
Firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000c8  00800200  00002fb8  0000304c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002fb8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ab0  008002c8  008002c8  00003114  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003114  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004e8  00000000  00000000  00003170  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005e98  00000000  00000000  00003658  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001625  00000000  00000000  000094f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000035f8  00000000  00000000  0000ab15  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001064  00000000  00000000  0000e110  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001b38  00000000  00000000  0000f174  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005278  00000000  00000000  00010cac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004d8  00000000  00000000  00015f24  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	c4 c0       	rjmp	.+392    	; 0x18a <__ctors_end>
       2:	00 00       	nop
       4:	a8 c3       	rjmp	.+1872   	; 0x756 <__vector_1>
       6:	00 00       	nop
       8:	e1 c0       	rjmp	.+450    	; 0x1cc <__bad_interrupt>
       a:	00 00       	nop
       c:	df c0       	rjmp	.+446    	; 0x1cc <__bad_interrupt>
       e:	00 00       	nop
      10:	dd c0       	rjmp	.+442    	; 0x1cc <__bad_interrupt>
      12:	00 00       	nop
      14:	db c0       	rjmp	.+438    	; 0x1cc <__bad_interrupt>
      16:	00 00       	nop
      18:	d9 c0       	rjmp	.+434    	; 0x1cc <__bad_interrupt>
      1a:	00 00       	nop
      1c:	d7 c0       	rjmp	.+430    	; 0x1cc <__bad_interrupt>
      1e:	00 00       	nop
      20:	d5 c0       	rjmp	.+426    	; 0x1cc <__bad_interrupt>
      22:	00 00       	nop
      24:	d3 c0       	rjmp	.+422    	; 0x1cc <__bad_interrupt>
      26:	00 00       	nop
      28:	d1 c0       	rjmp	.+418    	; 0x1cc <__bad_interrupt>
      2a:	00 00       	nop
      2c:	cf c0       	rjmp	.+414    	; 0x1cc <__bad_interrupt>
      2e:	00 00       	nop
      30:	cd c0       	rjmp	.+410    	; 0x1cc <__bad_interrupt>
      32:	00 00       	nop
      34:	c5 c3       	rjmp	.+1930   	; 0x7c0 <__vector_13>
      36:	00 00       	nop
      38:	c9 c0       	rjmp	.+402    	; 0x1cc <__bad_interrupt>
      3a:	00 00       	nop
      3c:	c7 c0       	rjmp	.+398    	; 0x1cc <__bad_interrupt>
      3e:	00 00       	nop
      40:	c5 c0       	rjmp	.+394    	; 0x1cc <__bad_interrupt>
      42:	00 00       	nop
      44:	c3 c0       	rjmp	.+390    	; 0x1cc <__bad_interrupt>
      46:	00 00       	nop
      48:	c1 c0       	rjmp	.+386    	; 0x1cc <__bad_interrupt>
      4a:	00 00       	nop
      4c:	bf c0       	rjmp	.+382    	; 0x1cc <__bad_interrupt>
      4e:	00 00       	nop
      50:	bd c0       	rjmp	.+378    	; 0x1cc <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 6f 08 	jmp	0x10de	; 0x10de <__vector_21>
      58:	b9 c0       	rjmp	.+370    	; 0x1cc <__bad_interrupt>
      5a:	00 00       	nop
      5c:	b7 c0       	rjmp	.+366    	; 0x1cc <__bad_interrupt>
      5e:	00 00       	nop
      60:	0c 94 16 13 	jmp	0x262c	; 0x262c <__vector_24>
      64:	0c 94 b2 10 	jmp	0x2164	; 0x2164 <__vector_25>
      68:	0c 94 f4 10 	jmp	0x21e8	; 0x21e8 <__vector_26>
      6c:	af c0       	rjmp	.+350    	; 0x1cc <__bad_interrupt>
      6e:	00 00       	nop
      70:	ad c0       	rjmp	.+346    	; 0x1cc <__bad_interrupt>
      72:	00 00       	nop
      74:	ab c0       	rjmp	.+342    	; 0x1cc <__bad_interrupt>
      76:	00 00       	nop
      78:	a9 c0       	rjmp	.+338    	; 0x1cc <__bad_interrupt>
      7a:	00 00       	nop
      7c:	a7 c0       	rjmp	.+334    	; 0x1cc <__bad_interrupt>
      7e:	00 00       	nop
      80:	a5 c0       	rjmp	.+330    	; 0x1cc <__bad_interrupt>
      82:	00 00       	nop
      84:	a3 c0       	rjmp	.+326    	; 0x1cc <__bad_interrupt>
      86:	00 00       	nop
      88:	a1 c0       	rjmp	.+322    	; 0x1cc <__bad_interrupt>
      8a:	00 00       	nop
      8c:	9f c0       	rjmp	.+318    	; 0x1cc <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 40 11 	jmp	0x2280	; 0x2280 <__vector_36>
      94:	0c 94 82 11 	jmp	0x2304	; 0x2304 <__vector_37>
      98:	99 c0       	rjmp	.+306    	; 0x1cc <__bad_interrupt>
      9a:	00 00       	nop
      9c:	97 c0       	rjmp	.+302    	; 0x1cc <__bad_interrupt>
      9e:	00 00       	nop
      a0:	95 c0       	rjmp	.+298    	; 0x1cc <__bad_interrupt>
      a2:	00 00       	nop
      a4:	93 c0       	rjmp	.+294    	; 0x1cc <__bad_interrupt>
      a6:	00 00       	nop
      a8:	91 c0       	rjmp	.+290    	; 0x1cc <__bad_interrupt>
      aa:	00 00       	nop
      ac:	8f c0       	rjmp	.+286    	; 0x1cc <__bad_interrupt>
      ae:	00 00       	nop
      b0:	8d c0       	rjmp	.+282    	; 0x1cc <__bad_interrupt>
      b2:	00 00       	nop
      b4:	8b c0       	rjmp	.+278    	; 0x1cc <__bad_interrupt>
      b6:	00 00       	nop
      b8:	89 c0       	rjmp	.+274    	; 0x1cc <__bad_interrupt>
      ba:	00 00       	nop
      bc:	87 c0       	rjmp	.+270    	; 0x1cc <__bad_interrupt>
      be:	00 00       	nop
      c0:	85 c0       	rjmp	.+266    	; 0x1cc <__bad_interrupt>
      c2:	00 00       	nop
      c4:	83 c0       	rjmp	.+262    	; 0x1cc <__bad_interrupt>
      c6:	00 00       	nop
      c8:	81 c0       	rjmp	.+258    	; 0x1cc <__bad_interrupt>
      ca:	00 00       	nop
      cc:	c8 0e       	add	r12, r24
      ce:	d0 0e       	add	r13, r16
      d0:	d8 0e       	add	r13, r24
      d2:	e0 0e       	add	r14, r16
      d4:	e8 0e       	add	r14, r24
      d6:	ec 0e       	add	r14, r28
      d8:	3c 0f       	add	r19, r28
      da:	7b 0f       	add	r23, r27
      dc:	7b 0f       	add	r23, r27
      de:	7b 0f       	add	r23, r27
      e0:	7b 0f       	add	r23, r27
      e2:	7b 0f       	add	r23, r27
      e4:	7b 0f       	add	r23, r27
      e6:	7b 0f       	add	r23, r27
      e8:	7b 0f       	add	r23, r27
      ea:	7b 0f       	add	r23, r27
      ec:	7b 0f       	add	r23, r27
      ee:	7b 0f       	add	r23, r27
      f0:	7b 0f       	add	r23, r27
      f2:	7b 0f       	add	r23, r27
      f4:	7b 0f       	add	r23, r27
      f6:	7b 0f       	add	r23, r27
      f8:	7b 0f       	add	r23, r27
      fa:	7b 0f       	add	r23, r27
      fc:	7b 0f       	add	r23, r27
      fe:	7b 0f       	add	r23, r27
     100:	7b 0f       	add	r23, r27
     102:	7b 0f       	add	r23, r27
     104:	7b 0f       	add	r23, r27
     106:	7b 0f       	add	r23, r27
     108:	7b 0f       	add	r23, r27
     10a:	7b 0f       	add	r23, r27
     10c:	c4 0e       	add	r12, r20
     10e:	cc 0e       	add	r12, r28
     110:	d4 0e       	add	r13, r20
     112:	dc 0e       	add	r13, r28
     114:	e4 0e       	add	r14, r20
     116:	17 0f       	add	r17, r23
     118:	5c 0f       	add	r21, r28

0000011a <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     11a:	0f 2e       	mov	r0, r31
     11c:	f1 e4       	ldi	r31, 0x41	; 65
     11e:	ef 2e       	mov	r14, r31
     120:	fd e0       	ldi	r31, 0x0D	; 13
     122:	ff 2e       	mov	r15, r31
     124:	f0 2d       	mov	r31, r0
     126:	c9 e1       	ldi	r28, 0x19	; 25
     128:	dd e0       	ldi	r29, 0x0D	; 13
     12a:	25 c0       	rjmp	.+74     	; 0x176 <prvIdleTask+0x5c>
     12c:	0e 94 24 0c 	call	0x1848	; 0x1848 <vTaskSuspendAll>
     130:	18 81       	ld	r17, Y
     132:	0e 94 e5 0c 	call	0x19ca	; 0x19ca <xTaskResumeAll>
     136:	11 23       	and	r17, r17
     138:	f1 f0       	breq	.+60     	; 0x176 <prvIdleTask+0x5c>
     13a:	0f b6       	in	r0, 0x3f	; 63
     13c:	f8 94       	cli
     13e:	0f 92       	push	r0
     140:	e0 91 1e 0d 	lds	r30, 0x0D1E
     144:	f0 91 1f 0d 	lds	r31, 0x0D1F
     148:	06 81       	ldd	r16, Z+6	; 0x06
     14a:	17 81       	ldd	r17, Z+7	; 0x07
     14c:	c8 01       	movw	r24, r16
     14e:	02 96       	adiw	r24, 0x02	; 2
     150:	13 d6       	rcall	.+3110   	; 0xd78 <uxListRemove>
     152:	80 91 17 0d 	lds	r24, 0x0D17
     156:	81 50       	subi	r24, 0x01	; 1
     158:	80 93 17 0d 	sts	0x0D17, r24
     15c:	80 91 18 0d 	lds	r24, 0x0D18
     160:	81 50       	subi	r24, 0x01	; 1
     162:	80 93 18 0d 	sts	0x0D18, r24
     166:	0f 90       	pop	r0
     168:	0f be       	out	0x3f, r0	; 63
     16a:	f8 01       	movw	r30, r16
     16c:	87 89       	ldd	r24, Z+23	; 0x17
     16e:	90 8d       	ldd	r25, Z+24	; 0x18
     170:	eb d7       	rcall	.+4054   	; 0x1148 <vPortFree>
     172:	c8 01       	movw	r24, r16
     174:	e9 d7       	rcall	.+4050   	; 0x1148 <vPortFree>
     176:	80 91 18 0d 	lds	r24, 0x0D18
     17a:	81 11       	cpse	r24, r1
     17c:	d7 cf       	rjmp	.-82     	; 0x12c <prvIdleTask+0x12>
     17e:	f7 01       	movw	r30, r14
     180:	80 81       	ld	r24, Z
     182:	82 30       	cpi	r24, 0x02	; 2
     184:	c0 f3       	brcs	.-16     	; 0x176 <prvIdleTask+0x5c>
     186:	d6 d6       	rcall	.+3500   	; 0xf34 <vPortYield>
     188:	f6 cf       	rjmp	.-20     	; 0x176 <prvIdleTask+0x5c>

0000018a <__ctors_end>:
     18a:	11 24       	eor	r1, r1
     18c:	1f be       	out	0x3f, r1	; 63
     18e:	cf ef       	ldi	r28, 0xFF	; 255
     190:	d1 e2       	ldi	r29, 0x21	; 33
     192:	de bf       	out	0x3e, r29	; 62
     194:	cd bf       	out	0x3d, r28	; 61
     196:	00 e0       	ldi	r16, 0x00	; 0
     198:	0c bf       	out	0x3c, r16	; 60

0000019a <__do_copy_data>:
     19a:	12 e0       	ldi	r17, 0x02	; 2
     19c:	a0 e0       	ldi	r26, 0x00	; 0
     19e:	b2 e0       	ldi	r27, 0x02	; 2
     1a0:	e8 eb       	ldi	r30, 0xB8	; 184
     1a2:	ff e2       	ldi	r31, 0x2F	; 47
     1a4:	00 e0       	ldi	r16, 0x00	; 0
     1a6:	0b bf       	out	0x3b, r16	; 59
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <__do_copy_data+0x14>
     1aa:	07 90       	elpm	r0, Z+
     1ac:	0d 92       	st	X+, r0
     1ae:	a8 3c       	cpi	r26, 0xC8	; 200
     1b0:	b1 07       	cpc	r27, r17
     1b2:	d9 f7       	brne	.-10     	; 0x1aa <__do_copy_data+0x10>

000001b4 <__do_clear_bss>:
     1b4:	2d e0       	ldi	r18, 0x0D	; 13
     1b6:	a8 ec       	ldi	r26, 0xC8	; 200
     1b8:	b2 e0       	ldi	r27, 0x02	; 2
     1ba:	01 c0       	rjmp	.+2      	; 0x1be <.do_clear_bss_start>

000001bc <.do_clear_bss_loop>:
     1bc:	1d 92       	st	X+, r1

000001be <.do_clear_bss_start>:
     1be:	a8 37       	cpi	r26, 0x78	; 120
     1c0:	b2 07       	cpc	r27, r18
     1c2:	e1 f7       	brne	.-8      	; 0x1bc <.do_clear_bss_loop>
     1c4:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <main>
     1c8:	0c 94 da 17 	jmp	0x2fb4	; 0x2fb4 <_exit>

000001cc <__bad_interrupt>:
     1cc:	19 cf       	rjmp	.-462    	; 0x0 <__vectors>

000001ce <_bt_status_call_back>:
}

// ----------------------------------------------------------------------------------------------------------------------
uint16_t get_tacho_count() {
	return 0;
}
     1ce:	10 92 f6 02 	sts	0x02F6, r1
     1d2:	e0 91 f4 02 	lds	r30, 0x02F4
     1d6:	f0 91 f5 02 	lds	r31, 0x02F5
     1da:	30 97       	sbiw	r30, 0x00	; 0
     1dc:	09 f0       	breq	.+2      	; 0x1e0 <_bt_status_call_back+0x12>
     1de:	19 95       	eicall
     1e0:	08 95       	ret

000001e2 <_bt_call_back>:
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
     1e6:	1f 92       	push	r1
     1e8:	1f 92       	push	r1
     1ea:	cd b7       	in	r28, 0x3d	; 61
     1ec:	de b7       	in	r29, 0x3e	; 62
     1ee:	6a 83       	std	Y+2, r22	; 0x02
     1f0:	80 91 f6 02 	lds	r24, 0x02F6
     1f4:	88 23       	and	r24, r24
     1f6:	19 f0       	breq	.+6      	; 0x1fe <_bt_call_back+0x1c>
     1f8:	86 2f       	mov	r24, r22
     1fa:	67 d4       	rcall	.+2254   	; 0xaca <dialog_byte_received>
     1fc:	13 c0       	rjmp	.+38     	; 0x224 <_bt_call_back+0x42>
     1fe:	80 91 f2 02 	lds	r24, 0x02F2
     202:	90 91 f3 02 	lds	r25, 0x02F3
     206:	00 97       	sbiw	r24, 0x00	; 0
     208:	69 f0       	breq	.+26     	; 0x224 <_bt_call_back+0x42>
     20a:	19 82       	std	Y+1, r1	; 0x01
     20c:	20 e0       	ldi	r18, 0x00	; 0
     20e:	ae 01       	movw	r20, r28
     210:	4f 5f       	subi	r20, 0xFF	; 255
     212:	5f 4f       	sbci	r21, 0xFF	; 255
     214:	be 01       	movw	r22, r28
     216:	6e 5f       	subi	r22, 0xFE	; 254
     218:	7f 4f       	sbci	r23, 0xFF	; 255
     21a:	0e 94 b6 09 	call	0x136c	; 0x136c <xQueueGenericSendFromISR>
     21e:	89 81       	ldd	r24, Y+1	; 0x01
     220:	81 11       	cpse	r24, r1
     222:	88 d6       	rcall	.+3344   	; 0xf34 <vPortYield>
     224:	0f 90       	pop	r0
     226:	0f 90       	pop	r0
     228:	df 91       	pop	r29
     22a:	cf 91       	pop	r28
     22c:	08 95       	ret

0000022e <_mpu9250_read_reg>:
     22e:	df 92       	push	r13
     230:	ef 92       	push	r14
     232:	ff 92       	push	r15
     234:	0f 93       	push	r16
     236:	1f 93       	push	r17
     238:	cf 93       	push	r28
     23a:	df 93       	push	r29
     23c:	cd b7       	in	r28, 0x3d	; 61
     23e:	de b7       	in	r29, 0x3e	; 62
     240:	d6 2e       	mov	r13, r22
     242:	ed b6       	in	r14, 0x3d	; 61
     244:	fe b6       	in	r15, 0x3e	; 62
     246:	26 2f       	mov	r18, r22
     248:	30 e0       	ldi	r19, 0x00	; 0
     24a:	2f 5f       	subi	r18, 0xFF	; 255
     24c:	3f 4f       	sbci	r19, 0xFF	; 255
     24e:	4d b7       	in	r20, 0x3d	; 61
     250:	5e b7       	in	r21, 0x3e	; 62
     252:	42 1b       	sub	r20, r18
     254:	53 0b       	sbc	r21, r19
     256:	0f b6       	in	r0, 0x3f	; 63
     258:	f8 94       	cli
     25a:	5e bf       	out	0x3e, r21	; 62
     25c:	0f be       	out	0x3f, r0	; 63
     25e:	4d bf       	out	0x3d, r20	; 61
     260:	0d b7       	in	r16, 0x3d	; 61
     262:	1e b7       	in	r17, 0x3e	; 62
     264:	0f 5f       	subi	r16, 0xFF	; 255
     266:	1f 4f       	sbci	r17, 0xFF	; 255
     268:	98 01       	movw	r18, r16
     26a:	80 68       	ori	r24, 0x80	; 128
     26c:	ed b7       	in	r30, 0x3d	; 61
     26e:	fe b7       	in	r31, 0x3e	; 62
     270:	81 83       	std	Z+1, r24	; 0x01
     272:	66 23       	and	r22, r22
     274:	41 f0       	breq	.+16     	; 0x286 <_mpu9250_read_reg+0x58>
     276:	81 e0       	ldi	r24, 0x01	; 1
     278:	f9 01       	movw	r30, r18
     27a:	e8 0f       	add	r30, r24
     27c:	f1 1d       	adc	r31, r1
     27e:	10 82       	st	Z, r1
     280:	8f 5f       	subi	r24, 0xFF	; 255
     282:	d8 16       	cp	r13, r24
     284:	c8 f7       	brcc	.-14     	; 0x278 <_mpu9250_read_reg+0x4a>
     286:	86 e1       	ldi	r24, 0x16	; 22
     288:	93 e0       	ldi	r25, 0x03	; 3
     28a:	04 d3       	rcall	.+1544   	; 0x894 <buffer_clear>
     28c:	41 e0       	ldi	r20, 0x01	; 1
     28e:	4d 0d       	add	r20, r13
     290:	b8 01       	movw	r22, r16
     292:	80 91 2b 03 	lds	r24, 0x032B
     296:	90 91 2c 03 	lds	r25, 0x032C
     29a:	0e 94 95 12 	call	0x252a	; 0x252a <spi_send_string>
     29e:	0f b6       	in	r0, 0x3f	; 63
     2a0:	f8 94       	cli
     2a2:	fe be       	out	0x3e, r15	; 62
     2a4:	0f be       	out	0x3f, r0	; 63
     2a6:	ed be       	out	0x3d, r14	; 61
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	1f 91       	pop	r17
     2ae:	0f 91       	pop	r16
     2b0:	ff 90       	pop	r15
     2b2:	ef 90       	pop	r14
     2b4:	df 90       	pop	r13
     2b6:	08 95       	ret

000002b8 <_send_bytes_to_bt>:
     2b8:	46 2f       	mov	r20, r22
     2ba:	bc 01       	movw	r22, r24
     2bc:	80 91 29 03 	lds	r24, 0x0329
     2c0:	90 91 2a 03 	lds	r25, 0x032A
     2c4:	0c 94 73 10 	jmp	0x20e6	; 0x20e6 <serial_send_bytes>
     2c8:	08 95       	ret

000002ca <_mpu9250_call_back>:
     2ca:	cf 93       	push	r28
     2cc:	df 93       	push	r29
     2ce:	00 d0       	rcall	.+0      	; 0x2d0 <_mpu9250_call_back+0x6>
     2d0:	1f 92       	push	r1
     2d2:	cd b7       	in	r28, 0x3d	; 61
     2d4:	de b7       	in	r29, 0x3e	; 62
     2d6:	80 91 c9 02 	lds	r24, 0x02C9
     2da:	82 30       	cpi	r24, 0x02	; 2
     2dc:	c1 f1       	breq	.+112    	; 0x34e <_mpu9250_call_back+0x84>
     2de:	28 f4       	brcc	.+10     	; 0x2ea <_mpu9250_call_back+0x20>
     2e0:	88 23       	and	r24, r24
     2e2:	51 f0       	breq	.+20     	; 0x2f8 <_mpu9250_call_back+0x2e>
     2e4:	81 30       	cpi	r24, 0x01	; 1
     2e6:	c9 f0       	breq	.+50     	; 0x31a <_mpu9250_call_back+0x50>
     2e8:	eb c0       	rjmp	.+470    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     2ea:	83 30       	cpi	r24, 0x03	; 3
     2ec:	09 f4       	brne	.+2      	; 0x2f0 <_mpu9250_call_back+0x26>
     2ee:	3f c0       	rjmp	.+126    	; 0x36e <_mpu9250_call_back+0xa4>
     2f0:	85 30       	cpi	r24, 0x05	; 5
     2f2:	09 f4       	brne	.+2      	; 0x2f6 <_mpu9250_call_back+0x2c>
     2f4:	91 c0       	rjmp	.+290    	; 0x418 <_mpu9250_call_back+0x14e>
     2f6:	e4 c0       	rjmp	.+456    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     2f8:	81 e0       	ldi	r24, 0x01	; 1
     2fa:	80 93 c9 02 	sts	0x02C9, r24
     2fe:	8c e1       	ldi	r24, 0x1C	; 28
     300:	8b 83       	std	Y+3, r24	; 0x03
     302:	1c 82       	std	Y+4, r1	; 0x04
     304:	42 e0       	ldi	r20, 0x02	; 2
     306:	be 01       	movw	r22, r28
     308:	6d 5f       	subi	r22, 0xFD	; 253
     30a:	7f 4f       	sbci	r23, 0xFF	; 255
     30c:	80 91 2b 03 	lds	r24, 0x032B
     310:	90 91 2c 03 	lds	r25, 0x032C
     314:	0e 94 95 12 	call	0x252a	; 0x252a <spi_send_string>
     318:	d3 c0       	rjmp	.+422    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     31a:	86 e1       	ldi	r24, 0x16	; 22
     31c:	93 e0       	ldi	r25, 0x03	; 3
     31e:	b7 d2       	rcall	.+1390   	; 0x88e <buffer_no_of_items>
     320:	82 30       	cpi	r24, 0x02	; 2
     322:	09 f0       	breq	.+2      	; 0x326 <_mpu9250_call_back+0x5c>
     324:	cd c0       	rjmp	.+410    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     326:	80 93 c9 02 	sts	0x02C9, r24
     32a:	86 e1       	ldi	r24, 0x16	; 22
     32c:	93 e0       	ldi	r25, 0x03	; 3
     32e:	b2 d2       	rcall	.+1380   	; 0x894 <buffer_clear>
     330:	8b e1       	ldi	r24, 0x1B	; 27
     332:	8b 83       	std	Y+3, r24	; 0x03
     334:	88 e0       	ldi	r24, 0x08	; 8
     336:	8c 83       	std	Y+4, r24	; 0x04
     338:	42 e0       	ldi	r20, 0x02	; 2
     33a:	be 01       	movw	r22, r28
     33c:	6d 5f       	subi	r22, 0xFD	; 253
     33e:	7f 4f       	sbci	r23, 0xFF	; 255
     340:	80 91 2b 03 	lds	r24, 0x032B
     344:	90 91 2c 03 	lds	r25, 0x032C
     348:	0e 94 95 12 	call	0x252a	; 0x252a <spi_send_string>
     34c:	b9 c0       	rjmp	.+370    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     34e:	86 e1       	ldi	r24, 0x16	; 22
     350:	93 e0       	ldi	r25, 0x03	; 3
     352:	9d d2       	rcall	.+1338   	; 0x88e <buffer_no_of_items>
     354:	82 30       	cpi	r24, 0x02	; 2
     356:	09 f0       	breq	.+2      	; 0x35a <_mpu9250_call_back+0x90>
     358:	b3 c0       	rjmp	.+358    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     35a:	83 e0       	ldi	r24, 0x03	; 3
     35c:	80 93 c9 02 	sts	0x02C9, r24
     360:	86 e1       	ldi	r24, 0x16	; 22
     362:	93 e0       	ldi	r25, 0x03	; 3
     364:	97 d2       	rcall	.+1326   	; 0x894 <buffer_clear>
     366:	66 e0       	ldi	r22, 0x06	; 6
     368:	8b e3       	ldi	r24, 0x3B	; 59
     36a:	61 df       	rcall	.-318    	; 0x22e <_mpu9250_read_reg>
     36c:	a9 c0       	rjmp	.+338    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     36e:	86 e1       	ldi	r24, 0x16	; 22
     370:	93 e0       	ldi	r25, 0x03	; 3
     372:	8d d2       	rcall	.+1306   	; 0x88e <buffer_no_of_items>
     374:	87 30       	cpi	r24, 0x07	; 7
     376:	09 f0       	breq	.+2      	; 0x37a <_mpu9250_call_back+0xb0>
     378:	a3 c0       	rjmp	.+326    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     37a:	be 01       	movw	r22, r28
     37c:	6f 5f       	subi	r22, 0xFF	; 255
     37e:	7f 4f       	sbci	r23, 0xFF	; 255
     380:	86 e1       	ldi	r24, 0x16	; 22
     382:	93 e0       	ldi	r25, 0x03	; 3
     384:	57 d2       	rcall	.+1198   	; 0x834 <buffer_get_item>
     386:	be 01       	movw	r22, r28
     388:	6e 5f       	subi	r22, 0xFE	; 254
     38a:	7f 4f       	sbci	r23, 0xFF	; 255
     38c:	86 e1       	ldi	r24, 0x16	; 22
     38e:	93 e0       	ldi	r25, 0x03	; 3
     390:	51 d2       	rcall	.+1186   	; 0x834 <buffer_get_item>
     392:	be 01       	movw	r22, r28
     394:	6f 5f       	subi	r22, 0xFF	; 255
     396:	7f 4f       	sbci	r23, 0xFF	; 255
     398:	86 e1       	ldi	r24, 0x16	; 22
     39a:	93 e0       	ldi	r25, 0x03	; 3
     39c:	4b d2       	rcall	.+1174   	; 0x834 <buffer_get_item>
     39e:	8a 81       	ldd	r24, Y+2	; 0x02
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	98 2f       	mov	r25, r24
     3a4:	88 27       	eor	r24, r24
     3a6:	29 81       	ldd	r18, Y+1	; 0x01
     3a8:	82 2b       	or	r24, r18
     3aa:	90 93 02 03 	sts	0x0302, r25
     3ae:	80 93 01 03 	sts	0x0301, r24
     3b2:	be 01       	movw	r22, r28
     3b4:	6e 5f       	subi	r22, 0xFE	; 254
     3b6:	7f 4f       	sbci	r23, 0xFF	; 255
     3b8:	86 e1       	ldi	r24, 0x16	; 22
     3ba:	93 e0       	ldi	r25, 0x03	; 3
     3bc:	3b d2       	rcall	.+1142   	; 0x834 <buffer_get_item>
     3be:	be 01       	movw	r22, r28
     3c0:	6f 5f       	subi	r22, 0xFF	; 255
     3c2:	7f 4f       	sbci	r23, 0xFF	; 255
     3c4:	86 e1       	ldi	r24, 0x16	; 22
     3c6:	93 e0       	ldi	r25, 0x03	; 3
     3c8:	35 d2       	rcall	.+1130   	; 0x834 <buffer_get_item>
     3ca:	8a 81       	ldd	r24, Y+2	; 0x02
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	98 2f       	mov	r25, r24
     3d0:	88 27       	eor	r24, r24
     3d2:	29 81       	ldd	r18, Y+1	; 0x01
     3d4:	82 2b       	or	r24, r18
     3d6:	90 93 00 03 	sts	0x0300, r25
     3da:	80 93 ff 02 	sts	0x02FF, r24
     3de:	be 01       	movw	r22, r28
     3e0:	6e 5f       	subi	r22, 0xFE	; 254
     3e2:	7f 4f       	sbci	r23, 0xFF	; 255
     3e4:	86 e1       	ldi	r24, 0x16	; 22
     3e6:	93 e0       	ldi	r25, 0x03	; 3
     3e8:	25 d2       	rcall	.+1098   	; 0x834 <buffer_get_item>
     3ea:	be 01       	movw	r22, r28
     3ec:	6f 5f       	subi	r22, 0xFF	; 255
     3ee:	7f 4f       	sbci	r23, 0xFF	; 255
     3f0:	86 e1       	ldi	r24, 0x16	; 22
     3f2:	93 e0       	ldi	r25, 0x03	; 3
     3f4:	1f d2       	rcall	.+1086   	; 0x834 <buffer_get_item>
     3f6:	8a 81       	ldd	r24, Y+2	; 0x02
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	98 2f       	mov	r25, r24
     3fc:	88 27       	eor	r24, r24
     3fe:	29 81       	ldd	r18, Y+1	; 0x01
     400:	82 2b       	or	r24, r18
     402:	90 93 fe 02 	sts	0x02FE, r25
     406:	80 93 fd 02 	sts	0x02FD, r24
     40a:	85 e0       	ldi	r24, 0x05	; 5
     40c:	80 93 c9 02 	sts	0x02C9, r24
     410:	66 e0       	ldi	r22, 0x06	; 6
     412:	83 e4       	ldi	r24, 0x43	; 67
     414:	0c df       	rcall	.-488    	; 0x22e <_mpu9250_read_reg>
     416:	54 c0       	rjmp	.+168    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     418:	86 e1       	ldi	r24, 0x16	; 22
     41a:	93 e0       	ldi	r25, 0x03	; 3
     41c:	38 d2       	rcall	.+1136   	; 0x88e <buffer_no_of_items>
     41e:	87 30       	cpi	r24, 0x07	; 7
     420:	09 f0       	breq	.+2      	; 0x424 <_mpu9250_call_back+0x15a>
     422:	4e c0       	rjmp	.+156    	; 0x4c0 <_mpu9250_call_back+0x1f6>
     424:	be 01       	movw	r22, r28
     426:	6f 5f       	subi	r22, 0xFF	; 255
     428:	7f 4f       	sbci	r23, 0xFF	; 255
     42a:	86 e1       	ldi	r24, 0x16	; 22
     42c:	93 e0       	ldi	r25, 0x03	; 3
     42e:	02 d2       	rcall	.+1028   	; 0x834 <buffer_get_item>
     430:	be 01       	movw	r22, r28
     432:	6e 5f       	subi	r22, 0xFE	; 254
     434:	7f 4f       	sbci	r23, 0xFF	; 255
     436:	86 e1       	ldi	r24, 0x16	; 22
     438:	93 e0       	ldi	r25, 0x03	; 3
     43a:	fc d1       	rcall	.+1016   	; 0x834 <buffer_get_item>
     43c:	be 01       	movw	r22, r28
     43e:	6f 5f       	subi	r22, 0xFF	; 255
     440:	7f 4f       	sbci	r23, 0xFF	; 255
     442:	86 e1       	ldi	r24, 0x16	; 22
     444:	93 e0       	ldi	r25, 0x03	; 3
     446:	f6 d1       	rcall	.+1004   	; 0x834 <buffer_get_item>
     448:	8a 81       	ldd	r24, Y+2	; 0x02
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	98 2f       	mov	r25, r24
     44e:	88 27       	eor	r24, r24
     450:	29 81       	ldd	r18, Y+1	; 0x01
     452:	82 2b       	or	r24, r18
     454:	90 93 fc 02 	sts	0x02FC, r25
     458:	80 93 fb 02 	sts	0x02FB, r24
     45c:	be 01       	movw	r22, r28
     45e:	6e 5f       	subi	r22, 0xFE	; 254
     460:	7f 4f       	sbci	r23, 0xFF	; 255
     462:	86 e1       	ldi	r24, 0x16	; 22
     464:	93 e0       	ldi	r25, 0x03	; 3
     466:	e6 d1       	rcall	.+972    	; 0x834 <buffer_get_item>
     468:	be 01       	movw	r22, r28
     46a:	6f 5f       	subi	r22, 0xFF	; 255
     46c:	7f 4f       	sbci	r23, 0xFF	; 255
     46e:	86 e1       	ldi	r24, 0x16	; 22
     470:	93 e0       	ldi	r25, 0x03	; 3
     472:	e0 d1       	rcall	.+960    	; 0x834 <buffer_get_item>
     474:	8a 81       	ldd	r24, Y+2	; 0x02
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	98 2f       	mov	r25, r24
     47a:	88 27       	eor	r24, r24
     47c:	29 81       	ldd	r18, Y+1	; 0x01
     47e:	82 2b       	or	r24, r18
     480:	90 93 fa 02 	sts	0x02FA, r25
     484:	80 93 f9 02 	sts	0x02F9, r24
     488:	be 01       	movw	r22, r28
     48a:	6e 5f       	subi	r22, 0xFE	; 254
     48c:	7f 4f       	sbci	r23, 0xFF	; 255
     48e:	86 e1       	ldi	r24, 0x16	; 22
     490:	93 e0       	ldi	r25, 0x03	; 3
     492:	d0 d1       	rcall	.+928    	; 0x834 <buffer_get_item>
     494:	be 01       	movw	r22, r28
     496:	6f 5f       	subi	r22, 0xFF	; 255
     498:	7f 4f       	sbci	r23, 0xFF	; 255
     49a:	86 e1       	ldi	r24, 0x16	; 22
     49c:	93 e0       	ldi	r25, 0x03	; 3
     49e:	ca d1       	rcall	.+916    	; 0x834 <buffer_get_item>
     4a0:	8a 81       	ldd	r24, Y+2	; 0x02
     4a2:	90 e0       	ldi	r25, 0x00	; 0
     4a4:	98 2f       	mov	r25, r24
     4a6:	88 27       	eor	r24, r24
     4a8:	29 81       	ldd	r18, Y+1	; 0x01
     4aa:	82 2b       	or	r24, r18
     4ac:	90 93 f8 02 	sts	0x02F8, r25
     4b0:	80 93 f7 02 	sts	0x02F7, r24
     4b4:	83 e0       	ldi	r24, 0x03	; 3
     4b6:	80 93 c9 02 	sts	0x02C9, r24
     4ba:	66 e0       	ldi	r22, 0x06	; 6
     4bc:	8b e3       	ldi	r24, 0x3B	; 59
     4be:	b7 de       	rcall	.-658    	; 0x22e <_mpu9250_read_reg>
     4c0:	0f 90       	pop	r0
     4c2:	0f 90       	pop	r0
     4c4:	0f 90       	pop	r0
     4c6:	0f 90       	pop	r0
     4c8:	df 91       	pop	r29
     4ca:	cf 91       	pop	r28
     4cc:	08 95       	ret

000004ce <set_horn>:
     4ce:	88 23       	and	r24, r24
     4d0:	11 f0       	breq	.+4      	; 0x4d6 <set_horn+0x8>
     4d2:	43 9a       	sbi	0x08, 3	; 8
     4d4:	08 95       	ret
     4d6:	43 98       	cbi	0x08, 3	; 8
     4d8:	08 95       	ret

000004da <set_head_light>:
     4da:	88 23       	and	r24, r24
     4dc:	11 f0       	breq	.+4      	; 0x4e2 <set_head_light+0x8>
     4de:	42 9a       	sbi	0x08, 2	; 8
     4e0:	08 95       	ret
     4e2:	42 98       	cbi	0x08, 2	; 8
     4e4:	08 95       	ret

000004e6 <set_brake_light>:
     4e6:	88 23       	and	r24, r24
     4e8:	11 f0       	breq	.+4      	; 0x4ee <set_brake_light+0x8>
     4ea:	41 9a       	sbi	0x08, 1	; 8
     4ec:	08 95       	ret
     4ee:	41 98       	cbi	0x08, 1	; 8
     4f0:	08 95       	ret

000004f2 <set_motor_speed>:
     4f2:	85 36       	cpi	r24, 0x65	; 101
     4f4:	08 f0       	brcs	.+2      	; 0x4f8 <set_motor_speed+0x6>
     4f6:	84 e6       	ldi	r24, 0x64	; 100
     4f8:	88 23       	and	r24, r24
     4fa:	a9 f0       	breq	.+42     	; 0x526 <set_motor_speed+0x34>
     4fc:	28 2f       	mov	r18, r24
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	af e7       	ldi	r26, 0x7F	; 127
     502:	bc e0       	ldi	r27, 0x0C	; 12
     504:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <__umulhisi3>
     508:	24 e6       	ldi	r18, 0x64	; 100
     50a:	30 e0       	ldi	r19, 0x00	; 0
     50c:	40 e0       	ldi	r20, 0x00	; 0
     50e:	50 e0       	ldi	r21, 0x00	; 0
     510:	0e 94 b7 13 	call	0x276e	; 0x276e <__divmodsi4>
     514:	30 93 99 00 	sts	0x0099, r19
     518:	20 93 98 00 	sts	0x0098, r18
     51c:	30 93 9b 00 	sts	0x009B, r19
     520:	20 93 9a 00 	sts	0x009A, r18
     524:	08 95       	ret
     526:	10 92 99 00 	sts	0x0099, r1
     52a:	10 92 98 00 	sts	0x0098, r1
     52e:	10 92 9b 00 	sts	0x009B, r1
     532:	10 92 9a 00 	sts	0x009A, r1
     536:	08 95       	ret

00000538 <init_main_board>:
     538:	8f 92       	push	r8
     53a:	9f 92       	push	r9
     53c:	af 92       	push	r10
     53e:	bf 92       	push	r11
     540:	cf 92       	push	r12
     542:	df 92       	push	r13
     544:	ef 92       	push	r14
     546:	0f 93       	push	r16
     548:	1f 93       	push	r17
     54a:	3b 9a       	sbi	0x07, 3	; 7
     54c:	3a 9a       	sbi	0x07, 2	; 7
     54e:	39 9a       	sbi	0x07, 1	; 7
     550:	38 9a       	sbi	0x07, 0	; 7
     552:	e0 e9       	ldi	r30, 0x90	; 144
     554:	f0 e0       	ldi	r31, 0x00	; 0
     556:	80 81       	ld	r24, Z
     558:	82 60       	ori	r24, 0x02	; 2
     55a:	80 83       	st	Z, r24
     55c:	a1 e9       	ldi	r26, 0x91	; 145
     55e:	b0 e0       	ldi	r27, 0x00	; 0
     560:	8c 91       	ld	r24, X
     562:	88 61       	ori	r24, 0x18	; 24
     564:	8c 93       	st	X, r24
     566:	8f e7       	ldi	r24, 0x7F	; 127
     568:	9c e0       	ldi	r25, 0x0C	; 12
     56a:	90 93 99 00 	sts	0x0099, r25
     56e:	80 93 98 00 	sts	0x0098, r24
     572:	20 81       	ld	r18, Z
     574:	20 6c       	ori	r18, 0xC0	; 192
     576:	20 83       	st	Z, r18
     578:	6b 9a       	sbi	0x0d, 3	; 13
     57a:	90 93 9b 00 	sts	0x009B, r25
     57e:	80 93 9a 00 	sts	0x009A, r24
     582:	20 81       	ld	r18, Z
     584:	20 63       	ori	r18, 0x30	; 48
     586:	20 83       	st	Z, r18
     588:	6c 9a       	sbi	0x0d, 4	; 13
     58a:	90 93 97 00 	sts	0x0097, r25
     58e:	80 93 96 00 	sts	0x0096, r24
     592:	8c 91       	ld	r24, X
     594:	81 60       	ori	r24, 0x01	; 1
     596:	8c 93       	st	X, r24
     598:	80 e0       	ldi	r24, 0x00	; 0
     59a:	ab df       	rcall	.-170    	; 0x4f2 <set_motor_speed>
     59c:	6a 98       	cbi	0x0d, 2	; 13
     59e:	6d 9a       	sbi	0x0d, 5	; 13
     5a0:	75 98       	cbi	0x0e, 5	; 14
     5a2:	08 9a       	sbi	0x01, 0	; 1
     5a4:	10 98       	cbi	0x02, 0	; 2
     5a6:	09 9a       	sbi	0x01, 1	; 1
     5a8:	11 98       	cbi	0x02, 1	; 2
     5aa:	0a 9a       	sbi	0x01, 2	; 1
     5ac:	12 98       	cbi	0x02, 2	; 2
     5ae:	e9 e6       	ldi	r30, 0x69	; 105
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	80 81       	ld	r24, Z
     5b4:	82 60       	ori	r24, 0x02	; 2
     5b6:	80 83       	st	Z, r24
     5b8:	e8 9a       	sbi	0x1d, 0	; 29
     5ba:	8d ed       	ldi	r24, 0xDD	; 221
     5bc:	92 e0       	ldi	r25, 0x02	; 2
     5be:	35 d1       	rcall	.+618    	; 0x82a <buffer_init>
     5c0:	8a ec       	ldi	r24, 0xCA	; 202
     5c2:	92 e0       	ldi	r25, 0x02	; 2
     5c4:	32 d1       	rcall	.+612    	; 0x82a <buffer_init>
     5c6:	0f 2e       	mov	r0, r31
     5c8:	f1 ef       	ldi	r31, 0xF1	; 241
     5ca:	8f 2e       	mov	r8, r31
     5cc:	f0 e0       	ldi	r31, 0x00	; 0
     5ce:	9f 2e       	mov	r9, r31
     5d0:	f0 2d       	mov	r31, r0
     5d2:	0f 2e       	mov	r0, r31
     5d4:	fa ec       	ldi	r31, 0xCA	; 202
     5d6:	af 2e       	mov	r10, r31
     5d8:	f2 e0       	ldi	r31, 0x02	; 2
     5da:	bf 2e       	mov	r11, r31
     5dc:	f0 2d       	mov	r31, r0
     5de:	0f 2e       	mov	r0, r31
     5e0:	fd ed       	ldi	r31, 0xDD	; 221
     5e2:	cf 2e       	mov	r12, r31
     5e4:	f2 e0       	ldi	r31, 0x02	; 2
     5e6:	df 2e       	mov	r13, r31
     5e8:	f0 2d       	mov	r31, r0
     5ea:	e1 2c       	mov	r14, r1
     5ec:	00 e0       	ldi	r16, 0x00	; 0
     5ee:	23 e0       	ldi	r18, 0x03	; 3
     5f0:	40 e8       	ldi	r20, 0x80	; 128
     5f2:	55 e2       	ldi	r21, 0x25	; 37
     5f4:	60 e0       	ldi	r22, 0x00	; 0
     5f6:	70 e0       	ldi	r23, 0x00	; 0
     5f8:	80 e0       	ldi	r24, 0x00	; 0
     5fa:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <serial_new_instance>
     5fe:	90 93 2a 03 	sts	0x032A, r25
     602:	80 93 29 03 	sts	0x0329, r24
     606:	86 e1       	ldi	r24, 0x16	; 22
     608:	93 e0       	ldi	r25, 0x03	; 3
     60a:	0f d1       	rcall	.+542    	; 0x82a <buffer_init>
     60c:	83 e0       	ldi	r24, 0x03	; 3
     60e:	93 e0       	ldi	r25, 0x03	; 3
     610:	0c d1       	rcall	.+536    	; 0x82a <buffer_init>
     612:	85 e6       	ldi	r24, 0x65	; 101
     614:	91 e0       	ldi	r25, 0x01	; 1
     616:	9f 93       	push	r25
     618:	8f 93       	push	r24
     61a:	0f 2e       	mov	r0, r31
     61c:	f3 e0       	ldi	r31, 0x03	; 3
     61e:	8f 2e       	mov	r8, r31
     620:	f3 e0       	ldi	r31, 0x03	; 3
     622:	9f 2e       	mov	r9, r31
     624:	f0 2d       	mov	r31, r0
     626:	0f 2e       	mov	r0, r31
     628:	f6 e1       	ldi	r31, 0x16	; 22
     62a:	af 2e       	mov	r10, r31
     62c:	f3 e0       	ldi	r31, 0x03	; 3
     62e:	bf 2e       	mov	r11, r31
     630:	f0 2d       	mov	r31, r0
     632:	c1 2c       	mov	r12, r1
     634:	05 e2       	ldi	r16, 0x25	; 37
     636:	10 e0       	ldi	r17, 0x00	; 0
     638:	20 e0       	ldi	r18, 0x00	; 0
     63a:	43 e0       	ldi	r20, 0x03	; 3
     63c:	63 e0       	ldi	r22, 0x03	; 3
     63e:	80 e1       	ldi	r24, 0x10	; 16
     640:	0e 94 08 12 	call	0x2410	; 0x2410 <spi_new_instance>
     644:	90 93 2c 03 	sts	0x032C, r25
     648:	80 93 2b 03 	sts	0x032B, r24
     64c:	60 e0       	ldi	r22, 0x00	; 0
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	3b de       	rcall	.-906    	; 0x2ca <_mpu9250_call_back>
     654:	8b e9       	ldi	r24, 0x9B	; 155
     656:	80 93 b3 00 	sts	0x00B3, r24
     65a:	e1 eb       	ldi	r30, 0xB1	; 177
     65c:	f0 e0       	ldi	r31, 0x00	; 0
     65e:	80 81       	ld	r24, Z
     660:	82 60       	ori	r24, 0x02	; 2
     662:	80 83       	st	Z, r24
     664:	a0 e7       	ldi	r26, 0x70	; 112
     666:	b0 e0       	ldi	r27, 0x00	; 0
     668:	8c 91       	ld	r24, X
     66a:	82 60       	ori	r24, 0x02	; 2
     66c:	8c 93       	st	X, r24
     66e:	80 81       	ld	r24, Z
     670:	85 60       	ori	r24, 0x05	; 5
     672:	80 83       	st	Z, r24
     674:	0f 90       	pop	r0
     676:	0f 90       	pop	r0
     678:	1f 91       	pop	r17
     67a:	0f 91       	pop	r16
     67c:	ef 90       	pop	r14
     67e:	df 90       	pop	r13
     680:	cf 90       	pop	r12
     682:	bf 90       	pop	r11
     684:	af 90       	pop	r10
     686:	9f 90       	pop	r9
     688:	8f 90       	pop	r8
     68a:	08 95       	ret

0000068c <set_brake>:
     68c:	85 36       	cpi	r24, 0x65	; 101
     68e:	08 f0       	brcs	.+2      	; 0x692 <set_brake+0x6>
     690:	84 e6       	ldi	r24, 0x64	; 100
     692:	88 23       	and	r24, r24
     694:	a9 f0       	breq	.+42     	; 0x6c0 <set_brake+0x34>
     696:	28 2f       	mov	r18, r24
     698:	30 e0       	ldi	r19, 0x00	; 0
     69a:	af e7       	ldi	r26, 0x7F	; 127
     69c:	bc e0       	ldi	r27, 0x0C	; 12
     69e:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <__umulhisi3>
     6a2:	24 e6       	ldi	r18, 0x64	; 100
     6a4:	30 e0       	ldi	r19, 0x00	; 0
     6a6:	40 e0       	ldi	r20, 0x00	; 0
     6a8:	50 e0       	ldi	r21, 0x00	; 0
     6aa:	0e 94 b7 13 	call	0x276e	; 0x276e <__divmodsi4>
     6ae:	30 93 99 00 	sts	0x0099, r19
     6b2:	20 93 98 00 	sts	0x0098, r18
     6b6:	10 92 9b 00 	sts	0x009B, r1
     6ba:	10 92 9a 00 	sts	0x009A, r1
     6be:	08 95       	ret
     6c0:	10 92 99 00 	sts	0x0099, r1
     6c4:	10 92 98 00 	sts	0x0098, r1
     6c8:	10 92 9b 00 	sts	0x009B, r1
     6cc:	10 92 9a 00 	sts	0x009A, r1
     6d0:	08 95       	ret

000006d2 <get_raw_x_accel>:
     6d2:	80 91 01 03 	lds	r24, 0x0301
     6d6:	90 91 02 03 	lds	r25, 0x0302
     6da:	08 95       	ret

000006dc <get_raw_y_accel>:
     6dc:	80 91 ff 02 	lds	r24, 0x02FF
     6e0:	90 91 00 03 	lds	r25, 0x0300
     6e4:	08 95       	ret

000006e6 <get_raw_z_accel>:
     6e6:	80 91 fd 02 	lds	r24, 0x02FD
     6ea:	90 91 fe 02 	lds	r25, 0x02FE
     6ee:	08 95       	ret

000006f0 <get_raw_x_rotation>:
     6f0:	80 91 fb 02 	lds	r24, 0x02FB
     6f4:	90 91 fc 02 	lds	r25, 0x02FC
     6f8:	08 95       	ret

000006fa <get_raw_y_rotation>:
     6fa:	80 91 f9 02 	lds	r24, 0x02F9
     6fe:	90 91 fa 02 	lds	r25, 0x02FA
     702:	08 95       	ret

00000704 <set_bt_reset>:

// ----------------------------------------------------------------------------------------------------------------------
void set_bt_reset(uint8_t state) {
	if (state) {
     704:	88 23       	and	r24, r24
     706:	11 f0       	breq	.+4      	; 0x70c <set_bt_reset+0x8>
		BT_RESET_PORT &= ~_BV(BT_RESET_PIN); // Set RESET low/active
     708:	10 98       	cbi	0x02, 0	; 2
     70a:	08 95       	ret
		} else {
		BT_RESET_PORT |= _BV(BT_RESET_PIN); // Set RESET high/in-active
     70c:	10 9a       	sbi	0x02, 0	; 2
     70e:	08 95       	ret

00000710 <bt_send_bytes>:
static void _send_bytes_to_bt(uint8_t *bytes, uint8_t len) {
	serial_send_bytes(_bt_serial_instance, bytes, len);
}

// ----------------------------------------------------------------------------------------------------------------------
void bt_send_bytes(uint8_t *bytes, uint8_t len) {
     710:	46 2f       	mov	r20, r22
	serial_send_bytes(_bt_serial_instance, bytes, len);
     712:	bc 01       	movw	r22, r24
     714:	80 91 29 03 	lds	r24, 0x0329
     718:	90 91 2a 03 	lds	r25, 0x032A
     71c:	0c 94 73 10 	jmp	0x20e6	; 0x20e6 <serial_send_bytes>
     720:	08 95       	ret

00000722 <init_bt_module>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void init_bt_module(void (*bt_status_call_back)(uint8_t result), QueueHandle_t RX_Que) {
	_xRxedCharsQ = RX_Que;
     722:	70 93 f3 02 	sts	0x02F3, r23
     726:	60 93 f2 02 	sts	0x02F2, r22
	_app_bt_status_call_back = bt_status_call_back;
     72a:	90 93 f5 02 	sts	0x02F5, r25
     72e:	80 93 f4 02 	sts	0x02F4, r24
	_bt_dialog_active = 1;
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	80 93 f6 02 	sts	0x02F6, r24
	dialog_start(_dialog_bt_init_seq, _send_bytes_to_bt, _bt_status_call_back);
     738:	47 ee       	ldi	r20, 0xE7	; 231
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	6c e5       	ldi	r22, 0x5C	; 92
     73e:	71 e0       	ldi	r23, 0x01	; 1
     740:	87 e0       	ldi	r24, 0x07	; 7
     742:	92 e0       	ldi	r25, 0x02	; 2
     744:	9a c1       	rjmp	.+820    	; 0xa7a <dialog_start>
     746:	08 95       	ret

00000748 <set_goal_line_semaphore>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void set_goal_line_semaphore(SemaphoreHandle_t goal_line_semaphore) {
	if (goal_line_semaphore) {
     748:	00 97       	sbiw	r24, 0x00	; 0
     74a:	21 f0       	breq	.+8      	; 0x754 <set_goal_line_semaphore+0xc>
		_goal_line_semaphore = goal_line_semaphore;
     74c:	90 93 f1 02 	sts	0x02F1, r25
     750:	80 93 f0 02 	sts	0x02F0, r24
     754:	08 95       	ret

00000756 <__vector_1>:
	}
}

ISR(INT0_vect) {
     756:	1f 92       	push	r1
     758:	0f 92       	push	r0
     75a:	0f b6       	in	r0, 0x3f	; 63
     75c:	0f 92       	push	r0
     75e:	11 24       	eor	r1, r1
     760:	0b b6       	in	r0, 0x3b	; 59
     762:	0f 92       	push	r0
     764:	2f 93       	push	r18
     766:	3f 93       	push	r19
     768:	4f 93       	push	r20
     76a:	5f 93       	push	r21
     76c:	6f 93       	push	r22
     76e:	7f 93       	push	r23
     770:	8f 93       	push	r24
     772:	9f 93       	push	r25
     774:	af 93       	push	r26
     776:	bf 93       	push	r27
     778:	ef 93       	push	r30
     77a:	ff 93       	push	r31
	static signed portBASE_TYPE _higher_priority_task_woken;
	if (_goal_line_semaphore) {
     77c:	80 91 f0 02 	lds	r24, 0x02F0
     780:	90 91 f1 02 	lds	r25, 0x02F1
     784:	00 97       	sbiw	r24, 0x00	; 0
     786:	49 f0       	breq	.+18     	; 0x79a <__vector_1+0x44>
		_higher_priority_task_woken = pdFALSE;
     788:	10 92 c8 02 	sts	0x02C8, r1

		xSemaphoreGiveFromISR(_goal_line_semaphore, &_higher_priority_task_woken);
     78c:	68 ec       	ldi	r22, 0xC8	; 200
     78e:	72 e0       	ldi	r23, 0x02	; 2
     790:	1f d6       	rcall	.+3134   	; 0x13d0 <xQueueGiveFromISR>
		
		if (_higher_priority_task_woken != pdFALSE) {
     792:	80 91 c8 02 	lds	r24, 0x02C8
     796:	81 11       	cpse	r24, r1
			portYIELD();
     798:	cd d3       	rcall	.+1946   	; 0xf34 <vPortYield>
		}
	}
}
     79a:	ff 91       	pop	r31
     79c:	ef 91       	pop	r30
     79e:	bf 91       	pop	r27
     7a0:	af 91       	pop	r26
     7a2:	9f 91       	pop	r25
     7a4:	8f 91       	pop	r24
     7a6:	7f 91       	pop	r23
     7a8:	6f 91       	pop	r22
     7aa:	5f 91       	pop	r21
     7ac:	4f 91       	pop	r20
     7ae:	3f 91       	pop	r19
     7b0:	2f 91       	pop	r18
     7b2:	0f 90       	pop	r0
     7b4:	0b be       	out	0x3b, r0	; 59
     7b6:	0f 90       	pop	r0
     7b8:	0f be       	out	0x3f, r0	; 63
     7ba:	0f 90       	pop	r0
     7bc:	1f 90       	pop	r1
     7be:	18 95       	reti

000007c0 <__vector_13>:
	#elif ((DIALOG_HANDLER_PRESCALER == 1024))
	DIALOG_HANDLER_TCCRB_reg |= _BV(DIALOG_HANDLER_CS0_bit) | _BV(DIALOG_HANDLER_CS2_bit); ;    // Prescaler 1024 and Start Timer
	#endif
}

ISR(TIMER2_COMPA_vect) {
     7c0:	1f 92       	push	r1
     7c2:	0f 92       	push	r0
     7c4:	0f b6       	in	r0, 0x3f	; 63
     7c6:	0f 92       	push	r0
     7c8:	11 24       	eor	r1, r1
     7ca:	0b b6       	in	r0, 0x3b	; 59
     7cc:	0f 92       	push	r0
     7ce:	2f 93       	push	r18
     7d0:	3f 93       	push	r19
     7d2:	4f 93       	push	r20
     7d4:	5f 93       	push	r21
     7d6:	6f 93       	push	r22
     7d8:	7f 93       	push	r23
     7da:	8f 93       	push	r24
     7dc:	9f 93       	push	r25
     7de:	af 93       	push	r26
     7e0:	bf 93       	push	r27
     7e2:	ef 93       	push	r30
     7e4:	ff 93       	push	r31
	static uint8_t _count = 10;
	if (_bt_dialog_active) {
     7e6:	80 91 f6 02 	lds	r24, 0x02F6
     7ea:	88 23       	and	r24, r24
     7ec:	59 f0       	breq	.+22     	; 0x804 <__vector_13+0x44>
		if (--_count == 0) {
     7ee:	80 91 06 02 	lds	r24, 0x0206
     7f2:	81 50       	subi	r24, 0x01	; 1
     7f4:	19 f0       	breq	.+6      	; 0x7fc <__vector_13+0x3c>
     7f6:	80 93 06 02 	sts	0x0206, r24
     7fa:	04 c0       	rjmp	.+8      	; 0x804 <__vector_13+0x44>
			_count = 10;
     7fc:	8a e0       	ldi	r24, 0x0A	; 10
     7fe:	80 93 06 02 	sts	0x0206, r24
			dialog_tick();
     802:	4c d1       	rcall	.+664    	; 0xa9c <dialog_tick>
		}
	}
}
     804:	ff 91       	pop	r31
     806:	ef 91       	pop	r30
     808:	bf 91       	pop	r27
     80a:	af 91       	pop	r26
     80c:	9f 91       	pop	r25
     80e:	8f 91       	pop	r24
     810:	7f 91       	pop	r23
     812:	6f 91       	pop	r22
     814:	5f 91       	pop	r21
     816:	4f 91       	pop	r20
     818:	3f 91       	pop	r19
     81a:	2f 91       	pop	r18
     81c:	0f 90       	pop	r0
     81e:	0b be       	out	0x3b, r0	; 59
     820:	0f 90       	pop	r0
     822:	0f be       	out	0x3f, r0	; 63
     824:	0f 90       	pop	r0
     826:	1f 90       	pop	r1
     828:	18 95       	reti

0000082a <buffer_init>:
 @return true if buffer is empty.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_is_empty(buffer_struct_t *buffer) {
	return (buffer->no_in_buffer == 0);
}
     82a:	fc 01       	movw	r30, r24
     82c:	10 8a       	std	Z+16, r1	; 0x10
     82e:	11 8a       	std	Z+17, r1	; 0x11
     830:	12 8a       	std	Z+18, r1	; 0x12
     832:	08 95       	ret

00000834 <buffer_get_item>:
     834:	fc 01       	movw	r30, r24
     836:	82 89       	ldd	r24, Z+18	; 0x12
     838:	88 23       	and	r24, r24
     83a:	91 f0       	breq	.+36     	; 0x860 <buffer_get_item+0x2c>
     83c:	81 89       	ldd	r24, Z+17	; 0x11
     83e:	df 01       	movw	r26, r30
     840:	a8 0f       	add	r26, r24
     842:	b1 1d       	adc	r27, r1
     844:	8c 91       	ld	r24, X
     846:	db 01       	movw	r26, r22
     848:	8c 93       	st	X, r24
     84a:	81 89       	ldd	r24, Z+17	; 0x11
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	01 96       	adiw	r24, 0x01	; 1
     850:	8f 70       	andi	r24, 0x0F	; 15
     852:	90 78       	andi	r25, 0x80	; 128
     854:	81 8b       	std	Z+17, r24	; 0x11
     856:	82 89       	ldd	r24, Z+18	; 0x12
     858:	81 50       	subi	r24, 0x01	; 1
     85a:	82 8b       	std	Z+18, r24	; 0x12
     85c:	80 e0       	ldi	r24, 0x00	; 0
     85e:	08 95       	ret
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	08 95       	ret

00000864 <buffer_put_item>:
     864:	fc 01       	movw	r30, r24
     866:	42 89       	ldd	r20, Z+18	; 0x12
     868:	40 31       	cpi	r20, 0x10	; 16
     86a:	78 f4       	brcc	.+30     	; 0x88a <buffer_put_item+0x26>
     86c:	20 89       	ldd	r18, Z+16	; 0x10
     86e:	30 e0       	ldi	r19, 0x00	; 0
     870:	e2 0f       	add	r30, r18
     872:	f3 1f       	adc	r31, r19
     874:	60 83       	st	Z, r22
     876:	2f 5f       	subi	r18, 0xFF	; 255
     878:	3f 4f       	sbci	r19, 0xFF	; 255
     87a:	2f 70       	andi	r18, 0x0F	; 15
     87c:	30 78       	andi	r19, 0x80	; 128
     87e:	fc 01       	movw	r30, r24
     880:	20 8b       	std	Z+16, r18	; 0x10
     882:	4f 5f       	subi	r20, 0xFF	; 255
     884:	42 8b       	std	Z+18, r20	; 0x12
     886:	80 e0       	ldi	r24, 0x00	; 0
     888:	08 95       	ret
     88a:	82 e0       	ldi	r24, 0x02	; 2
     88c:	08 95       	ret

0000088e <buffer_no_of_items>:
 @return no of items in the buffer.
 @param *buffer pointer to the buffer structure.
 ***********************************************/
uint8_t buffer_no_of_items(buffer_struct_t *buffer) {
	return buffer->no_in_buffer;
}
     88e:	fc 01       	movw	r30, r24
     890:	82 89       	ldd	r24, Z+18	; 0x12
     892:	08 95       	ret

00000894 <buffer_clear>:
 @ingroup buffer_function
 @brief Clear the content of the buffer.

 @param *buffer pointer to the buffer structure.
 **********************************************************************/
void buffer_clear(buffer_struct_t *buffer) {
     894:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     896:	10 8a       	std	Z+16, r1	; 0x10
	buffer->out_i = 0;
     898:	11 8a       	std	Z+17, r1	; 0x11
	buffer->no_in_buffer = 0;
     89a:	12 8a       	std	Z+18, r1	; 0x12
     89c:	08 95       	ret

0000089e <_dialog_prepare_for_next_byte>:

 When the function returns it has setup the state variable _dialog_await_state that will be used in dialog_char_received(), and the needed argument counters etc.
 */
static void _dialog_prepare_for_next_byte() {
  // esc char?
  if (*(_dialog_format.response_p) == '%') {
     89e:	e0 91 3a 03 	lds	r30, 0x033A
     8a2:	f0 91 3b 03 	lds	r31, 0x033B
     8a6:	80 81       	ld	r24, Z
     8a8:	85 32       	cpi	r24, 0x25	; 37
     8aa:	09 f0       	breq	.+2      	; 0x8ae <_dialog_prepare_for_next_byte+0x10>
     8ac:	85 c0       	rjmp	.+266    	; 0x9b8 <_dialog_prepare_for_next_byte+0x11a>
    _dialog_format.response_p++;
     8ae:	cf 01       	movw	r24, r30
     8b0:	01 96       	adiw	r24, 0x01	; 1
     8b2:	90 93 3b 03 	sts	0x033B, r25
     8b6:	80 93 3a 03 	sts	0x033A, r24

    if (*(_dialog_format.response_p) == '%') {
     8ba:	81 81       	ldd	r24, Z+1	; 0x01
     8bc:	85 32       	cpi	r24, 0x25	; 37
     8be:	19 f4       	brne	.+6      	; 0x8c6 <_dialog_prepare_for_next_byte+0x28>
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
     8c0:	10 92 31 03 	sts	0x0331, r1
     8c4:	08 95       	ret
    } else if (*_dialog_format.response_p == '*') {
     8c6:	8a 32       	cpi	r24, 0x2A	; 42
     8c8:	e1 f5       	brne	.+120    	; 0x942 <_dialog_prepare_for_next_byte+0xa4>
      // Max args: %*nnB
      _dialog_format.response_p++;
     8ca:	cf 01       	movw	r24, r30
     8cc:	02 96       	adiw	r24, 0x02	; 2
     8ce:	90 93 3b 03 	sts	0x033B, r25
     8d2:	80 93 3a 03 	sts	0x033A, r24
     8d6:	33 96       	adiw	r30, 0x03	; 3
     8d8:	20 e0       	ldi	r18, 0x00	; 0
     8da:	dc 01       	movw	r26, r24
     8dc:	01 96       	adiw	r24, 0x01	; 1
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     8de:	22 0f       	add	r18, r18
     8e0:	32 2f       	mov	r19, r18
     8e2:	33 0f       	add	r19, r19
     8e4:	33 0f       	add	r19, r19
     8e6:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     8e8:	20 53       	subi	r18, 0x30	; 48
     8ea:	3c 91       	ld	r19, X
     8ec:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     8ee:	31 91       	ld	r19, Z+
     8f0:	32 34       	cpi	r19, 0x42	; 66
     8f2:	99 f7       	brne	.-26     	; 0x8da <_dialog_prepare_for_next_byte+0x3c>
     8f4:	20 93 3c 03 	sts	0x033C, r18
      _dialog_format.response_p++;
     8f8:	12 96       	adiw	r26, 0x02	; 2
     8fa:	b0 93 3b 03 	sts	0x033B, r27
     8fe:	a0 93 3a 03 	sts	0x033A, r26
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     902:	80 91 3e 03 	lds	r24, 0x033E
     906:	90 91 3f 03 	lds	r25, 0x033F
     90a:	00 97       	sbiw	r24, 0x00	; 0
     90c:	b1 f0       	breq	.+44     	; 0x93a <_dialog_prepare_for_next_byte+0x9c>
        _dialog_format.arg_index++;
     90e:	ed e3       	ldi	r30, 0x3D	; 61
     910:	f3 e0       	ldi	r31, 0x03	; 3
     912:	20 81       	ld	r18, Z
     914:	2f 5f       	subi	r18, 0xFF	; 255
     916:	20 83       	st	Z, r18
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     918:	33 27       	eor	r19, r19
     91a:	27 fd       	sbrc	r18, 7
     91c:	30 95       	com	r19
     91e:	f9 01       	movw	r30, r18
     920:	ee 0f       	add	r30, r30
     922:	ff 1f       	adc	r31, r31
     924:	e2 0f       	add	r30, r18
     926:	f3 1f       	adc	r31, r19
     928:	e8 0f       	add	r30, r24
     92a:	f9 1f       	adc	r31, r25
     92c:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     92e:	80 81       	ld	r24, Z
     930:	91 81       	ldd	r25, Z+1	; 0x01
     932:	90 93 41 03 	sts	0x0341, r25
     936:	80 93 40 03 	sts	0x0340, r24
      }
      _dialog_await_state = ARG_MAX_STATE;
     93a:	82 e0       	ldi	r24, 0x02	; 2
     93c:	80 93 31 03 	sts	0x0331, r24
     940:	08 95       	ret
     942:	80 91 3a 03 	lds	r24, 0x033A
     946:	90 91 3b 03 	lds	r25, 0x033B
     94a:	dc 01       	movw	r26, r24
     94c:	11 96       	adiw	r26, 0x01	; 1
    _dialog_format.response_p++;

    if (*(_dialog_format.response_p) == '%') {
      //Byte stuffing
      _dialog_await_state = NORMAL_STATE;
    } else if (*_dialog_format.response_p == '*') {
     94e:	20 e0       	ldi	r18, 0x00	; 0
     950:	fc 01       	movw	r30, r24
     952:	01 96       	adiw	r24, 0x01	; 1
    } else {
      // args: %nnB
      // Find the arg. cnt
      _dialog_format.arg_cnt = 0;
      do {
        _dialog_format.arg_cnt *= 10;
     954:	22 0f       	add	r18, r18
     956:	32 2f       	mov	r19, r18
     958:	33 0f       	add	r19, r19
     95a:	33 0f       	add	r19, r19
     95c:	23 0f       	add	r18, r19
        _dialog_format.arg_cnt += (*_dialog_format.response_p) - '0';
     95e:	20 53       	subi	r18, 0x30	; 48
     960:	30 81       	ld	r19, Z
     962:	23 0f       	add	r18, r19
      } while (*(++_dialog_format.response_p) != 'B');
     964:	3d 91       	ld	r19, X+
     966:	32 34       	cpi	r19, 0x42	; 66
     968:	99 f7       	brne	.-26     	; 0x950 <_dialog_prepare_for_next_byte+0xb2>
     96a:	20 93 3c 03 	sts	0x033C, r18
      _dialog_format.response_p++;
     96e:	32 96       	adiw	r30, 0x02	; 2
     970:	f0 93 3b 03 	sts	0x033B, r31
     974:	e0 93 3a 03 	sts	0x033A, r30
      // Are argument buffers allocated?
      if (_dialog_format.arg_buffers != 0) {
     978:	80 91 3e 03 	lds	r24, 0x033E
     97c:	90 91 3f 03 	lds	r25, 0x033F
     980:	00 97       	sbiw	r24, 0x00	; 0
     982:	b1 f0       	breq	.+44     	; 0x9b0 <_dialog_prepare_for_next_byte+0x112>
        _dialog_format.arg_index++;
     984:	ad e3       	ldi	r26, 0x3D	; 61
     986:	b3 e0       	ldi	r27, 0x03	; 3
     988:	ec 91       	ld	r30, X
     98a:	ef 5f       	subi	r30, 0xFF	; 255
     98c:	ec 93       	st	X, r30
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len = 0;
     98e:	ff 27       	eor	r31, r31
     990:	e7 fd       	sbrc	r30, 7
     992:	f0 95       	com	r31
     994:	9f 01       	movw	r18, r30
     996:	22 0f       	add	r18, r18
     998:	33 1f       	adc	r19, r19
     99a:	e2 0f       	add	r30, r18
     99c:	f3 1f       	adc	r31, r19
     99e:	e8 0f       	add	r30, r24
     9a0:	f9 1f       	adc	r31, r25
     9a2:	12 82       	std	Z+2, r1	; 0x02
        _dialog_format.arg_buf_p = _dialog_format.arg_buffers[_dialog_format.arg_index].arg_buf;
     9a4:	80 81       	ld	r24, Z
     9a6:	91 81       	ldd	r25, Z+1	; 0x01
     9a8:	90 93 41 03 	sts	0x0341, r25
     9ac:	80 93 40 03 	sts	0x0340, r24
      }
      _dialog_await_state = ARG_STATE;
     9b0:	81 e0       	ldi	r24, 0x01	; 1
     9b2:	80 93 31 03 	sts	0x0331, r24
     9b6:	08 95       	ret
    }
  } else {
    _dialog_await_state = NORMAL_STATE;
     9b8:	10 92 31 03 	sts	0x0331, r1
     9bc:	08 95       	ret

000009be <_dialog_goto_state>:
 IF the new state is either DIALOG_OK_STOP or DIALOG_ERROR_STOP then the call_back function will be called.
 ELSE the new State will be setup.

 @param[in] new_state the new state to goto.
 */
static void _dialog_goto_state(const uint8_t new_state) {
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
  _dialog_second_counter = 0;
     9c2:	10 92 35 03 	sts	0x0335, r1
  _dialog_current_state = new_state;
     9c6:	80 93 34 03 	sts	0x0334, r24
  if (new_state == DIALOG_ERROR_STOP || new_state == DIALOG_OK_STOP) {
     9ca:	92 e0       	ldi	r25, 0x02	; 2
     9cc:	98 0f       	add	r25, r24
     9ce:	92 30       	cpi	r25, 0x02	; 2
     9d0:	30 f4       	brcc	.+12     	; 0x9de <_dialog_goto_state+0x20>
    (*_dialog_pf_call_back)(new_state);
     9d2:	e0 91 2d 03 	lds	r30, 0x032D
     9d6:	f0 91 2e 03 	lds	r31, 0x032E
     9da:	19 95       	eicall
     9dc:	4b c0       	rjmp	.+150    	; 0xa74 <_dialog_goto_state+0xb6>
  } else {
    // Send command if any
    if (_dialog_seq[new_state].command_length != 0) {
     9de:	9b e0       	ldi	r25, 0x0B	; 11
     9e0:	89 9f       	mul	r24, r25
     9e2:	e0 01       	movw	r28, r0
     9e4:	11 24       	eor	r1, r1
     9e6:	a0 91 32 03 	lds	r26, 0x0332
     9ea:	b0 91 33 03 	lds	r27, 0x0333
     9ee:	ac 0f       	add	r26, r28
     9f0:	bd 1f       	adc	r27, r29
     9f2:	12 96       	adiw	r26, 0x02	; 2
     9f4:	6c 91       	ld	r22, X
     9f6:	12 97       	sbiw	r26, 0x02	; 2
     9f8:	66 23       	and	r22, r22
     9fa:	39 f0       	breq	.+14     	; 0xa0a <_dialog_goto_state+0x4c>
      (*_dialog_pf_send)(_dialog_seq[new_state].command,
     9fc:	e0 91 2f 03 	lds	r30, 0x032F
     a00:	f0 91 30 03 	lds	r31, 0x0330
     a04:	8d 91       	ld	r24, X+
     a06:	9c 91       	ld	r25, X
     a08:	19 95       	eicall
      _dialog_seq[new_state].command_length);
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
     a0a:	80 91 32 03 	lds	r24, 0x0332
     a0e:	90 91 33 03 	lds	r25, 0x0333
     a12:	c8 0f       	add	r28, r24
     a14:	d9 1f       	adc	r29, r25
     a16:	2d 81       	ldd	r18, Y+5	; 0x05
     a18:	22 23       	and	r18, r18
     a1a:	51 f1       	breq	.+84     	; 0xa70 <_dialog_goto_state+0xb2>
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
                  _dialog_seq[new_state].responce_format;
     a1c:	8b 81       	ldd	r24, Y+3	; 0x03
     a1e:	9c 81       	ldd	r25, Y+4	; 0x04
 @param[in] response_format to be waited for..
 @param[in] len
 @param[out] *buf
 */
static void _dialog_await(uint8_t new_state) {
  _dialog_format.response_p = _dialog_format.response =
     a20:	90 93 37 03 	sts	0x0337, r25
     a24:	80 93 36 03 	sts	0x0336, r24
     a28:	90 93 3b 03 	sts	0x033B, r25
     a2c:	80 93 3a 03 	sts	0x033A, r24
                  _dialog_seq[new_state].responce_format;
  _dialog_format.arg_buffers = _dialog_seq[new_state].arg_buffers;
     a30:	e9 85       	ldd	r30, Y+9	; 0x09
     a32:	fa 85       	ldd	r31, Y+10	; 0x0a
     a34:	f0 93 3f 03 	sts	0x033F, r31
     a38:	e0 93 3e 03 	sts	0x033E, r30
  _dialog_format.arg_index = -1;
     a3c:	3f ef       	ldi	r19, 0xFF	; 255
     a3e:	30 93 3d 03 	sts	0x033D, r19
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
     a42:	30 97       	sbiw	r30, 0x00	; 0
     a44:	31 f0       	breq	.+12     	; 0xa52 <_dialog_goto_state+0x94>
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
     a46:	40 81       	ld	r20, Z
     a48:	51 81       	ldd	r21, Z+1	; 0x01
     a4a:	50 93 41 03 	sts	0x0341, r21
     a4e:	40 93 40 03 	sts	0x0340, r20
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
                  + _dialog_seq[new_state].responce_format_length - 1;
     a52:	30 e0       	ldi	r19, 0x00	; 0
     a54:	21 50       	subi	r18, 0x01	; 1
     a56:	31 09       	sbc	r19, r1
     a58:	82 0f       	add	r24, r18
     a5a:	93 1f       	adc	r25, r19
  _dialog_format.arg_index = -1;
  // Are any arg_buffers specified?
  if (_dialog_format.arg_buffers) {
    _dialog_format.arg_buf_p = _dialog_seq[new_state].arg_buffers[0].arg_buf;
  }
  _dialog_format.last = _dialog_seq[new_state].responce_format
     a5c:	90 93 39 03 	sts	0x0339, r25
     a60:	80 93 38 03 	sts	0x0338, r24
                  + _dialog_seq[new_state].responce_format_length - 1;
  _dialog_prepare_for_next_byte();
     a64:	1c df       	rcall	.-456    	; 0x89e <_dialog_prepare_for_next_byte>
    }

    // Any response to wait for?
    if (_dialog_seq[new_state].responce_format_length > 0) {
      _dialog_await(new_state);
      _dialog_second_counter = _dialog_seq[new_state].max_response_time
     a66:	8e 81       	ldd	r24, Y+6	; 0x06
     a68:	8f 5f       	subi	r24, 0xFF	; 255
     a6a:	80 93 35 03 	sts	0x0335, r24
     a6e:	02 c0       	rjmp	.+4      	; 0xa74 <_dialog_goto_state+0xb6>
                      + 1; // add one because of 1 sec jitter in second timer
    } else {
      _dialog_goto_state(_dialog_seq[new_state].ok_state);
     a70:	8f 81       	ldd	r24, Y+7	; 0x07
     a72:	a5 df       	rcall	.-182    	; 0x9be <_dialog_goto_state>
    }
  }
}
     a74:	df 91       	pop	r29
     a76:	cf 91       	pop	r28
     a78:	08 95       	ret

00000a7a <dialog_start>:
 @endcode
 */
void dialog_start(dialog_seq_t *p_seq,
		void (*pf_send)(uint8_t *command, uint8_t command_length),
		void (*pf_call_back)(uint8_t result)) {
  _dialog_seq = p_seq;
     a7a:	90 93 33 03 	sts	0x0333, r25
     a7e:	80 93 32 03 	sts	0x0332, r24
  _dialog_pf_send = pf_send;
     a82:	70 93 30 03 	sts	0x0330, r23
     a86:	60 93 2f 03 	sts	0x032F, r22
  _dialog_pf_call_back = pf_call_back;
     a8a:	50 93 2e 03 	sts	0x032E, r21
     a8e:	40 93 2d 03 	sts	0x032D, r20
  _dialog_current_state = 0;
     a92:	10 92 34 03 	sts	0x0334, r1
  _dialog_goto_state(0);
     a96:	80 e0       	ldi	r24, 0x00	; 0
     a98:	92 cf       	rjmp	.-220    	; 0x9be <_dialog_goto_state>
     a9a:	08 95       	ret

00000a9c <dialog_tick>:
 @brief Housekeeping function that must be called every second when a dialog is active.

 If the maximum wait time is exceeded the the dialog will change to error state.
 */
void dialog_tick() {
  if (_dialog_second_counter) {
     a9c:	80 91 35 03 	lds	r24, 0x0335
     aa0:	88 23       	and	r24, r24
     aa2:	91 f0       	breq	.+36     	; 0xac8 <dialog_tick+0x2c>
    if (--_dialog_second_counter == 0) {
     aa4:	81 50       	subi	r24, 0x01	; 1
     aa6:	80 93 35 03 	sts	0x0335, r24
     aaa:	81 11       	cpse	r24, r1
     aac:	0d c0       	rjmp	.+26     	; 0xac8 <dialog_tick+0x2c>
      _dialog_goto_state(_dialog_seq[_dialog_current_state].error_state);
     aae:	80 91 34 03 	lds	r24, 0x0334
     ab2:	e0 91 32 03 	lds	r30, 0x0332
     ab6:	f0 91 33 03 	lds	r31, 0x0333
     aba:	9b e0       	ldi	r25, 0x0B	; 11
     abc:	89 9f       	mul	r24, r25
     abe:	e0 0d       	add	r30, r0
     ac0:	f1 1d       	adc	r31, r1
     ac2:	11 24       	eor	r1, r1
     ac4:	80 85       	ldd	r24, Z+8	; 0x08
     ac6:	7b cf       	rjmp	.-266    	; 0x9be <_dialog_goto_state>
     ac8:	08 95       	ret

00000aca <dialog_byte_received>:
If there are specified a pointer to an argument buffer in the current state of the dialog_seq, the received argument bytes will be stored in this buffer, else the argument values will be thrown away.

 When/If the expected response string is received the dialog state is changed to the current dialog states OK state.
 @param[in] byte received from device we are communication with.
 */
void dialog_byte_received(const uint8_t byte) {
     aca:	6f 92       	push	r6
     acc:	7f 92       	push	r7
     ace:	8f 92       	push	r8
     ad0:	9f 92       	push	r9
     ad2:	af 92       	push	r10
     ad4:	bf 92       	push	r11
     ad6:	cf 92       	push	r12
     ad8:	df 92       	push	r13
     ada:	ef 92       	push	r14
     adc:	ff 92       	push	r15
     ade:	0f 93       	push	r16
     ae0:	1f 93       	push	r17
     ae2:	cf 93       	push	r28
     ae4:	df 93       	push	r29
     ae6:	98 2e       	mov	r9, r24
  uint8_t _retry;
  
  switch (_dialog_await_state) {
     ae8:	80 91 31 03 	lds	r24, 0x0331
     aec:	81 30       	cpi	r24, 0x01	; 1
     aee:	09 f4       	brne	.+2      	; 0xaf2 <dialog_byte_received+0x28>
     af0:	42 c0       	rjmp	.+132    	; 0xb76 <dialog_byte_received+0xac>
     af2:	20 f0       	brcs	.+8      	; 0xafc <dialog_byte_received+0x32>
     af4:	82 30       	cpi	r24, 0x02	; 2
     af6:	09 f4       	brne	.+2      	; 0xafa <dialog_byte_received+0x30>
     af8:	70 c0       	rjmp	.+224    	; 0xbda <dialog_byte_received+0x110>
     afa:	af c0       	rjmp	.+350    	; 0xc5a <dialog_byte_received+0x190>
     afc:	81 2c       	mov	r8, r1
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     afe:	ca e3       	ldi	r28, 0x3A	; 58
     b00:	d3 e0       	ldi	r29, 0x03	; 3
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     b02:	0f 2e       	mov	r0, r31
     b04:	f6 e3       	ldi	r31, 0x36	; 54
     b06:	cf 2e       	mov	r12, r31
     b08:	f3 e0       	ldi	r31, 0x03	; 3
     b0a:	df 2e       	mov	r13, r31
     b0c:	f0 2d       	mov	r31, r0

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     b0e:	0f 2e       	mov	r0, r31
     b10:	fd e3       	ldi	r31, 0x3D	; 61
     b12:	ef 2e       	mov	r14, r31
     b14:	f3 e0       	ldi	r31, 0x03	; 3
     b16:	ff 2e       	mov	r15, r31
     b18:	f0 2d       	mov	r31, r0
        if (_dialog_format.arg_buffers != 0) {
     b1a:	0e e3       	ldi	r16, 0x3E	; 62
     b1c:	13 e0       	ldi	r17, 0x03	; 3
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
        }

        if (!_retry) {
     b1e:	77 24       	eor	r7, r7
     b20:	73 94       	inc	r7
     b22:	61 2c       	mov	r6, r1
        _dialog_format.response_p = _dialog_format.response;

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
        if (_dialog_format.arg_buffers != 0) {
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     b24:	0f 2e       	mov	r0, r31
     b26:	f0 e4       	ldi	r31, 0x40	; 64
     b28:	af 2e       	mov	r10, r31
     b2a:	f3 e0       	ldi	r31, 0x03	; 3
     b2c:	bf 2e       	mov	r11, r31
     b2e:	f0 2d       	mov	r31, r0
  
  switch (_dialog_await_state) {
  case NORMAL_STATE:
    _retry = 0;
    do {
      if (*_dialog_format.response_p++ != byte) {
     b30:	e8 81       	ld	r30, Y
     b32:	f9 81       	ldd	r31, Y+1	; 0x01
     b34:	9f 01       	movw	r18, r30
     b36:	2f 5f       	subi	r18, 0xFF	; 255
     b38:	3f 4f       	sbci	r19, 0xFF	; 255
     b3a:	39 83       	std	Y+1, r19	; 0x01
     b3c:	28 83       	st	Y, r18
     b3e:	80 81       	ld	r24, Z
     b40:	89 15       	cp	r24, r9
     b42:	a9 f0       	breq	.+42     	; 0xb6e <dialog_byte_received+0xa4>
        // Problem: not the expected byte
        // Lets try from the beginning of the format
        _dialog_format.response_p = _dialog_format.response;
     b44:	d6 01       	movw	r26, r12
     b46:	8d 91       	ld	r24, X+
     b48:	9c 91       	ld	r25, X
     b4a:	99 83       	std	Y+1, r25	; 0x01
     b4c:	88 83       	st	Y, r24

        // Reset all things about argument capturing
        _dialog_format.arg_index=0;
     b4e:	f7 01       	movw	r30, r14
     b50:	10 82       	st	Z, r1
        if (_dialog_format.arg_buffers != 0) {
     b52:	d8 01       	movw	r26, r16
     b54:	ed 91       	ld	r30, X+
     b56:	fc 91       	ld	r31, X
     b58:	30 97       	sbiw	r30, 0x00	; 0
     b5a:	29 f0       	breq	.+10     	; 0xb66 <dialog_byte_received+0x9c>
          _dialog_format.arg_buf_p = _dialog_format.arg_buffers[0].arg_buf;
     b5c:	80 81       	ld	r24, Z
     b5e:	91 81       	ldd	r25, Z+1	; 0x01
     b60:	f5 01       	movw	r30, r10
     b62:	91 83       	std	Z+1, r25	; 0x01
     b64:	80 83       	st	Z, r24
        }

        if (!_retry) {
     b66:	87 2d       	mov	r24, r7
     b68:	81 10       	cpse	r8, r1
     b6a:	86 2d       	mov	r24, r6
          _retry = 1;
     b6c:	88 2e       	mov	r8, r24
        } else {
          _retry = 0;
        }
      }
      _dialog_prepare_for_next_byte();
     b6e:	97 de       	rcall	.-722    	; 0x89e <_dialog_prepare_for_next_byte>
    } while (_retry);
     b70:	81 10       	cpse	r8, r1
     b72:	de cf       	rjmp	.-68     	; 0xb30 <dialog_byte_received+0x66>
     b74:	72 c0       	rjmp	.+228    	; 0xc5a <dialog_byte_received+0x190>
    break;

  case ARG_STATE:
    // Test if buffer is specified
    if (_dialog_format.arg_buffers != 0) {
     b76:	20 91 3e 03 	lds	r18, 0x033E
     b7a:	30 91 3f 03 	lds	r19, 0x033F
     b7e:	21 15       	cp	r18, r1
     b80:	31 05       	cpc	r19, r1
     b82:	11 f1       	breq	.+68     	; 0xbc8 <dialog_byte_received+0xfe>
      *_dialog_format.arg_buf_p++ = byte;
     b84:	a0 e4       	ldi	r26, 0x40	; 64
     b86:	b3 e0       	ldi	r27, 0x03	; 3
     b88:	ed 91       	ld	r30, X+
     b8a:	fc 91       	ld	r31, X
     b8c:	11 97       	sbiw	r26, 0x01	; 1
     b8e:	cf 01       	movw	r24, r30
     b90:	01 96       	adiw	r24, 0x01	; 1
     b92:	8d 93       	st	X+, r24
     b94:	9c 93       	st	X, r25
     b96:	90 82       	st	Z, r9
      // Update length of received argument in arg_buffers
      _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     b98:	e0 91 3d 03 	lds	r30, 0x033D
     b9c:	ff 27       	eor	r31, r31
     b9e:	e7 fd       	sbrc	r30, 7
     ba0:	f0 95       	com	r31
     ba2:	cf 01       	movw	r24, r30
     ba4:	88 0f       	add	r24, r24
     ba6:	99 1f       	adc	r25, r25
     ba8:	e8 0f       	add	r30, r24
     baa:	f9 1f       	adc	r31, r25
     bac:	e2 0f       	add	r30, r18
     bae:	f3 1f       	adc	r31, r19
     bb0:	82 81       	ldd	r24, Z+2	; 0x02
     bb2:	8f 5f       	subi	r24, 0xFF	; 255
     bb4:	82 83       	std	Z+2, r24	; 0x02

      // have we got all the bytes in the this argument
      if (--(_dialog_format.arg_cnt) == 0) {
     bb6:	ec e3       	ldi	r30, 0x3C	; 60
     bb8:	f3 e0       	ldi	r31, 0x03	; 3
     bba:	80 81       	ld	r24, Z
     bbc:	81 50       	subi	r24, 0x01	; 1
     bbe:	80 83       	st	Z, r24
     bc0:	81 11       	cpse	r24, r1
     bc2:	4b c0       	rjmp	.+150    	; 0xc5a <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     bc4:	6c de       	rcall	.-808    	; 0x89e <_dialog_prepare_for_next_byte>
     bc6:	49 c0       	rjmp	.+146    	; 0xc5a <dialog_byte_received+0x190>
      }
    } else if (--(_dialog_format.arg_cnt) == 0) {
     bc8:	ec e3       	ldi	r30, 0x3C	; 60
     bca:	f3 e0       	ldi	r31, 0x03	; 3
     bcc:	80 81       	ld	r24, Z
     bce:	81 50       	subi	r24, 0x01	; 1
     bd0:	80 83       	st	Z, r24
     bd2:	81 11       	cpse	r24, r1
     bd4:	42 c0       	rjmp	.+132    	; 0xc5a <dialog_byte_received+0x190>
        _dialog_prepare_for_next_byte();
     bd6:	63 de       	rcall	.-826    	; 0x89e <_dialog_prepare_for_next_byte>
     bd8:	40 c0       	rjmp	.+128    	; 0xc5a <dialog_byte_received+0x190>
    }
    break;

  case ARG_MAX_STATE:
    // Test if we still are receiving argument bytes
    if (byte != *_dialog_format.response_p) {
     bda:	e0 91 3a 03 	lds	r30, 0x033A
     bde:	f0 91 3b 03 	lds	r31, 0x033B
     be2:	80 81       	ld	r24, Z
     be4:	89 15       	cp	r24, r9
     be6:	51 f1       	breq	.+84     	; 0xc3c <dialog_byte_received+0x172>
      // Test if buffer is specified
      if (_dialog_format.arg_buffers != 0) {
     be8:	80 91 3e 03 	lds	r24, 0x033E
     bec:	90 91 3f 03 	lds	r25, 0x033F
     bf0:	00 97       	sbiw	r24, 0x00	; 0
     bf2:	09 f4       	brne	.+2      	; 0xbf6 <dialog_byte_received+0x12c>
     bf4:	4e c0       	rjmp	.+156    	; 0xc92 <dialog_byte_received+0x1c8>
        *_dialog_format.arg_buf_p++ = byte;
     bf6:	a0 e4       	ldi	r26, 0x40	; 64
     bf8:	b3 e0       	ldi	r27, 0x03	; 3
     bfa:	ed 91       	ld	r30, X+
     bfc:	fc 91       	ld	r31, X
     bfe:	11 97       	sbiw	r26, 0x01	; 1
     c00:	9f 01       	movw	r18, r30
     c02:	2f 5f       	subi	r18, 0xFF	; 255
     c04:	3f 4f       	sbci	r19, 0xFF	; 255
     c06:	2d 93       	st	X+, r18
     c08:	3c 93       	st	X, r19
     c0a:	90 82       	st	Z, r9
        // Update length of received argument in arg_buffers
        _dialog_format.arg_buffers[_dialog_format.arg_index].arg_len++;
     c0c:	20 91 3d 03 	lds	r18, 0x033D
     c10:	33 27       	eor	r19, r19
     c12:	27 fd       	sbrc	r18, 7
     c14:	30 95       	com	r19
     c16:	f9 01       	movw	r30, r18
     c18:	ee 0f       	add	r30, r30
     c1a:	ff 1f       	adc	r31, r31
     c1c:	e2 0f       	add	r30, r18
     c1e:	f3 1f       	adc	r31, r19
     c20:	e8 0f       	add	r30, r24
     c22:	f9 1f       	adc	r31, r25
     c24:	82 81       	ldd	r24, Z+2	; 0x02
     c26:	8f 5f       	subi	r24, 0xFF	; 255
     c28:	82 83       	std	Z+2, r24	; 0x02

        // Have we received the maximum number of bytes in argument?
        if (--(_dialog_format.arg_cnt) == 0) {
     c2a:	ec e3       	ldi	r30, 0x3C	; 60
     c2c:	f3 e0       	ldi	r31, 0x03	; 3
     c2e:	80 81       	ld	r24, Z
     c30:	81 50       	subi	r24, 0x01	; 1
     c32:	80 83       	st	Z, r24
     c34:	81 11       	cpse	r24, r1
     c36:	11 c0       	rjmp	.+34     	; 0xc5a <dialog_byte_received+0x190>
          _dialog_prepare_for_next_byte();
     c38:	32 de       	rcall	.-924    	; 0x89e <_dialog_prepare_for_next_byte>
     c3a:	0f c0       	rjmp	.+30     	; 0xc5a <dialog_byte_received+0x190>
        }
      }
    } else if (--(_dialog_format.arg_cnt) == 0) { // or have we received the maximum allowed no of bytes in the argument?
     c3c:	ac e3       	ldi	r26, 0x3C	; 60
     c3e:	b3 e0       	ldi	r27, 0x03	; 3
     c40:	8c 91       	ld	r24, X
     c42:	81 50       	subi	r24, 0x01	; 1
     c44:	8c 93       	st	X, r24
     c46:	81 11       	cpse	r24, r1
     c48:	02 c0       	rjmp	.+4      	; 0xc4e <dialog_byte_received+0x184>
      _dialog_prepare_for_next_byte();
     c4a:	29 de       	rcall	.-942    	; 0x89e <_dialog_prepare_for_next_byte>
     c4c:	06 c0       	rjmp	.+12     	; 0xc5a <dialog_byte_received+0x190>
    } else {
      // Next byte in normal response is received
      _dialog_format.response_p++;
     c4e:	31 96       	adiw	r30, 0x01	; 1
     c50:	f0 93 3b 03 	sts	0x033B, r31
     c54:	e0 93 3a 03 	sts	0x033A, r30
      _dialog_prepare_for_next_byte();
     c58:	22 de       	rcall	.-956    	; 0x89e <_dialog_prepare_for_next_byte>
  default:
    break;
  }

  // Test if we are done - have received all bytes in this state of the dialog_seq
  if ((_dialog_await_state == NORMAL_STATE) && (_dialog_format.response_p > _dialog_format.last)) {
     c5a:	80 91 31 03 	lds	r24, 0x0331
     c5e:	81 11       	cpse	r24, r1
     c60:	18 c0       	rjmp	.+48     	; 0xc92 <dialog_byte_received+0x1c8>
     c62:	20 91 3a 03 	lds	r18, 0x033A
     c66:	30 91 3b 03 	lds	r19, 0x033B
     c6a:	80 91 38 03 	lds	r24, 0x0338
     c6e:	90 91 39 03 	lds	r25, 0x0339
     c72:	82 17       	cp	r24, r18
     c74:	93 07       	cpc	r25, r19
     c76:	68 f4       	brcc	.+26     	; 0xc92 <dialog_byte_received+0x1c8>
    // OK - goto OK state
    _dialog_goto_state(_dialog_seq[_dialog_current_state].ok_state);
     c78:	80 91 34 03 	lds	r24, 0x0334
     c7c:	e0 91 32 03 	lds	r30, 0x0332
     c80:	f0 91 33 03 	lds	r31, 0x0333
     c84:	9b e0       	ldi	r25, 0x0B	; 11
     c86:	89 9f       	mul	r24, r25
     c88:	e0 0d       	add	r30, r0
     c8a:	f1 1d       	adc	r31, r1
     c8c:	11 24       	eor	r1, r1
     c8e:	87 81       	ldd	r24, Z+7	; 0x07
     c90:	96 de       	rcall	.-724    	; 0x9be <_dialog_goto_state>
  }
}
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	ff 90       	pop	r15
     c9c:	ef 90       	pop	r14
     c9e:	df 90       	pop	r13
     ca0:	cf 90       	pop	r12
     ca2:	bf 90       	pop	r11
     ca4:	af 90       	pop	r10
     ca6:	9f 90       	pop	r9
     ca8:	8f 90       	pop	r8
     caa:	7f 90       	pop	r7
     cac:	6f 90       	pop	r6
     cae:	08 95       	ret

00000cb0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     cb0:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     cb2:	03 96       	adiw	r24, 0x03	; 3
     cb4:	92 83       	std	Z+2, r25	; 0x02
     cb6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     cb8:	2f ef       	ldi	r18, 0xFF	; 255
     cba:	3f ef       	ldi	r19, 0xFF	; 255
     cbc:	34 83       	std	Z+4, r19	; 0x04
     cbe:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     cc0:	96 83       	std	Z+6, r25	; 0x06
     cc2:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     cc4:	90 87       	std	Z+8, r25	; 0x08
     cc6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     cc8:	10 82       	st	Z, r1
     cca:	08 95       	ret

00000ccc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     ccc:	fc 01       	movw	r30, r24
     cce:	11 86       	std	Z+9, r1	; 0x09
     cd0:	10 86       	std	Z+8, r1	; 0x08
     cd2:	08 95       	ret

00000cd4 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     cd4:	cf 93       	push	r28
     cd6:	df 93       	push	r29
     cd8:	9c 01       	movw	r18, r24
     cda:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     cdc:	dc 01       	movw	r26, r24
     cde:	11 96       	adiw	r26, 0x01	; 1
     ce0:	cd 91       	ld	r28, X+
     ce2:	dc 91       	ld	r29, X
     ce4:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     ce6:	d3 83       	std	Z+3, r29	; 0x03
     ce8:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     cea:	8c 81       	ldd	r24, Y+4	; 0x04
     cec:	9d 81       	ldd	r25, Y+5	; 0x05
     cee:	95 83       	std	Z+5, r25	; 0x05
     cf0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     cf2:	8c 81       	ldd	r24, Y+4	; 0x04
     cf4:	9d 81       	ldd	r25, Y+5	; 0x05
     cf6:	dc 01       	movw	r26, r24
     cf8:	13 96       	adiw	r26, 0x03	; 3
     cfa:	7c 93       	st	X, r23
     cfc:	6e 93       	st	-X, r22
     cfe:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     d00:	7d 83       	std	Y+5, r23	; 0x05
     d02:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d04:	31 87       	std	Z+9, r19	; 0x09
     d06:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     d08:	f9 01       	movw	r30, r18
     d0a:	80 81       	ld	r24, Z
     d0c:	8f 5f       	subi	r24, 0xFF	; 255
     d0e:	80 83       	st	Z, r24
}
     d10:	df 91       	pop	r29
     d12:	cf 91       	pop	r28
     d14:	08 95       	ret

00000d16 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     d16:	cf 93       	push	r28
     d18:	df 93       	push	r29
     d1a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     d1c:	48 81       	ld	r20, Y
     d1e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d20:	4f 3f       	cpi	r20, 0xFF	; 255
     d22:	2f ef       	ldi	r18, 0xFF	; 255
     d24:	52 07       	cpc	r21, r18
     d26:	21 f4       	brne	.+8      	; 0xd30 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d28:	fc 01       	movw	r30, r24
     d2a:	a7 81       	ldd	r26, Z+7	; 0x07
     d2c:	b0 85       	ldd	r27, Z+8	; 0x08
     d2e:	0d c0       	rjmp	.+26     	; 0xd4a <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d30:	dc 01       	movw	r26, r24
     d32:	13 96       	adiw	r26, 0x03	; 3
     d34:	12 96       	adiw	r26, 0x02	; 2
     d36:	ed 91       	ld	r30, X+
     d38:	fc 91       	ld	r31, X
     d3a:	13 97       	sbiw	r26, 0x03	; 3
     d3c:	20 81       	ld	r18, Z
     d3e:	31 81       	ldd	r19, Z+1	; 0x01
     d40:	42 17       	cp	r20, r18
     d42:	53 07       	cpc	r21, r19
     d44:	10 f0       	brcs	.+4      	; 0xd4a <vListInsert+0x34>
     d46:	df 01       	movw	r26, r30
     d48:	f5 cf       	rjmp	.-22     	; 0xd34 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     d4a:	12 96       	adiw	r26, 0x02	; 2
     d4c:	ed 91       	ld	r30, X+
     d4e:	fc 91       	ld	r31, X
     d50:	13 97       	sbiw	r26, 0x03	; 3
     d52:	fb 83       	std	Y+3, r31	; 0x03
     d54:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     d56:	d5 83       	std	Z+5, r29	; 0x05
     d58:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     d5a:	bd 83       	std	Y+5, r27	; 0x05
     d5c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     d5e:	13 96       	adiw	r26, 0x03	; 3
     d60:	dc 93       	st	X, r29
     d62:	ce 93       	st	-X, r28
     d64:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d66:	99 87       	std	Y+9, r25	; 0x09
     d68:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     d6a:	fc 01       	movw	r30, r24
     d6c:	20 81       	ld	r18, Z
     d6e:	2f 5f       	subi	r18, 0xFF	; 255
     d70:	20 83       	st	Z, r18
}
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     d7e:	a0 85       	ldd	r26, Z+8	; 0x08
     d80:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     d82:	c2 81       	ldd	r28, Z+2	; 0x02
     d84:	d3 81       	ldd	r29, Z+3	; 0x03
     d86:	84 81       	ldd	r24, Z+4	; 0x04
     d88:	95 81       	ldd	r25, Z+5	; 0x05
     d8a:	9d 83       	std	Y+5, r25	; 0x05
     d8c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     d8e:	c4 81       	ldd	r28, Z+4	; 0x04
     d90:	d5 81       	ldd	r29, Z+5	; 0x05
     d92:	82 81       	ldd	r24, Z+2	; 0x02
     d94:	93 81       	ldd	r25, Z+3	; 0x03
     d96:	9b 83       	std	Y+3, r25	; 0x03
     d98:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     d9a:	11 96       	adiw	r26, 0x01	; 1
     d9c:	cd 91       	ld	r28, X+
     d9e:	dc 91       	ld	r29, X
     da0:	12 97       	sbiw	r26, 0x02	; 2
     da2:	ce 17       	cp	r28, r30
     da4:	df 07       	cpc	r29, r31
     da6:	31 f4       	brne	.+12     	; 0xdb4 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     da8:	8c 81       	ldd	r24, Y+4	; 0x04
     daa:	9d 81       	ldd	r25, Y+5	; 0x05
     dac:	12 96       	adiw	r26, 0x02	; 2
     dae:	9c 93       	st	X, r25
     db0:	8e 93       	st	-X, r24
     db2:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     db4:	11 86       	std	Z+9, r1	; 0x09
     db6:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     db8:	8c 91       	ld	r24, X
     dba:	81 50       	subi	r24, 0x01	; 1
     dbc:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     dbe:	df 91       	pop	r29
     dc0:	cf 91       	pop	r28
     dc2:	08 95       	ret

00000dc4 <pxPortInitialiseStack>:
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */

#if defined( portUSE_TIMER0 )
   /* Setup clock source and compare match behaviour. Assuming 328p*/
	portTIMSK &= ~( _BV(OCIE0B)|_BV(OCIE0A)|_BV(TOIE0) );	// disable all Timer0 interrupts
     dc4:	31 e1       	ldi	r19, 0x11	; 17
     dc6:	fc 01       	movw	r30, r24
     dc8:	30 83       	st	Z, r19
     dca:	31 97       	sbiw	r30, 0x01	; 1
     dcc:	22 e2       	ldi	r18, 0x22	; 34
     dce:	20 83       	st	Z, r18
     dd0:	31 97       	sbiw	r30, 0x01	; 1
     dd2:	a3 e3       	ldi	r26, 0x33	; 51
     dd4:	a0 83       	st	Z, r26
     dd6:	31 97       	sbiw	r30, 0x01	; 1
     dd8:	60 83       	st	Z, r22
     dda:	31 97       	sbiw	r30, 0x01	; 1
     ddc:	70 83       	st	Z, r23
     dde:	31 97       	sbiw	r30, 0x01	; 1
     de0:	10 82       	st	Z, r1
     de2:	31 97       	sbiw	r30, 0x01	; 1
     de4:	10 82       	st	Z, r1
     de6:	31 97       	sbiw	r30, 0x01	; 1
     de8:	60 e8       	ldi	r22, 0x80	; 128
     dea:	60 83       	st	Z, r22
     dec:	31 97       	sbiw	r30, 0x01	; 1
     dee:	10 82       	st	Z, r1
     df0:	31 97       	sbiw	r30, 0x01	; 1
     df2:	10 82       	st	Z, r1
     df4:	31 97       	sbiw	r30, 0x01	; 1
     df6:	10 82       	st	Z, r1
     df8:	31 97       	sbiw	r30, 0x01	; 1
     dfa:	62 e0       	ldi	r22, 0x02	; 2
     dfc:	60 83       	st	Z, r22
     dfe:	31 97       	sbiw	r30, 0x01	; 1
     e00:	63 e0       	ldi	r22, 0x03	; 3
     e02:	60 83       	st	Z, r22
     e04:	31 97       	sbiw	r30, 0x01	; 1
     e06:	64 e0       	ldi	r22, 0x04	; 4
     e08:	60 83       	st	Z, r22
     e0a:	31 97       	sbiw	r30, 0x01	; 1
     e0c:	65 e0       	ldi	r22, 0x05	; 5
     e0e:	60 83       	st	Z, r22
     e10:	31 97       	sbiw	r30, 0x01	; 1
     e12:	66 e0       	ldi	r22, 0x06	; 6
     e14:	60 83       	st	Z, r22
     e16:	31 97       	sbiw	r30, 0x01	; 1
     e18:	67 e0       	ldi	r22, 0x07	; 7
     e1a:	60 83       	st	Z, r22
     e1c:	31 97       	sbiw	r30, 0x01	; 1
     e1e:	68 e0       	ldi	r22, 0x08	; 8
     e20:	60 83       	st	Z, r22
     e22:	31 97       	sbiw	r30, 0x01	; 1
     e24:	69 e0       	ldi	r22, 0x09	; 9
     e26:	60 83       	st	Z, r22
     e28:	31 97       	sbiw	r30, 0x01	; 1
     e2a:	60 e1       	ldi	r22, 0x10	; 16
     e2c:	60 83       	st	Z, r22
     e2e:	31 97       	sbiw	r30, 0x01	; 1
     e30:	30 83       	st	Z, r19
     e32:	31 97       	sbiw	r30, 0x01	; 1
     e34:	32 e1       	ldi	r19, 0x12	; 18
     e36:	30 83       	st	Z, r19
     e38:	31 97       	sbiw	r30, 0x01	; 1
     e3a:	33 e1       	ldi	r19, 0x13	; 19
     e3c:	30 83       	st	Z, r19
     e3e:	31 97       	sbiw	r30, 0x01	; 1
     e40:	34 e1       	ldi	r19, 0x14	; 20
     e42:	30 83       	st	Z, r19
     e44:	31 97       	sbiw	r30, 0x01	; 1
     e46:	35 e1       	ldi	r19, 0x15	; 21
     e48:	30 83       	st	Z, r19
     e4a:	31 97       	sbiw	r30, 0x01	; 1
     e4c:	36 e1       	ldi	r19, 0x16	; 22
     e4e:	30 83       	st	Z, r19
     e50:	31 97       	sbiw	r30, 0x01	; 1
     e52:	37 e1       	ldi	r19, 0x17	; 23
     e54:	30 83       	st	Z, r19
     e56:	31 97       	sbiw	r30, 0x01	; 1
     e58:	38 e1       	ldi	r19, 0x18	; 24
     e5a:	30 83       	st	Z, r19
     e5c:	31 97       	sbiw	r30, 0x01	; 1
     e5e:	39 e1       	ldi	r19, 0x19	; 25
     e60:	30 83       	st	Z, r19
     e62:	31 97       	sbiw	r30, 0x01	; 1
     e64:	30 e2       	ldi	r19, 0x20	; 32
     e66:	30 83       	st	Z, r19
     e68:	31 97       	sbiw	r30, 0x01	; 1
     e6a:	31 e2       	ldi	r19, 0x21	; 33
     e6c:	30 83       	st	Z, r19
     e6e:	31 97       	sbiw	r30, 0x01	; 1
     e70:	20 83       	st	Z, r18
     e72:	31 97       	sbiw	r30, 0x01	; 1
     e74:	23 e2       	ldi	r18, 0x23	; 35
     e76:	20 83       	st	Z, r18
     e78:	31 97       	sbiw	r30, 0x01	; 1
     e7a:	40 83       	st	Z, r20
     e7c:	31 97       	sbiw	r30, 0x01	; 1
     e7e:	50 83       	st	Z, r21
     e80:	31 97       	sbiw	r30, 0x01	; 1
     e82:	26 e2       	ldi	r18, 0x26	; 38
     e84:	20 83       	st	Z, r18
     e86:	31 97       	sbiw	r30, 0x01	; 1
     e88:	27 e2       	ldi	r18, 0x27	; 39
     e8a:	20 83       	st	Z, r18
     e8c:	31 97       	sbiw	r30, 0x01	; 1
     e8e:	28 e2       	ldi	r18, 0x28	; 40
     e90:	20 83       	st	Z, r18
     e92:	31 97       	sbiw	r30, 0x01	; 1
     e94:	29 e2       	ldi	r18, 0x29	; 41
     e96:	20 83       	st	Z, r18
     e98:	31 97       	sbiw	r30, 0x01	; 1
     e9a:	20 e3       	ldi	r18, 0x30	; 48
     e9c:	20 83       	st	Z, r18
     e9e:	31 97       	sbiw	r30, 0x01	; 1
     ea0:	21 e3       	ldi	r18, 0x31	; 49
     ea2:	20 83       	st	Z, r18
     ea4:	89 97       	sbiw	r24, 0x29	; 41
     ea6:	08 95       	ret

00000ea8 <xPortStartScheduler>:
     ea8:	88 ee       	ldi	r24, 0xE8	; 232
     eaa:	93 e0       	ldi	r25, 0x03	; 3
     eac:	90 93 45 03 	sts	0x0345, r25
     eb0:	80 93 44 03 	sts	0x0344, r24
     eb4:	90 93 43 03 	sts	0x0343, r25
     eb8:	80 93 42 03 	sts	0x0342, r24
     ebc:	89 ef       	ldi	r24, 0xF9	; 249
     ebe:	87 bd       	out	0x27, r24	; 39
     ec0:	82 e0       	ldi	r24, 0x02	; 2
     ec2:	84 bd       	out	0x24, r24	; 36
     ec4:	83 e0       	ldi	r24, 0x03	; 3
     ec6:	85 bd       	out	0x25, r24	; 37
     ec8:	ee e6       	ldi	r30, 0x6E	; 110
     eca:	f0 e0       	ldi	r31, 0x00	; 0
     ecc:	80 81       	ld	r24, Z
     ece:	82 60       	ori	r24, 0x02	; 2
     ed0:	80 83       	st	Z, r24
     ed2:	a0 91 65 0d 	lds	r26, 0x0D65
     ed6:	b0 91 66 0d 	lds	r27, 0x0D66
     eda:	cd 91       	ld	r28, X+
     edc:	cd bf       	out	0x3d, r28	; 61
     ede:	dd 91       	ld	r29, X+
     ee0:	de bf       	out	0x3e, r29	; 62
     ee2:	ff 91       	pop	r31
     ee4:	ef 91       	pop	r30
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
     eea:	bf 91       	pop	r27
     eec:	af 91       	pop	r26
     eee:	9f 91       	pop	r25
     ef0:	8f 91       	pop	r24
     ef2:	7f 91       	pop	r23
     ef4:	6f 91       	pop	r22
     ef6:	5f 91       	pop	r21
     ef8:	4f 91       	pop	r20
     efa:	3f 91       	pop	r19
     efc:	2f 91       	pop	r18
     efe:	1f 91       	pop	r17
     f00:	0f 91       	pop	r16
     f02:	ff 90       	pop	r15
     f04:	ef 90       	pop	r14
     f06:	df 90       	pop	r13
     f08:	cf 90       	pop	r12
     f0a:	bf 90       	pop	r11
     f0c:	af 90       	pop	r10
     f0e:	9f 90       	pop	r9
     f10:	8f 90       	pop	r8
     f12:	7f 90       	pop	r7
     f14:	6f 90       	pop	r6
     f16:	5f 90       	pop	r5
     f18:	4f 90       	pop	r4
     f1a:	3f 90       	pop	r3
     f1c:	2f 90       	pop	r2
     f1e:	1f 90       	pop	r1
     f20:	0f 90       	pop	r0
     f22:	0c be       	out	0x3c, r0	; 60
     f24:	0f 90       	pop	r0
     f26:	0b be       	out	0x3b, r0	; 59
     f28:	0f 90       	pop	r0
     f2a:	0f be       	out	0x3f, r0	; 63
     f2c:	0f 90       	pop	r0
     f2e:	08 95       	ret
     f30:	81 e0       	ldi	r24, 0x01	; 1
     f32:	08 95       	ret

00000f34 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     f34:	0f 92       	push	r0
     f36:	0f b6       	in	r0, 0x3f	; 63
     f38:	f8 94       	cli
     f3a:	0f 92       	push	r0
     f3c:	0b b6       	in	r0, 0x3b	; 59
     f3e:	0f 92       	push	r0
     f40:	0c b6       	in	r0, 0x3c	; 60
     f42:	0f 92       	push	r0
     f44:	1f 92       	push	r1
     f46:	11 24       	eor	r1, r1
     f48:	2f 92       	push	r2
     f4a:	3f 92       	push	r3
     f4c:	4f 92       	push	r4
     f4e:	5f 92       	push	r5
     f50:	6f 92       	push	r6
     f52:	7f 92       	push	r7
     f54:	8f 92       	push	r8
     f56:	9f 92       	push	r9
     f58:	af 92       	push	r10
     f5a:	bf 92       	push	r11
     f5c:	cf 92       	push	r12
     f5e:	df 92       	push	r13
     f60:	ef 92       	push	r14
     f62:	ff 92       	push	r15
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	2f 93       	push	r18
     f6a:	3f 93       	push	r19
     f6c:	4f 93       	push	r20
     f6e:	5f 93       	push	r21
     f70:	6f 93       	push	r22
     f72:	7f 93       	push	r23
     f74:	8f 93       	push	r24
     f76:	9f 93       	push	r25
     f78:	af 93       	push	r26
     f7a:	bf 93       	push	r27
     f7c:	cf 93       	push	r28
     f7e:	df 93       	push	r29
     f80:	ef 93       	push	r30
     f82:	ff 93       	push	r31
     f84:	a0 91 65 0d 	lds	r26, 0x0D65
     f88:	b0 91 66 0d 	lds	r27, 0x0D66
     f8c:	0d b6       	in	r0, 0x3d	; 61
     f8e:	0d 92       	st	X+, r0
     f90:	0e b6       	in	r0, 0x3e	; 62
     f92:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f94:	b3 d5       	rcall	.+2918   	; 0x1afc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f96:	a0 91 65 0d 	lds	r26, 0x0D65
     f9a:	b0 91 66 0d 	lds	r27, 0x0D66
     f9e:	cd 91       	ld	r28, X+
     fa0:	cd bf       	out	0x3d, r28	; 61
     fa2:	dd 91       	ld	r29, X+
     fa4:	de bf       	out	0x3e, r29	; 62
     fa6:	ff 91       	pop	r31
     fa8:	ef 91       	pop	r30
     faa:	df 91       	pop	r29
     fac:	cf 91       	pop	r28
     fae:	bf 91       	pop	r27
     fb0:	af 91       	pop	r26
     fb2:	9f 91       	pop	r25
     fb4:	8f 91       	pop	r24
     fb6:	7f 91       	pop	r23
     fb8:	6f 91       	pop	r22
     fba:	5f 91       	pop	r21
     fbc:	4f 91       	pop	r20
     fbe:	3f 91       	pop	r19
     fc0:	2f 91       	pop	r18
     fc2:	1f 91       	pop	r17
     fc4:	0f 91       	pop	r16
     fc6:	ff 90       	pop	r15
     fc8:	ef 90       	pop	r14
     fca:	df 90       	pop	r13
     fcc:	cf 90       	pop	r12
     fce:	bf 90       	pop	r11
     fd0:	af 90       	pop	r10
     fd2:	9f 90       	pop	r9
     fd4:	8f 90       	pop	r8
     fd6:	7f 90       	pop	r7
     fd8:	6f 90       	pop	r6
     fda:	5f 90       	pop	r5
     fdc:	4f 90       	pop	r4
     fde:	3f 90       	pop	r3
     fe0:	2f 90       	pop	r2
     fe2:	1f 90       	pop	r1
     fe4:	0f 90       	pop	r0
     fe6:	0c be       	out	0x3c, r0	; 60
     fe8:	0f 90       	pop	r0
     fea:	0b be       	out	0x3b, r0	; 59
     fec:	0f 90       	pop	r0
     fee:	0f be       	out	0x3f, r0	; 63
     ff0:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
     ff2:	08 95       	ret

00000ff4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ff4:	0f 92       	push	r0
     ff6:	0f b6       	in	r0, 0x3f	; 63
     ff8:	f8 94       	cli
     ffa:	0f 92       	push	r0
     ffc:	0b b6       	in	r0, 0x3b	; 59
     ffe:	0f 92       	push	r0
    1000:	0c b6       	in	r0, 0x3c	; 60
    1002:	0f 92       	push	r0
    1004:	1f 92       	push	r1
    1006:	11 24       	eor	r1, r1
    1008:	2f 92       	push	r2
    100a:	3f 92       	push	r3
    100c:	4f 92       	push	r4
    100e:	5f 92       	push	r5
    1010:	6f 92       	push	r6
    1012:	7f 92       	push	r7
    1014:	8f 92       	push	r8
    1016:	9f 92       	push	r9
    1018:	af 92       	push	r10
    101a:	bf 92       	push	r11
    101c:	cf 92       	push	r12
    101e:	df 92       	push	r13
    1020:	ef 92       	push	r14
    1022:	ff 92       	push	r15
    1024:	0f 93       	push	r16
    1026:	1f 93       	push	r17
    1028:	2f 93       	push	r18
    102a:	3f 93       	push	r19
    102c:	4f 93       	push	r20
    102e:	5f 93       	push	r21
    1030:	6f 93       	push	r22
    1032:	7f 93       	push	r23
    1034:	8f 93       	push	r24
    1036:	9f 93       	push	r25
    1038:	af 93       	push	r26
    103a:	bf 93       	push	r27
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	ef 93       	push	r30
    1042:	ff 93       	push	r31
    1044:	a0 91 65 0d 	lds	r26, 0x0D65
    1048:	b0 91 66 0d 	lds	r27, 0x0D66
    104c:	0d b6       	in	r0, 0x3d	; 61
    104e:	0d 92       	st	X+, r0
    1050:	0e b6       	in	r0, 0x3e	; 62
    1052:	0d 92       	st	X+, r0

	if (--ticksRemainingInSec == 0)
    1054:	80 91 42 03 	lds	r24, 0x0342
    1058:	90 91 43 03 	lds	r25, 0x0343
    105c:	01 97       	sbiw	r24, 0x01	; 1
    105e:	90 93 43 03 	sts	0x0343, r25
    1062:	80 93 42 03 	sts	0x0342, r24
    1066:	89 2b       	or	r24, r25
    1068:	41 f4       	brne	.+16     	; 0x107a <vPortYieldFromTick+0x86>
	{
//		system_tick();
		ticksRemainingInSec = portTickRateHz;
    106a:	80 91 44 03 	lds	r24, 0x0344
    106e:	90 91 45 03 	lds	r25, 0x0345
    1072:	90 93 43 03 	sts	0x0343, r25
    1076:	80 93 42 03 	sts	0x0342, r24
	}

	if( xTaskIncrementTick() != pdFALSE )
    107a:	ec d3       	rcall	.+2008   	; 0x1854 <xTaskIncrementTick>
    107c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    107e:	3e d5       	rcall	.+2684   	; 0x1afc <vTaskSwitchContext>
	}

	portRESTORE_CONTEXT();
    1080:	a0 91 65 0d 	lds	r26, 0x0D65
    1084:	b0 91 66 0d 	lds	r27, 0x0D66
    1088:	cd 91       	ld	r28, X+
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	dd 91       	ld	r29, X+
    108e:	de bf       	out	0x3e, r29	; 62
    1090:	ff 91       	pop	r31
    1092:	ef 91       	pop	r30
    1094:	df 91       	pop	r29
    1096:	cf 91       	pop	r28
    1098:	bf 91       	pop	r27
    109a:	af 91       	pop	r26
    109c:	9f 91       	pop	r25
    109e:	8f 91       	pop	r24
    10a0:	7f 91       	pop	r23
    10a2:	6f 91       	pop	r22
    10a4:	5f 91       	pop	r21
    10a6:	4f 91       	pop	r20
    10a8:	3f 91       	pop	r19
    10aa:	2f 91       	pop	r18
    10ac:	1f 91       	pop	r17
    10ae:	0f 91       	pop	r16
    10b0:	ff 90       	pop	r15
    10b2:	ef 90       	pop	r14
    10b4:	df 90       	pop	r13
    10b6:	cf 90       	pop	r12
    10b8:	bf 90       	pop	r11
    10ba:	af 90       	pop	r10
    10bc:	9f 90       	pop	r9
    10be:	8f 90       	pop	r8
    10c0:	7f 90       	pop	r7
    10c2:	6f 90       	pop	r6
    10c4:	5f 90       	pop	r5
    10c6:	4f 90       	pop	r4
    10c8:	3f 90       	pop	r3
    10ca:	2f 90       	pop	r2
    10cc:	1f 90       	pop	r1
    10ce:	0f 90       	pop	r0
    10d0:	0c be       	out	0x3c, r0	; 60
    10d2:	0f 90       	pop	r0
    10d4:	0b be       	out	0x3b, r0	; 59
    10d6:	0f 90       	pop	r0
    10d8:	0f be       	out	0x3f, r0	; 63
    10da:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    10dc:	08 95       	ret

000010de <__vector_21>:
	 */
//	ISR(TIMER_COMPA_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(TIMER_COMPA_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(TIMER_COMPA_ISR, ISR_NAKED)
	{
		vPortYieldFromTick();
    10de:	8a df       	rcall	.-236    	; 0xff4 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    10e0:	18 95       	reti

000010e2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10e2:	cf 93       	push	r28
    10e4:	df 93       	push	r29
    10e6:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    10e8:	af d3       	rcall	.+1886   	; 0x1848 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    10ea:	80 91 46 03 	lds	r24, 0x0346
    10ee:	90 91 47 03 	lds	r25, 0x0347
    10f2:	89 2b       	or	r24, r25
    10f4:	31 f4       	brne	.+12     	; 0x1102 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    10f6:	8b e4       	ldi	r24, 0x4B	; 75
    10f8:	93 e0       	ldi	r25, 0x03	; 3
    10fa:	90 93 47 03 	sts	0x0347, r25
    10fe:	80 93 46 03 	sts	0x0346, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1102:	40 91 48 03 	lds	r20, 0x0348
    1106:	50 91 49 03 	lds	r21, 0x0349
    110a:	9e 01       	movw	r18, r28
    110c:	24 0f       	add	r18, r20
    110e:	35 1f       	adc	r19, r21
    1110:	23 3c       	cpi	r18, 0xC3	; 195
    1112:	89 e0       	ldi	r24, 0x09	; 9
    1114:	38 07       	cpc	r19, r24
    1116:	70 f4       	brcc	.+28     	; 0x1134 <pvPortMalloc+0x52>
    1118:	42 17       	cp	r20, r18
    111a:	53 07       	cpc	r21, r19
    111c:	70 f4       	brcc	.+28     	; 0x113a <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    111e:	c0 91 46 03 	lds	r28, 0x0346
    1122:	d0 91 47 03 	lds	r29, 0x0347
    1126:	c4 0f       	add	r28, r20
    1128:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
    112a:	30 93 49 03 	sts	0x0349, r19
    112e:	20 93 48 03 	sts	0x0348, r18
    1132:	05 c0       	rjmp	.+10     	; 0x113e <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1134:	c0 e0       	ldi	r28, 0x00	; 0
    1136:	d0 e0       	ldi	r29, 0x00	; 0
    1138:	02 c0       	rjmp	.+4      	; 0x113e <pvPortMalloc+0x5c>
    113a:	c0 e0       	ldi	r28, 0x00	; 0
    113c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    113e:	45 d4       	rcall	.+2186   	; 0x19ca <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1140:	ce 01       	movw	r24, r28
    1142:	df 91       	pop	r29
    1144:	cf 91       	pop	r28
    1146:	08 95       	ret

00001148 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1148:	08 95       	ret

0000114a <prvCopyDataToQueue>:
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    114a:	1f 93       	push	r17
    114c:	cf 93       	push	r28
    114e:	df 93       	push	r29
    1150:	ec 01       	movw	r28, r24
    1152:	14 2f       	mov	r17, r20
    1154:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1156:	88 23       	and	r24, r24
    1158:	e9 f1       	breq	.+122    	; 0x11d4 <prvCopyDataToQueue+0x8a>
    115a:	41 11       	cpse	r20, r1
    115c:	17 c0       	rjmp	.+46     	; 0x118c <prvCopyDataToQueue+0x42>
    115e:	48 2f       	mov	r20, r24
    1160:	50 e0       	ldi	r21, 0x00	; 0
    1162:	8c 81       	ldd	r24, Y+4	; 0x04
    1164:	9d 81       	ldd	r25, Y+5	; 0x05
    1166:	0e 94 0f 15 	call	0x2a1e	; 0x2a1e <memcpy>
    116a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    116c:	8c 81       	ldd	r24, Y+4	; 0x04
    116e:	9d 81       	ldd	r25, Y+5	; 0x05
    1170:	82 0f       	add	r24, r18
    1172:	91 1d       	adc	r25, r1
    1174:	9d 83       	std	Y+5, r25	; 0x05
    1176:	8c 83       	std	Y+4, r24	; 0x04
    1178:	2a 81       	ldd	r18, Y+2	; 0x02
    117a:	3b 81       	ldd	r19, Y+3	; 0x03
    117c:	82 17       	cp	r24, r18
    117e:	93 07       	cpc	r25, r19
    1180:	48 f1       	brcs	.+82     	; 0x11d4 <prvCopyDataToQueue+0x8a>
    1182:	88 81       	ld	r24, Y
    1184:	99 81       	ldd	r25, Y+1	; 0x01
    1186:	9d 83       	std	Y+5, r25	; 0x05
    1188:	8c 83       	std	Y+4, r24	; 0x04
    118a:	24 c0       	rjmp	.+72     	; 0x11d4 <prvCopyDataToQueue+0x8a>
    118c:	48 2f       	mov	r20, r24
    118e:	50 e0       	ldi	r21, 0x00	; 0
    1190:	8e 81       	ldd	r24, Y+6	; 0x06
    1192:	9f 81       	ldd	r25, Y+7	; 0x07
    1194:	0e 94 0f 15 	call	0x2a1e	; 0x2a1e <memcpy>
    1198:	2c 8d       	ldd	r18, Y+28	; 0x1c
    119a:	30 e0       	ldi	r19, 0x00	; 0
    119c:	31 95       	neg	r19
    119e:	21 95       	neg	r18
    11a0:	31 09       	sbc	r19, r1
    11a2:	8e 81       	ldd	r24, Y+6	; 0x06
    11a4:	9f 81       	ldd	r25, Y+7	; 0x07
    11a6:	82 0f       	add	r24, r18
    11a8:	93 1f       	adc	r25, r19
    11aa:	9f 83       	std	Y+7, r25	; 0x07
    11ac:	8e 83       	std	Y+6, r24	; 0x06
    11ae:	68 81       	ld	r22, Y
    11b0:	79 81       	ldd	r23, Y+1	; 0x01
    11b2:	86 17       	cp	r24, r22
    11b4:	97 07       	cpc	r25, r23
    11b6:	30 f4       	brcc	.+12     	; 0x11c4 <prvCopyDataToQueue+0x7a>
    11b8:	8a 81       	ldd	r24, Y+2	; 0x02
    11ba:	9b 81       	ldd	r25, Y+3	; 0x03
    11bc:	28 0f       	add	r18, r24
    11be:	39 1f       	adc	r19, r25
    11c0:	3f 83       	std	Y+7, r19	; 0x07
    11c2:	2e 83       	std	Y+6, r18	; 0x06
    11c4:	12 30       	cpi	r17, 0x02	; 2
    11c6:	31 f4       	brne	.+12     	; 0x11d4 <prvCopyDataToQueue+0x8a>
    11c8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11ca:	88 23       	and	r24, r24
    11cc:	19 f0       	breq	.+6      	; 0x11d4 <prvCopyDataToQueue+0x8a>
    11ce:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11d0:	81 50       	subi	r24, 0x01	; 1
    11d2:	8a 8f       	std	Y+26, r24	; 0x1a
    11d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11d6:	8f 5f       	subi	r24, 0xFF	; 255
    11d8:	8a 8f       	std	Y+26, r24	; 0x1a
    11da:	80 e0       	ldi	r24, 0x00	; 0
    11dc:	df 91       	pop	r29
    11de:	cf 91       	pop	r28
    11e0:	1f 91       	pop	r17
    11e2:	08 95       	ret

000011e4 <prvCopyDataFromQueue>:
    11e4:	fc 01       	movw	r30, r24
    11e6:	cb 01       	movw	r24, r22
    11e8:	44 8d       	ldd	r20, Z+28	; 0x1c
    11ea:	44 23       	and	r20, r20
    11ec:	a1 f0       	breq	.+40     	; 0x1216 <prvCopyDataFromQueue+0x32>
    11ee:	50 e0       	ldi	r21, 0x00	; 0
    11f0:	26 81       	ldd	r18, Z+6	; 0x06
    11f2:	37 81       	ldd	r19, Z+7	; 0x07
    11f4:	24 0f       	add	r18, r20
    11f6:	35 1f       	adc	r19, r21
    11f8:	37 83       	std	Z+7, r19	; 0x07
    11fa:	26 83       	std	Z+6, r18	; 0x06
    11fc:	62 81       	ldd	r22, Z+2	; 0x02
    11fe:	73 81       	ldd	r23, Z+3	; 0x03
    1200:	26 17       	cp	r18, r22
    1202:	37 07       	cpc	r19, r23
    1204:	20 f0       	brcs	.+8      	; 0x120e <prvCopyDataFromQueue+0x2a>
    1206:	20 81       	ld	r18, Z
    1208:	31 81       	ldd	r19, Z+1	; 0x01
    120a:	37 83       	std	Z+7, r19	; 0x07
    120c:	26 83       	std	Z+6, r18	; 0x06
    120e:	66 81       	ldd	r22, Z+6	; 0x06
    1210:	77 81       	ldd	r23, Z+7	; 0x07
    1212:	0c 94 0f 15 	jmp	0x2a1e	; 0x2a1e <memcpy>
    1216:	08 95       	ret

00001218 <prvUnlockQueue>:
    1218:	0f 93       	push	r16
    121a:	1f 93       	push	r17
    121c:	cf 93       	push	r28
    121e:	df 93       	push	r29
    1220:	ec 01       	movw	r28, r24
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	f8 94       	cli
    1226:	0f 92       	push	r0
    1228:	8e 8d       	ldd	r24, Y+30	; 0x1e
    122a:	18 16       	cp	r1, r24
    122c:	a4 f4       	brge	.+40     	; 0x1256 <prvUnlockQueue+0x3e>
    122e:	89 89       	ldd	r24, Y+17	; 0x11
    1230:	88 23       	and	r24, r24
    1232:	89 f0       	breq	.+34     	; 0x1256 <prvUnlockQueue+0x3e>
    1234:	8e 01       	movw	r16, r28
    1236:	0f 5e       	subi	r16, 0xEF	; 239
    1238:	1f 4f       	sbci	r17, 0xFF	; 255
    123a:	03 c0       	rjmp	.+6      	; 0x1242 <prvUnlockQueue+0x2a>
    123c:	89 89       	ldd	r24, Y+17	; 0x11
    123e:	88 23       	and	r24, r24
    1240:	51 f0       	breq	.+20     	; 0x1256 <prvUnlockQueue+0x3e>
    1242:	c8 01       	movw	r24, r16
    1244:	ed d4       	rcall	.+2522   	; 0x1c20 <xTaskRemoveFromEventList>
    1246:	81 11       	cpse	r24, r1
    1248:	6c d5       	rcall	.+2776   	; 0x1d22 <vTaskMissedYield>
    124a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    124c:	81 50       	subi	r24, 0x01	; 1
    124e:	8e 8f       	std	Y+30, r24	; 0x1e
    1250:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1252:	18 16       	cp	r1, r24
    1254:	9c f3       	brlt	.-26     	; 0x123c <prvUnlockQueue+0x24>
    1256:	8f ef       	ldi	r24, 0xFF	; 255
    1258:	8e 8f       	std	Y+30, r24	; 0x1e
    125a:	0f 90       	pop	r0
    125c:	0f be       	out	0x3f, r0	; 63
    125e:	0f b6       	in	r0, 0x3f	; 63
    1260:	f8 94       	cli
    1262:	0f 92       	push	r0
    1264:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1266:	18 16       	cp	r1, r24
    1268:	a4 f4       	brge	.+40     	; 0x1292 <prvUnlockQueue+0x7a>
    126a:	88 85       	ldd	r24, Y+8	; 0x08
    126c:	88 23       	and	r24, r24
    126e:	89 f0       	breq	.+34     	; 0x1292 <prvUnlockQueue+0x7a>
    1270:	8e 01       	movw	r16, r28
    1272:	08 5f       	subi	r16, 0xF8	; 248
    1274:	1f 4f       	sbci	r17, 0xFF	; 255
    1276:	03 c0       	rjmp	.+6      	; 0x127e <prvUnlockQueue+0x66>
    1278:	88 85       	ldd	r24, Y+8	; 0x08
    127a:	88 23       	and	r24, r24
    127c:	51 f0       	breq	.+20     	; 0x1292 <prvUnlockQueue+0x7a>
    127e:	c8 01       	movw	r24, r16
    1280:	cf d4       	rcall	.+2462   	; 0x1c20 <xTaskRemoveFromEventList>
    1282:	81 11       	cpse	r24, r1
    1284:	4e d5       	rcall	.+2716   	; 0x1d22 <vTaskMissedYield>
    1286:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	8d 8f       	std	Y+29, r24	; 0x1d
    128c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    128e:	18 16       	cp	r1, r24
    1290:	9c f3       	brlt	.-26     	; 0x1278 <prvUnlockQueue+0x60>
    1292:	8f ef       	ldi	r24, 0xFF	; 255
    1294:	8d 8f       	std	Y+29, r24	; 0x1d
    1296:	0f 90       	pop	r0
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	08 95       	ret

000012a4 <xQueueGenericReset>:
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	ec 01       	movw	r28, r24
    12aa:	0f b6       	in	r0, 0x3f	; 63
    12ac:	f8 94       	cli
    12ae:	0f 92       	push	r0
    12b0:	88 81       	ld	r24, Y
    12b2:	99 81       	ldd	r25, Y+1	; 0x01
    12b4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12b6:	30 e0       	ldi	r19, 0x00	; 0
    12b8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    12ba:	72 9f       	mul	r23, r18
    12bc:	a0 01       	movw	r20, r0
    12be:	73 9f       	mul	r23, r19
    12c0:	50 0d       	add	r21, r0
    12c2:	11 24       	eor	r1, r1
    12c4:	fc 01       	movw	r30, r24
    12c6:	e4 0f       	add	r30, r20
    12c8:	f5 1f       	adc	r31, r21
    12ca:	fb 83       	std	Y+3, r31	; 0x03
    12cc:	ea 83       	std	Y+2, r30	; 0x02
    12ce:	1a 8e       	std	Y+26, r1	; 0x1a
    12d0:	9d 83       	std	Y+5, r25	; 0x05
    12d2:	8c 83       	std	Y+4, r24	; 0x04
    12d4:	42 1b       	sub	r20, r18
    12d6:	53 0b       	sbc	r21, r19
    12d8:	84 0f       	add	r24, r20
    12da:	95 1f       	adc	r25, r21
    12dc:	9f 83       	std	Y+7, r25	; 0x07
    12de:	8e 83       	std	Y+6, r24	; 0x06
    12e0:	8f ef       	ldi	r24, 0xFF	; 255
    12e2:	8d 8f       	std	Y+29, r24	; 0x1d
    12e4:	8e 8f       	std	Y+30, r24	; 0x1e
    12e6:	61 11       	cpse	r22, r1
    12e8:	0a c0       	rjmp	.+20     	; 0x12fe <xQueueGenericReset+0x5a>
    12ea:	88 85       	ldd	r24, Y+8	; 0x08
    12ec:	88 23       	and	r24, r24
    12ee:	69 f0       	breq	.+26     	; 0x130a <xQueueGenericReset+0x66>
    12f0:	ce 01       	movw	r24, r28
    12f2:	08 96       	adiw	r24, 0x08	; 8
    12f4:	95 d4       	rcall	.+2346   	; 0x1c20 <xTaskRemoveFromEventList>
    12f6:	81 30       	cpi	r24, 0x01	; 1
    12f8:	41 f4       	brne	.+16     	; 0x130a <xQueueGenericReset+0x66>
    12fa:	1c de       	rcall	.-968    	; 0xf34 <vPortYield>
    12fc:	06 c0       	rjmp	.+12     	; 0x130a <xQueueGenericReset+0x66>
    12fe:	ce 01       	movw	r24, r28
    1300:	08 96       	adiw	r24, 0x08	; 8
    1302:	d6 dc       	rcall	.-1620   	; 0xcb0 <vListInitialise>
    1304:	ce 01       	movw	r24, r28
    1306:	41 96       	adiw	r24, 0x11	; 17
    1308:	d3 dc       	rcall	.-1626   	; 0xcb0 <vListInitialise>
    130a:	0f 90       	pop	r0
    130c:	0f be       	out	0x3f, r0	; 63
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	08 95       	ret

00001316 <xQueueGenericCreate>:
    1316:	0f 93       	push	r16
    1318:	1f 93       	push	r17
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
    131e:	08 2f       	mov	r16, r24
    1320:	16 2f       	mov	r17, r22
    1322:	66 23       	and	r22, r22
    1324:	b9 f0       	breq	.+46     	; 0x1354 <xQueueGenericCreate+0x3e>
    1326:	86 9f       	mul	r24, r22
    1328:	c0 01       	movw	r24, r0
    132a:	11 24       	eor	r1, r1
    132c:	80 96       	adiw	r24, 0x20	; 32
    132e:	d9 de       	rcall	.-590    	; 0x10e2 <pvPortMalloc>
    1330:	ec 01       	movw	r28, r24
    1332:	00 97       	sbiw	r24, 0x00	; 0
    1334:	21 f4       	brne	.+8      	; 0x133e <xQueueGenericCreate+0x28>
    1336:	14 c0       	rjmp	.+40     	; 0x1360 <xQueueGenericCreate+0x4a>
    1338:	d9 83       	std	Y+1, r29	; 0x01
    133a:	c8 83       	st	Y, r28
    133c:	05 c0       	rjmp	.+10     	; 0x1348 <xQueueGenericCreate+0x32>
    133e:	9c 01       	movw	r18, r24
    1340:	21 5e       	subi	r18, 0xE1	; 225
    1342:	3f 4f       	sbci	r19, 0xFF	; 255
    1344:	39 83       	std	Y+1, r19	; 0x01
    1346:	28 83       	st	Y, r18
    1348:	0b 8f       	std	Y+27, r16	; 0x1b
    134a:	1c 8f       	std	Y+28, r17	; 0x1c
    134c:	61 e0       	ldi	r22, 0x01	; 1
    134e:	ce 01       	movw	r24, r28
    1350:	a9 df       	rcall	.-174    	; 0x12a4 <xQueueGenericReset>
    1352:	06 c0       	rjmp	.+12     	; 0x1360 <xQueueGenericCreate+0x4a>
    1354:	8f e1       	ldi	r24, 0x1F	; 31
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	c4 de       	rcall	.-632    	; 0x10e2 <pvPortMalloc>
    135a:	ec 01       	movw	r28, r24
    135c:	00 97       	sbiw	r24, 0x00	; 0
    135e:	61 f7       	brne	.-40     	; 0x1338 <xQueueGenericCreate+0x22>
    1360:	ce 01       	movw	r24, r28
    1362:	df 91       	pop	r29
    1364:	cf 91       	pop	r28
    1366:	1f 91       	pop	r17
    1368:	0f 91       	pop	r16
    136a:	08 95       	ret

0000136c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    136c:	0f 93       	push	r16
    136e:	1f 93       	push	r17
    1370:	cf 93       	push	r28
    1372:	df 93       	push	r29
    1374:	ec 01       	movw	r28, r24
    1376:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1378:	9a 8d       	ldd	r25, Y+26	; 0x1a
    137a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    137c:	98 17       	cp	r25, r24
    137e:	10 f0       	brcs	.+4      	; 0x1384 <xQueueGenericSendFromISR+0x18>
    1380:	22 30       	cpi	r18, 0x02	; 2
    1382:	d1 f4       	brne	.+52     	; 0x13b8 <xQueueGenericSendFromISR+0x4c>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1384:	42 2f       	mov	r20, r18
    1386:	ce 01       	movw	r24, r28
    1388:	e0 de       	rcall	.-576    	; 0x114a <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    138a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    138c:	8f 3f       	cpi	r24, 0xFF	; 255
    138e:	79 f4       	brne	.+30     	; 0x13ae <xQueueGenericSendFromISR+0x42>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1390:	89 89       	ldd	r24, Y+17	; 0x11
    1392:	88 23       	and	r24, r24
    1394:	99 f0       	breq	.+38     	; 0x13bc <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1396:	ce 01       	movw	r24, r28
    1398:	41 96       	adiw	r24, 0x11	; 17
    139a:	42 d4       	rcall	.+2180   	; 0x1c20 <xTaskRemoveFromEventList>
    139c:	88 23       	and	r24, r24
    139e:	81 f0       	breq	.+32     	; 0x13c0 <xQueueGenericSendFromISR+0x54>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    13a0:	01 15       	cp	r16, r1
    13a2:	11 05       	cpc	r17, r1
    13a4:	79 f0       	breq	.+30     	; 0x13c4 <xQueueGenericSendFromISR+0x58>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	f8 01       	movw	r30, r16
    13aa:	80 83       	st	Z, r24
    13ac:	0c c0       	rjmp	.+24     	; 0x13c6 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13ae:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13b0:	8f 5f       	subi	r24, 0xFF	; 255
    13b2:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13b4:	81 e0       	ldi	r24, 0x01	; 1
    13b6:	07 c0       	rjmp	.+14     	; 0x13c6 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13b8:	80 e0       	ldi	r24, 0x00	; 0
    13ba:	05 c0       	rjmp	.+10     	; 0x13c6 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	03 c0       	rjmp	.+6      	; 0x13c6 <xQueueGenericSendFromISR+0x5a>
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	01 c0       	rjmp	.+2      	; 0x13c6 <xQueueGenericSendFromISR+0x5a>
    13c4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	1f 91       	pop	r17
    13cc:	0f 91       	pop	r16
    13ce:	08 95       	ret

000013d0 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	fc 01       	movw	r30, r24
    13d6:	eb 01       	movw	r28, r22
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    13d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    13da:	83 8d       	ldd	r24, Z+27	; 0x1b
    13dc:	98 17       	cp	r25, r24
    13de:	c0 f4       	brcc	.+48     	; 0x1410 <xQueueGiveFromISR+0x40>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    13e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    13e2:	8f 5f       	subi	r24, 0xFF	; 255
    13e4:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    13e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    13e8:	8f 3f       	cpi	r24, 0xFF	; 255
    13ea:	69 f4       	brne	.+26     	; 0x1406 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13ec:	81 89       	ldd	r24, Z+17	; 0x11
    13ee:	88 23       	and	r24, r24
    13f0:	89 f0       	breq	.+34     	; 0x1414 <xQueueGiveFromISR+0x44>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13f2:	cf 01       	movw	r24, r30
    13f4:	41 96       	adiw	r24, 0x11	; 17
    13f6:	14 d4       	rcall	.+2088   	; 0x1c20 <xTaskRemoveFromEventList>
    13f8:	88 23       	and	r24, r24
    13fa:	71 f0       	breq	.+28     	; 0x1418 <xQueueGiveFromISR+0x48>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    13fc:	20 97       	sbiw	r28, 0x00	; 0
    13fe:	71 f0       	breq	.+28     	; 0x141c <xQueueGiveFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1400:	81 e0       	ldi	r24, 0x01	; 1
    1402:	88 83       	st	Y, r24
    1404:	0c c0       	rjmp	.+24     	; 0x141e <xQueueGiveFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1406:	86 8d       	ldd	r24, Z+30	; 0x1e
    1408:	8f 5f       	subi	r24, 0xFF	; 255
    140a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	07 c0       	rjmp	.+14     	; 0x141e <xQueueGiveFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	05 c0       	rjmp	.+10     	; 0x141e <xQueueGiveFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1414:	81 e0       	ldi	r24, 0x01	; 1
    1416:	03 c0       	rjmp	.+6      	; 0x141e <xQueueGiveFromISR+0x4e>
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	01 c0       	rjmp	.+2      	; 0x141e <xQueueGiveFromISR+0x4e>
    141c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    141e:	df 91       	pop	r29
    1420:	cf 91       	pop	r28
    1422:	08 95       	ret

00001424 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1424:	9f 92       	push	r9
    1426:	af 92       	push	r10
    1428:	bf 92       	push	r11
    142a:	cf 92       	push	r12
    142c:	df 92       	push	r13
    142e:	ef 92       	push	r14
    1430:	ff 92       	push	r15
    1432:	0f 93       	push	r16
    1434:	1f 93       	push	r17
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	00 d0       	rcall	.+0      	; 0x143c <xQueueGenericReceive+0x18>
    143c:	1f 92       	push	r1
    143e:	1f 92       	push	r1
    1440:	cd b7       	in	r28, 0x3d	; 61
    1442:	de b7       	in	r29, 0x3e	; 62
    1444:	8c 01       	movw	r16, r24
    1446:	6b 01       	movw	r12, r22
    1448:	5d 83       	std	Y+5, r21	; 0x05
    144a:	4c 83       	std	Y+4, r20	; 0x04
    144c:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    144e:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1450:	99 24       	eor	r9, r9
    1452:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1454:	7c 01       	movw	r14, r24
    1456:	81 e1       	ldi	r24, 0x11	; 17
    1458:	e8 0e       	add	r14, r24
    145a:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    145c:	0f b6       	in	r0, 0x3f	; 63
    145e:	f8 94       	cli
    1460:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1462:	f8 01       	movw	r30, r16
    1464:	82 8d       	ldd	r24, Z+26	; 0x1a
    1466:	88 23       	and	r24, r24
    1468:	21 f1       	breq	.+72     	; 0x14b2 <xQueueGenericReceive+0x8e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    146a:	e6 80       	ldd	r14, Z+6	; 0x06
    146c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    146e:	b6 01       	movw	r22, r12
    1470:	c8 01       	movw	r24, r16
    1472:	b8 de       	rcall	.-656    	; 0x11e4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1474:	b1 10       	cpse	r11, r1
    1476:	0e c0       	rjmp	.+28     	; 0x1494 <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1478:	f8 01       	movw	r30, r16
    147a:	82 8d       	ldd	r24, Z+26	; 0x1a
    147c:	81 50       	subi	r24, 0x01	; 1
    147e:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1480:	80 85       	ldd	r24, Z+8	; 0x08
    1482:	88 23       	and	r24, r24
    1484:	91 f0       	breq	.+36     	; 0x14aa <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1486:	c8 01       	movw	r24, r16
    1488:	08 96       	adiw	r24, 0x08	; 8
    148a:	ca d3       	rcall	.+1940   	; 0x1c20 <xTaskRemoveFromEventList>
    148c:	81 30       	cpi	r24, 0x01	; 1
    148e:	69 f4       	brne	.+26     	; 0x14aa <xQueueGenericReceive+0x86>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1490:	51 dd       	rcall	.-1374   	; 0xf34 <vPortYield>
    1492:	0b c0       	rjmp	.+22     	; 0x14aa <xQueueGenericReceive+0x86>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1494:	f8 01       	movw	r30, r16
    1496:	f7 82       	std	Z+7, r15	; 0x07
    1498:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    149a:	81 89       	ldd	r24, Z+17	; 0x11
    149c:	88 23       	and	r24, r24
    149e:	29 f0       	breq	.+10     	; 0x14aa <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14a0:	c8 01       	movw	r24, r16
    14a2:	41 96       	adiw	r24, 0x11	; 17
    14a4:	bd d3       	rcall	.+1914   	; 0x1c20 <xTaskRemoveFromEventList>
    14a6:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    14a8:	45 dd       	rcall	.-1398   	; 0xf34 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    14aa:	0f 90       	pop	r0
    14ac:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	44 c0       	rjmp	.+136    	; 0x153a <xQueueGenericReceive+0x116>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    14b2:	4c 81       	ldd	r20, Y+4	; 0x04
    14b4:	5d 81       	ldd	r21, Y+5	; 0x05
    14b6:	45 2b       	or	r20, r21
    14b8:	21 f4       	brne	.+8      	; 0x14c2 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14ba:	0f 90       	pop	r0
    14bc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	3c c0       	rjmp	.+120    	; 0x153a <xQueueGenericReceive+0x116>
				}
				else if( xEntryTimeSet == pdFALSE )
    14c2:	a1 10       	cpse	r10, r1
    14c4:	04 c0       	rjmp	.+8      	; 0x14ce <xQueueGenericReceive+0xaa>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14c6:	ce 01       	movw	r24, r28
    14c8:	01 96       	adiw	r24, 0x01	; 1
    14ca:	ee d3       	rcall	.+2012   	; 0x1ca8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14cc:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    14ce:	0f 90       	pop	r0
    14d0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14d2:	ba d1       	rcall	.+884    	; 0x1848 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14d4:	0f b6       	in	r0, 0x3f	; 63
    14d6:	f8 94       	cli
    14d8:	0f 92       	push	r0
    14da:	f8 01       	movw	r30, r16
    14dc:	85 8d       	ldd	r24, Z+29	; 0x1d
    14de:	8f 3f       	cpi	r24, 0xFF	; 255
    14e0:	09 f4       	brne	.+2      	; 0x14e4 <xQueueGenericReceive+0xc0>
    14e2:	15 8e       	std	Z+29, r1	; 0x1d
    14e4:	f8 01       	movw	r30, r16
    14e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    14e8:	8f 3f       	cpi	r24, 0xFF	; 255
    14ea:	09 f4       	brne	.+2      	; 0x14ee <xQueueGenericReceive+0xca>
    14ec:	16 8e       	std	Z+30, r1	; 0x1e
    14ee:	0f 90       	pop	r0
    14f0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14f2:	be 01       	movw	r22, r28
    14f4:	6c 5f       	subi	r22, 0xFC	; 252
    14f6:	7f 4f       	sbci	r23, 0xFF	; 255
    14f8:	ce 01       	movw	r24, r28
    14fa:	01 96       	adiw	r24, 0x01	; 1
    14fc:	e0 d3       	rcall	.+1984   	; 0x1cbe <xTaskCheckForTimeOut>
    14fe:	81 11       	cpse	r24, r1
    1500:	18 c0       	rjmp	.+48     	; 0x1532 <xQueueGenericReceive+0x10e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	f8 94       	cli
    1506:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1508:	f8 01       	movw	r30, r16
    150a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    150c:	0f 90       	pop	r0
    150e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1510:	81 11       	cpse	r24, r1
    1512:	0b c0       	rjmp	.+22     	; 0x152a <xQueueGenericReceive+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1514:	6c 81       	ldd	r22, Y+4	; 0x04
    1516:	7d 81       	ldd	r23, Y+5	; 0x05
    1518:	c7 01       	movw	r24, r14
    151a:	68 d3       	rcall	.+1744   	; 0x1bec <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    151c:	c8 01       	movw	r24, r16
    151e:	7c de       	rcall	.-776    	; 0x1218 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1520:	54 d2       	rcall	.+1192   	; 0x19ca <xTaskResumeAll>
    1522:	81 11       	cpse	r24, r1
    1524:	9b cf       	rjmp	.-202    	; 0x145c <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1526:	06 dd       	rcall	.-1524   	; 0xf34 <vPortYield>
    1528:	99 cf       	rjmp	.-206    	; 0x145c <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    152a:	c8 01       	movw	r24, r16
    152c:	75 de       	rcall	.-790    	; 0x1218 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    152e:	4d d2       	rcall	.+1178   	; 0x19ca <xTaskResumeAll>
    1530:	95 cf       	rjmp	.-214    	; 0x145c <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1532:	c8 01       	movw	r24, r16
    1534:	71 de       	rcall	.-798    	; 0x1218 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1536:	49 d2       	rcall	.+1170   	; 0x19ca <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1538:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    153a:	0f 90       	pop	r0
    153c:	0f 90       	pop	r0
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0
    1542:	0f 90       	pop	r0
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	1f 91       	pop	r17
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	df 90       	pop	r13
    1552:	cf 90       	pop	r12
    1554:	bf 90       	pop	r11
    1556:	af 90       	pop	r10
    1558:	9f 90       	pop	r9
    155a:	08 95       	ret

0000155c <prvResetNextTaskUnblockTime>:
    155c:	e0 91 2d 0d 	lds	r30, 0x0D2D
    1560:	f0 91 2e 0d 	lds	r31, 0x0D2E
    1564:	80 81       	ld	r24, Z
    1566:	81 11       	cpse	r24, r1
    1568:	07 c0       	rjmp	.+14     	; 0x1578 <prvResetNextTaskUnblockTime+0x1c>
    156a:	8f ef       	ldi	r24, 0xFF	; 255
    156c:	9f ef       	ldi	r25, 0xFF	; 255
    156e:	90 93 4a 02 	sts	0x024A, r25
    1572:	80 93 49 02 	sts	0x0249, r24
    1576:	08 95       	ret
    1578:	e0 91 2d 0d 	lds	r30, 0x0D2D
    157c:	f0 91 2e 0d 	lds	r31, 0x0D2E
    1580:	05 80       	ldd	r0, Z+5	; 0x05
    1582:	f6 81       	ldd	r31, Z+6	; 0x06
    1584:	e0 2d       	mov	r30, r0
    1586:	06 80       	ldd	r0, Z+6	; 0x06
    1588:	f7 81       	ldd	r31, Z+7	; 0x07
    158a:	e0 2d       	mov	r30, r0
    158c:	82 81       	ldd	r24, Z+2	; 0x02
    158e:	93 81       	ldd	r25, Z+3	; 0x03
    1590:	90 93 4a 02 	sts	0x024A, r25
    1594:	80 93 49 02 	sts	0x0249, r24
    1598:	08 95       	ret

0000159a <prvAddCurrentTaskToDelayedList>:
    159a:	cf 93       	push	r28
    159c:	df 93       	push	r29
    159e:	ec 01       	movw	r28, r24
    15a0:	e0 91 65 0d 	lds	r30, 0x0D65
    15a4:	f0 91 66 0d 	lds	r31, 0x0D66
    15a8:	93 83       	std	Z+3, r25	; 0x03
    15aa:	82 83       	std	Z+2, r24	; 0x02
    15ac:	80 91 15 0d 	lds	r24, 0x0D15
    15b0:	90 91 16 0d 	lds	r25, 0x0D16
    15b4:	c8 17       	cp	r28, r24
    15b6:	d9 07       	cpc	r29, r25
    15b8:	60 f4       	brcc	.+24     	; 0x15d2 <prvAddCurrentTaskToDelayedList+0x38>
    15ba:	60 91 65 0d 	lds	r22, 0x0D65
    15be:	70 91 66 0d 	lds	r23, 0x0D66
    15c2:	80 91 2b 0d 	lds	r24, 0x0D2B
    15c6:	90 91 2c 0d 	lds	r25, 0x0D2C
    15ca:	6e 5f       	subi	r22, 0xFE	; 254
    15cc:	7f 4f       	sbci	r23, 0xFF	; 255
    15ce:	a3 db       	rcall	.-2234   	; 0xd16 <vListInsert>
    15d0:	16 c0       	rjmp	.+44     	; 0x15fe <prvAddCurrentTaskToDelayedList+0x64>
    15d2:	60 91 65 0d 	lds	r22, 0x0D65
    15d6:	70 91 66 0d 	lds	r23, 0x0D66
    15da:	80 91 2d 0d 	lds	r24, 0x0D2D
    15de:	90 91 2e 0d 	lds	r25, 0x0D2E
    15e2:	6e 5f       	subi	r22, 0xFE	; 254
    15e4:	7f 4f       	sbci	r23, 0xFF	; 255
    15e6:	97 db       	rcall	.-2258   	; 0xd16 <vListInsert>
    15e8:	80 91 49 02 	lds	r24, 0x0249
    15ec:	90 91 4a 02 	lds	r25, 0x024A
    15f0:	c8 17       	cp	r28, r24
    15f2:	d9 07       	cpc	r29, r25
    15f4:	20 f4       	brcc	.+8      	; 0x15fe <prvAddCurrentTaskToDelayedList+0x64>
    15f6:	d0 93 4a 02 	sts	0x024A, r29
    15fa:	c0 93 49 02 	sts	0x0249, r28
    15fe:	df 91       	pop	r29
    1600:	cf 91       	pop	r28
    1602:	08 95       	ret

00001604 <xTaskGenericCreate>:
    1604:	4f 92       	push	r4
    1606:	5f 92       	push	r5
    1608:	6f 92       	push	r6
    160a:	7f 92       	push	r7
    160c:	8f 92       	push	r8
    160e:	9f 92       	push	r9
    1610:	af 92       	push	r10
    1612:	bf 92       	push	r11
    1614:	cf 92       	push	r12
    1616:	df 92       	push	r13
    1618:	ef 92       	push	r14
    161a:	ff 92       	push	r15
    161c:	0f 93       	push	r16
    161e:	1f 93       	push	r17
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
    1624:	4c 01       	movw	r8, r24
    1626:	5b 01       	movw	r10, r22
    1628:	2a 01       	movw	r4, r20
    162a:	39 01       	movw	r6, r18
    162c:	c1 14       	cp	r12, r1
    162e:	d1 04       	cpc	r13, r1
    1630:	31 f4       	brne	.+12     	; 0x163e <xTaskGenericCreate+0x3a>
    1632:	ca 01       	movw	r24, r20
    1634:	56 dd       	rcall	.-1364   	; 0x10e2 <pvPortMalloc>
    1636:	6c 01       	movw	r12, r24
    1638:	00 97       	sbiw	r24, 0x00	; 0
    163a:	09 f4       	brne	.+2      	; 0x163e <xTaskGenericCreate+0x3a>
    163c:	ca c0       	rjmp	.+404    	; 0x17d2 <xTaskGenericCreate+0x1ce>
    163e:	86 e2       	ldi	r24, 0x26	; 38
    1640:	90 e0       	ldi	r25, 0x00	; 0
    1642:	4f dd       	rcall	.-1378   	; 0x10e2 <pvPortMalloc>
    1644:	ec 01       	movw	r28, r24
    1646:	00 97       	sbiw	r24, 0x00	; 0
    1648:	71 f0       	breq	.+28     	; 0x1666 <xTaskGenericCreate+0x62>
    164a:	d8 8e       	std	Y+24, r13	; 0x18
    164c:	cf 8a       	std	Y+23, r12	; 0x17
    164e:	81 e0       	ldi	r24, 0x01	; 1
    1650:	48 1a       	sub	r4, r24
    1652:	51 08       	sbc	r5, r1
    1654:	c4 0c       	add	r12, r4
    1656:	d5 1c       	adc	r13, r5
    1658:	d5 01       	movw	r26, r10
    165a:	8c 91       	ld	r24, X
    165c:	89 8f       	std	Y+25, r24	; 0x19
    165e:	8c 91       	ld	r24, X
    1660:	81 11       	cpse	r24, r1
    1662:	04 c0       	rjmp	.+8      	; 0x166c <xTaskGenericCreate+0x68>
    1664:	14 c0       	rjmp	.+40     	; 0x168e <xTaskGenericCreate+0x8a>
    1666:	c6 01       	movw	r24, r12
    1668:	6f dd       	rcall	.-1314   	; 0x1148 <vPortFree>
    166a:	b3 c0       	rjmp	.+358    	; 0x17d2 <xTaskGenericCreate+0x1ce>
    166c:	ae 01       	movw	r20, r28
    166e:	46 5e       	subi	r20, 0xE6	; 230
    1670:	5f 4f       	sbci	r21, 0xFF	; 255
    1672:	f5 01       	movw	r30, r10
    1674:	31 96       	adiw	r30, 0x01	; 1
    1676:	27 e0       	ldi	r18, 0x07	; 7
    1678:	cf 01       	movw	r24, r30
    167a:	31 91       	ld	r19, Z+
    167c:	da 01       	movw	r26, r20
    167e:	3d 93       	st	X+, r19
    1680:	ad 01       	movw	r20, r26
    1682:	dc 01       	movw	r26, r24
    1684:	8c 91       	ld	r24, X
    1686:	88 23       	and	r24, r24
    1688:	11 f0       	breq	.+4      	; 0x168e <xTaskGenericCreate+0x8a>
    168a:	21 50       	subi	r18, 0x01	; 1
    168c:	a9 f7       	brne	.-22     	; 0x1678 <xTaskGenericCreate+0x74>
    168e:	18 a2       	std	Y+32, r1	; 0x20
    1690:	10 2f       	mov	r17, r16
    1692:	04 30       	cpi	r16, 0x04	; 4
    1694:	08 f0       	brcs	.+2      	; 0x1698 <xTaskGenericCreate+0x94>
    1696:	13 e0       	ldi	r17, 0x03	; 3
    1698:	1e 8b       	std	Y+22, r17	; 0x16
    169a:	5e 01       	movw	r10, r28
    169c:	b2 e0       	ldi	r27, 0x02	; 2
    169e:	ab 0e       	add	r10, r27
    16a0:	b1 1c       	adc	r11, r1
    16a2:	c5 01       	movw	r24, r10
    16a4:	13 db       	rcall	.-2522   	; 0xccc <vListInitialiseItem>
    16a6:	ce 01       	movw	r24, r28
    16a8:	0c 96       	adiw	r24, 0x0c	; 12
    16aa:	10 db       	rcall	.-2528   	; 0xccc <vListInitialiseItem>
    16ac:	d9 87       	std	Y+9, r29	; 0x09
    16ae:	c8 87       	std	Y+8, r28	; 0x08
    16b0:	84 e0       	ldi	r24, 0x04	; 4
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	81 1b       	sub	r24, r17
    16b6:	91 09       	sbc	r25, r1
    16b8:	9d 87       	std	Y+13, r25	; 0x0d
    16ba:	8c 87       	std	Y+12, r24	; 0x0c
    16bc:	db 8b       	std	Y+19, r29	; 0x13
    16be:	ca 8b       	std	Y+18, r28	; 0x12
    16c0:	19 a2       	std	Y+33, r1	; 0x21
    16c2:	1a a2       	std	Y+34, r1	; 0x22
    16c4:	1b a2       	std	Y+35, r1	; 0x23
    16c6:	1c a2       	std	Y+36, r1	; 0x24
    16c8:	1d a2       	std	Y+37, r1	; 0x25
    16ca:	a3 01       	movw	r20, r6
    16cc:	b4 01       	movw	r22, r8
    16ce:	c6 01       	movw	r24, r12
    16d0:	79 db       	rcall	.-2318   	; 0xdc4 <pxPortInitialiseStack>
    16d2:	99 83       	std	Y+1, r25	; 0x01
    16d4:	88 83       	st	Y, r24
    16d6:	e1 14       	cp	r14, r1
    16d8:	f1 04       	cpc	r15, r1
    16da:	19 f0       	breq	.+6      	; 0x16e2 <xTaskGenericCreate+0xde>
    16dc:	f7 01       	movw	r30, r14
    16de:	d1 83       	std	Z+1, r29	; 0x01
    16e0:	c0 83       	st	Z, r28
    16e2:	0f b6       	in	r0, 0x3f	; 63
    16e4:	f8 94       	cli
    16e6:	0f 92       	push	r0
    16e8:	80 91 17 0d 	lds	r24, 0x0D17
    16ec:	8f 5f       	subi	r24, 0xFF	; 255
    16ee:	80 93 17 0d 	sts	0x0D17, r24
    16f2:	80 91 65 0d 	lds	r24, 0x0D65
    16f6:	90 91 66 0d 	lds	r25, 0x0D66
    16fa:	89 2b       	or	r24, r25
    16fc:	69 f5       	brne	.+90     	; 0x1758 <xTaskGenericCreate+0x154>
    16fe:	d0 93 66 0d 	sts	0x0D66, r29
    1702:	c0 93 65 0d 	sts	0x0D65, r28
    1706:	80 91 17 0d 	lds	r24, 0x0D17
    170a:	81 30       	cpi	r24, 0x01	; 1
    170c:	a1 f5       	brne	.+104    	; 0x1776 <xTaskGenericCreate+0x172>
    170e:	81 e4       	ldi	r24, 0x41	; 65
    1710:	9d e0       	ldi	r25, 0x0D	; 13
    1712:	ce da       	rcall	.-2660   	; 0xcb0 <vListInitialise>
    1714:	8a e4       	ldi	r24, 0x4A	; 74
    1716:	9d e0       	ldi	r25, 0x0D	; 13
    1718:	cb da       	rcall	.-2666   	; 0xcb0 <vListInitialise>
    171a:	83 e5       	ldi	r24, 0x53	; 83
    171c:	9d e0       	ldi	r25, 0x0D	; 13
    171e:	c8 da       	rcall	.-2672   	; 0xcb0 <vListInitialise>
    1720:	8c e5       	ldi	r24, 0x5C	; 92
    1722:	9d e0       	ldi	r25, 0x0D	; 13
    1724:	c5 da       	rcall	.-2678   	; 0xcb0 <vListInitialise>
    1726:	88 e3       	ldi	r24, 0x38	; 56
    1728:	9d e0       	ldi	r25, 0x0D	; 13
    172a:	c2 da       	rcall	.-2684   	; 0xcb0 <vListInitialise>
    172c:	8f e2       	ldi	r24, 0x2F	; 47
    172e:	9d e0       	ldi	r25, 0x0D	; 13
    1730:	bf da       	rcall	.-2690   	; 0xcb0 <vListInitialise>
    1732:	82 e2       	ldi	r24, 0x22	; 34
    1734:	9d e0       	ldi	r25, 0x0D	; 13
    1736:	bc da       	rcall	.-2696   	; 0xcb0 <vListInitialise>
    1738:	89 e1       	ldi	r24, 0x19	; 25
    173a:	9d e0       	ldi	r25, 0x0D	; 13
    173c:	b9 da       	rcall	.-2702   	; 0xcb0 <vListInitialise>
    173e:	88 e3       	ldi	r24, 0x38	; 56
    1740:	9d e0       	ldi	r25, 0x0D	; 13
    1742:	90 93 2e 0d 	sts	0x0D2E, r25
    1746:	80 93 2d 0d 	sts	0x0D2D, r24
    174a:	8f e2       	ldi	r24, 0x2F	; 47
    174c:	9d e0       	ldi	r25, 0x0D	; 13
    174e:	90 93 2c 0d 	sts	0x0D2C, r25
    1752:	80 93 2b 0d 	sts	0x0D2B, r24
    1756:	0f c0       	rjmp	.+30     	; 0x1776 <xTaskGenericCreate+0x172>
    1758:	80 91 13 0d 	lds	r24, 0x0D13
    175c:	81 11       	cpse	r24, r1
    175e:	0b c0       	rjmp	.+22     	; 0x1776 <xTaskGenericCreate+0x172>
    1760:	e0 91 65 0d 	lds	r30, 0x0D65
    1764:	f0 91 66 0d 	lds	r31, 0x0D66
    1768:	86 89       	ldd	r24, Z+22	; 0x16
    176a:	08 17       	cp	r16, r24
    176c:	20 f0       	brcs	.+8      	; 0x1776 <xTaskGenericCreate+0x172>
    176e:	d0 93 66 0d 	sts	0x0D66, r29
    1772:	c0 93 65 0d 	sts	0x0D65, r28
    1776:	80 91 0f 0d 	lds	r24, 0x0D0F
    177a:	8f 5f       	subi	r24, 0xFF	; 255
    177c:	80 93 0f 0d 	sts	0x0D0F, r24
    1780:	8e 89       	ldd	r24, Y+22	; 0x16
    1782:	90 91 14 0d 	lds	r25, 0x0D14
    1786:	98 17       	cp	r25, r24
    1788:	10 f4       	brcc	.+4      	; 0x178e <xTaskGenericCreate+0x18a>
    178a:	80 93 14 0d 	sts	0x0D14, r24
    178e:	90 e0       	ldi	r25, 0x00	; 0
    1790:	9c 01       	movw	r18, r24
    1792:	22 0f       	add	r18, r18
    1794:	33 1f       	adc	r19, r19
    1796:	22 0f       	add	r18, r18
    1798:	33 1f       	adc	r19, r19
    179a:	22 0f       	add	r18, r18
    179c:	33 1f       	adc	r19, r19
    179e:	82 0f       	add	r24, r18
    17a0:	93 1f       	adc	r25, r19
    17a2:	b5 01       	movw	r22, r10
    17a4:	8f 5b       	subi	r24, 0xBF	; 191
    17a6:	92 4f       	sbci	r25, 0xF2	; 242
    17a8:	95 da       	rcall	.-2774   	; 0xcd4 <vListInsertEnd>
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63
    17ae:	80 91 13 0d 	lds	r24, 0x0D13
    17b2:	88 23       	and	r24, r24
    17b4:	51 f0       	breq	.+20     	; 0x17ca <xTaskGenericCreate+0x1c6>
    17b6:	e0 91 65 0d 	lds	r30, 0x0D65
    17ba:	f0 91 66 0d 	lds	r31, 0x0D66
    17be:	86 89       	ldd	r24, Z+22	; 0x16
    17c0:	80 17       	cp	r24, r16
    17c2:	28 f4       	brcc	.+10     	; 0x17ce <xTaskGenericCreate+0x1ca>
    17c4:	b7 db       	rcall	.-2194   	; 0xf34 <vPortYield>
    17c6:	81 e0       	ldi	r24, 0x01	; 1
    17c8:	05 c0       	rjmp	.+10     	; 0x17d4 <xTaskGenericCreate+0x1d0>
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	03 c0       	rjmp	.+6      	; 0x17d4 <xTaskGenericCreate+0x1d0>
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	01 c0       	rjmp	.+2      	; 0x17d4 <xTaskGenericCreate+0x1d0>
    17d2:	8f ef       	ldi	r24, 0xFF	; 255
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	1f 91       	pop	r17
    17da:	0f 91       	pop	r16
    17dc:	ff 90       	pop	r15
    17de:	ef 90       	pop	r14
    17e0:	df 90       	pop	r13
    17e2:	cf 90       	pop	r12
    17e4:	bf 90       	pop	r11
    17e6:	af 90       	pop	r10
    17e8:	9f 90       	pop	r9
    17ea:	8f 90       	pop	r8
    17ec:	7f 90       	pop	r7
    17ee:	6f 90       	pop	r6
    17f0:	5f 90       	pop	r5
    17f2:	4f 90       	pop	r4
    17f4:	08 95       	ret

000017f6 <vTaskStartScheduler>:
    17f6:	af 92       	push	r10
    17f8:	bf 92       	push	r11
    17fa:	cf 92       	push	r12
    17fc:	df 92       	push	r13
    17fe:	ef 92       	push	r14
    1800:	ff 92       	push	r15
    1802:	0f 93       	push	r16
    1804:	a1 2c       	mov	r10, r1
    1806:	b1 2c       	mov	r11, r1
    1808:	c1 2c       	mov	r12, r1
    180a:	d1 2c       	mov	r13, r1
    180c:	e1 2c       	mov	r14, r1
    180e:	f1 2c       	mov	r15, r1
    1810:	00 e0       	ldi	r16, 0x00	; 0
    1812:	20 e0       	ldi	r18, 0x00	; 0
    1814:	30 e0       	ldi	r19, 0x00	; 0
    1816:	49 eb       	ldi	r20, 0xB9	; 185
    1818:	50 e0       	ldi	r21, 0x00	; 0
    181a:	66 e8       	ldi	r22, 0x86	; 134
    181c:	72 e0       	ldi	r23, 0x02	; 2
    181e:	8d e8       	ldi	r24, 0x8D	; 141
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	f0 de       	rcall	.-544    	; 0x1604 <xTaskGenericCreate>
    1824:	81 30       	cpi	r24, 0x01	; 1
    1826:	41 f4       	brne	.+16     	; 0x1838 <vTaskStartScheduler+0x42>
    1828:	f8 94       	cli
    182a:	80 93 13 0d 	sts	0x0D13, r24
    182e:	10 92 16 0d 	sts	0x0D16, r1
    1832:	10 92 15 0d 	sts	0x0D15, r1
    1836:	38 db       	rcall	.-2448   	; 0xea8 <xPortStartScheduler>
    1838:	0f 91       	pop	r16
    183a:	ff 90       	pop	r15
    183c:	ef 90       	pop	r14
    183e:	df 90       	pop	r13
    1840:	cf 90       	pop	r12
    1842:	bf 90       	pop	r11
    1844:	af 90       	pop	r10
    1846:	08 95       	ret

00001848 <vTaskSuspendAll>:
    1848:	80 91 0e 0d 	lds	r24, 0x0D0E
    184c:	8f 5f       	subi	r24, 0xFF	; 255
    184e:	80 93 0e 0d 	sts	0x0D0E, r24
    1852:	08 95       	ret

00001854 <xTaskIncrementTick>:
    1854:	cf 92       	push	r12
    1856:	df 92       	push	r13
    1858:	ef 92       	push	r14
    185a:	ff 92       	push	r15
    185c:	0f 93       	push	r16
    185e:	1f 93       	push	r17
    1860:	cf 93       	push	r28
    1862:	df 93       	push	r29
    1864:	80 91 0e 0d 	lds	r24, 0x0D0E
    1868:	81 11       	cpse	r24, r1
    186a:	96 c0       	rjmp	.+300    	; 0x1998 <xTaskIncrementTick+0x144>
    186c:	80 91 15 0d 	lds	r24, 0x0D15
    1870:	90 91 16 0d 	lds	r25, 0x0D16
    1874:	01 96       	adiw	r24, 0x01	; 1
    1876:	90 93 16 0d 	sts	0x0D16, r25
    187a:	80 93 15 0d 	sts	0x0D15, r24
    187e:	e0 90 15 0d 	lds	r14, 0x0D15
    1882:	f0 90 16 0d 	lds	r15, 0x0D16
    1886:	e1 14       	cp	r14, r1
    1888:	f1 04       	cpc	r15, r1
    188a:	b1 f4       	brne	.+44     	; 0x18b8 <xTaskIncrementTick+0x64>
    188c:	80 91 2d 0d 	lds	r24, 0x0D2D
    1890:	90 91 2e 0d 	lds	r25, 0x0D2E
    1894:	20 91 2b 0d 	lds	r18, 0x0D2B
    1898:	30 91 2c 0d 	lds	r19, 0x0D2C
    189c:	30 93 2e 0d 	sts	0x0D2E, r19
    18a0:	20 93 2d 0d 	sts	0x0D2D, r18
    18a4:	90 93 2c 0d 	sts	0x0D2C, r25
    18a8:	80 93 2b 0d 	sts	0x0D2B, r24
    18ac:	80 91 10 0d 	lds	r24, 0x0D10
    18b0:	8f 5f       	subi	r24, 0xFF	; 255
    18b2:	80 93 10 0d 	sts	0x0D10, r24
    18b6:	52 de       	rcall	.-860    	; 0x155c <prvResetNextTaskUnblockTime>
    18b8:	80 91 49 02 	lds	r24, 0x0249
    18bc:	90 91 4a 02 	lds	r25, 0x024A
    18c0:	e8 16       	cp	r14, r24
    18c2:	f9 06       	cpc	r15, r25
    18c4:	08 f4       	brcc	.+2      	; 0x18c8 <xTaskIncrementTick+0x74>
    18c6:	51 c0       	rjmp	.+162    	; 0x196a <xTaskIncrementTick+0x116>
    18c8:	d1 2c       	mov	r13, r1
    18ca:	cc 24       	eor	r12, r12
    18cc:	c3 94       	inc	r12
    18ce:	01 c0       	rjmp	.+2      	; 0x18d2 <xTaskIncrementTick+0x7e>
    18d0:	dc 2c       	mov	r13, r12
    18d2:	e0 91 2d 0d 	lds	r30, 0x0D2D
    18d6:	f0 91 2e 0d 	lds	r31, 0x0D2E
    18da:	80 81       	ld	r24, Z
    18dc:	81 11       	cpse	r24, r1
    18de:	07 c0       	rjmp	.+14     	; 0x18ee <xTaskIncrementTick+0x9a>
    18e0:	8f ef       	ldi	r24, 0xFF	; 255
    18e2:	9f ef       	ldi	r25, 0xFF	; 255
    18e4:	90 93 4a 02 	sts	0x024A, r25
    18e8:	80 93 49 02 	sts	0x0249, r24
    18ec:	3f c0       	rjmp	.+126    	; 0x196c <xTaskIncrementTick+0x118>
    18ee:	e0 91 2d 0d 	lds	r30, 0x0D2D
    18f2:	f0 91 2e 0d 	lds	r31, 0x0D2E
    18f6:	05 80       	ldd	r0, Z+5	; 0x05
    18f8:	f6 81       	ldd	r31, Z+6	; 0x06
    18fa:	e0 2d       	mov	r30, r0
    18fc:	c6 81       	ldd	r28, Z+6	; 0x06
    18fe:	d7 81       	ldd	r29, Z+7	; 0x07
    1900:	2a 81       	ldd	r18, Y+2	; 0x02
    1902:	3b 81       	ldd	r19, Y+3	; 0x03
    1904:	e2 16       	cp	r14, r18
    1906:	f3 06       	cpc	r15, r19
    1908:	28 f4       	brcc	.+10     	; 0x1914 <xTaskIncrementTick+0xc0>
    190a:	30 93 4a 02 	sts	0x024A, r19
    190e:	20 93 49 02 	sts	0x0249, r18
    1912:	2c c0       	rjmp	.+88     	; 0x196c <xTaskIncrementTick+0x118>
    1914:	8e 01       	movw	r16, r28
    1916:	0e 5f       	subi	r16, 0xFE	; 254
    1918:	1f 4f       	sbci	r17, 0xFF	; 255
    191a:	c8 01       	movw	r24, r16
    191c:	2d da       	rcall	.-2982   	; 0xd78 <uxListRemove>
    191e:	8c 89       	ldd	r24, Y+20	; 0x14
    1920:	9d 89       	ldd	r25, Y+21	; 0x15
    1922:	89 2b       	or	r24, r25
    1924:	19 f0       	breq	.+6      	; 0x192c <xTaskIncrementTick+0xd8>
    1926:	ce 01       	movw	r24, r28
    1928:	0c 96       	adiw	r24, 0x0c	; 12
    192a:	26 da       	rcall	.-2996   	; 0xd78 <uxListRemove>
    192c:	2e 89       	ldd	r18, Y+22	; 0x16
    192e:	80 91 14 0d 	lds	r24, 0x0D14
    1932:	82 17       	cp	r24, r18
    1934:	10 f4       	brcc	.+4      	; 0x193a <xTaskIncrementTick+0xe6>
    1936:	20 93 14 0d 	sts	0x0D14, r18
    193a:	30 e0       	ldi	r19, 0x00	; 0
    193c:	c9 01       	movw	r24, r18
    193e:	88 0f       	add	r24, r24
    1940:	99 1f       	adc	r25, r25
    1942:	88 0f       	add	r24, r24
    1944:	99 1f       	adc	r25, r25
    1946:	88 0f       	add	r24, r24
    1948:	99 1f       	adc	r25, r25
    194a:	82 0f       	add	r24, r18
    194c:	93 1f       	adc	r25, r19
    194e:	b8 01       	movw	r22, r16
    1950:	8f 5b       	subi	r24, 0xBF	; 191
    1952:	92 4f       	sbci	r25, 0xF2	; 242
    1954:	bf d9       	rcall	.-3202   	; 0xcd4 <vListInsertEnd>
    1956:	e0 91 65 0d 	lds	r30, 0x0D65
    195a:	f0 91 66 0d 	lds	r31, 0x0D66
    195e:	9e 89       	ldd	r25, Y+22	; 0x16
    1960:	86 89       	ldd	r24, Z+22	; 0x16
    1962:	98 17       	cp	r25, r24
    1964:	08 f0       	brcs	.+2      	; 0x1968 <xTaskIncrementTick+0x114>
    1966:	b4 cf       	rjmp	.-152    	; 0x18d0 <xTaskIncrementTick+0x7c>
    1968:	b4 cf       	rjmp	.-152    	; 0x18d2 <xTaskIncrementTick+0x7e>
    196a:	d1 2c       	mov	r13, r1
    196c:	e0 91 65 0d 	lds	r30, 0x0D65
    1970:	f0 91 66 0d 	lds	r31, 0x0D66
    1974:	86 89       	ldd	r24, Z+22	; 0x16
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	fc 01       	movw	r30, r24
    197a:	ee 0f       	add	r30, r30
    197c:	ff 1f       	adc	r31, r31
    197e:	ee 0f       	add	r30, r30
    1980:	ff 1f       	adc	r31, r31
    1982:	ee 0f       	add	r30, r30
    1984:	ff 1f       	adc	r31, r31
    1986:	8e 0f       	add	r24, r30
    1988:	9f 1f       	adc	r25, r31
    198a:	fc 01       	movw	r30, r24
    198c:	ef 5b       	subi	r30, 0xBF	; 191
    198e:	f2 4f       	sbci	r31, 0xF2	; 242
    1990:	80 81       	ld	r24, Z
    1992:	82 30       	cpi	r24, 0x02	; 2
    1994:	40 f4       	brcc	.+16     	; 0x19a6 <xTaskIncrementTick+0x152>
    1996:	09 c0       	rjmp	.+18     	; 0x19aa <xTaskIncrementTick+0x156>
    1998:	80 91 12 0d 	lds	r24, 0x0D12
    199c:	8f 5f       	subi	r24, 0xFF	; 255
    199e:	80 93 12 0d 	sts	0x0D12, r24
    19a2:	d1 2c       	mov	r13, r1
    19a4:	02 c0       	rjmp	.+4      	; 0x19aa <xTaskIncrementTick+0x156>
    19a6:	dd 24       	eor	r13, r13
    19a8:	d3 94       	inc	r13
    19aa:	80 91 11 0d 	lds	r24, 0x0D11
    19ae:	88 23       	and	r24, r24
    19b0:	11 f0       	breq	.+4      	; 0x19b6 <xTaskIncrementTick+0x162>
    19b2:	dd 24       	eor	r13, r13
    19b4:	d3 94       	inc	r13
    19b6:	8d 2d       	mov	r24, r13
    19b8:	df 91       	pop	r29
    19ba:	cf 91       	pop	r28
    19bc:	1f 91       	pop	r17
    19be:	0f 91       	pop	r16
    19c0:	ff 90       	pop	r15
    19c2:	ef 90       	pop	r14
    19c4:	df 90       	pop	r13
    19c6:	cf 90       	pop	r12
    19c8:	08 95       	ret

000019ca <xTaskResumeAll>:
    19ca:	df 92       	push	r13
    19cc:	ef 92       	push	r14
    19ce:	ff 92       	push	r15
    19d0:	0f 93       	push	r16
    19d2:	1f 93       	push	r17
    19d4:	cf 93       	push	r28
    19d6:	df 93       	push	r29
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	f8 94       	cli
    19dc:	0f 92       	push	r0
    19de:	80 91 0e 0d 	lds	r24, 0x0D0E
    19e2:	81 50       	subi	r24, 0x01	; 1
    19e4:	80 93 0e 0d 	sts	0x0D0E, r24
    19e8:	80 91 0e 0d 	lds	r24, 0x0D0E
    19ec:	81 11       	cpse	r24, r1
    19ee:	5c c0       	rjmp	.+184    	; 0x1aa8 <xTaskResumeAll+0xde>
    19f0:	80 91 17 0d 	lds	r24, 0x0D17
    19f4:	88 23       	and	r24, r24
    19f6:	09 f4       	brne	.+2      	; 0x19fa <xTaskResumeAll+0x30>
    19f8:	59 c0       	rjmp	.+178    	; 0x1aac <xTaskResumeAll+0xe2>
    19fa:	0f 2e       	mov	r0, r31
    19fc:	f2 e2       	ldi	r31, 0x22	; 34
    19fe:	ef 2e       	mov	r14, r31
    1a00:	fd e0       	ldi	r31, 0x0D	; 13
    1a02:	ff 2e       	mov	r15, r31
    1a04:	f0 2d       	mov	r31, r0
    1a06:	dd 24       	eor	r13, r13
    1a08:	d3 94       	inc	r13
    1a0a:	2d c0       	rjmp	.+90     	; 0x1a66 <xTaskResumeAll+0x9c>
    1a0c:	e0 91 27 0d 	lds	r30, 0x0D27
    1a10:	f0 91 28 0d 	lds	r31, 0x0D28
    1a14:	c6 81       	ldd	r28, Z+6	; 0x06
    1a16:	d7 81       	ldd	r29, Z+7	; 0x07
    1a18:	ce 01       	movw	r24, r28
    1a1a:	0c 96       	adiw	r24, 0x0c	; 12
    1a1c:	ad d9       	rcall	.-3238   	; 0xd78 <uxListRemove>
    1a1e:	8e 01       	movw	r16, r28
    1a20:	0e 5f       	subi	r16, 0xFE	; 254
    1a22:	1f 4f       	sbci	r17, 0xFF	; 255
    1a24:	c8 01       	movw	r24, r16
    1a26:	a8 d9       	rcall	.-3248   	; 0xd78 <uxListRemove>
    1a28:	8e 89       	ldd	r24, Y+22	; 0x16
    1a2a:	90 91 14 0d 	lds	r25, 0x0D14
    1a2e:	98 17       	cp	r25, r24
    1a30:	10 f4       	brcc	.+4      	; 0x1a36 <xTaskResumeAll+0x6c>
    1a32:	80 93 14 0d 	sts	0x0D14, r24
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	9c 01       	movw	r18, r24
    1a3a:	22 0f       	add	r18, r18
    1a3c:	33 1f       	adc	r19, r19
    1a3e:	22 0f       	add	r18, r18
    1a40:	33 1f       	adc	r19, r19
    1a42:	22 0f       	add	r18, r18
    1a44:	33 1f       	adc	r19, r19
    1a46:	82 0f       	add	r24, r18
    1a48:	93 1f       	adc	r25, r19
    1a4a:	b8 01       	movw	r22, r16
    1a4c:	8f 5b       	subi	r24, 0xBF	; 191
    1a4e:	92 4f       	sbci	r25, 0xF2	; 242
    1a50:	41 d9       	rcall	.-3454   	; 0xcd4 <vListInsertEnd>
    1a52:	e0 91 65 0d 	lds	r30, 0x0D65
    1a56:	f0 91 66 0d 	lds	r31, 0x0D66
    1a5a:	9e 89       	ldd	r25, Y+22	; 0x16
    1a5c:	86 89       	ldd	r24, Z+22	; 0x16
    1a5e:	98 17       	cp	r25, r24
    1a60:	10 f0       	brcs	.+4      	; 0x1a66 <xTaskResumeAll+0x9c>
    1a62:	d0 92 11 0d 	sts	0x0D11, r13
    1a66:	f7 01       	movw	r30, r14
    1a68:	80 81       	ld	r24, Z
    1a6a:	81 11       	cpse	r24, r1
    1a6c:	cf cf       	rjmp	.-98     	; 0x1a0c <xTaskResumeAll+0x42>
    1a6e:	80 91 12 0d 	lds	r24, 0x0D12
    1a72:	88 23       	and	r24, r24
    1a74:	91 f0       	breq	.+36     	; 0x1a9a <xTaskResumeAll+0xd0>
    1a76:	80 91 12 0d 	lds	r24, 0x0D12
    1a7a:	88 23       	and	r24, r24
    1a7c:	71 f0       	breq	.+28     	; 0x1a9a <xTaskResumeAll+0xd0>
    1a7e:	c1 e0       	ldi	r28, 0x01	; 1
    1a80:	e9 de       	rcall	.-558    	; 0x1854 <xTaskIncrementTick>
    1a82:	81 11       	cpse	r24, r1
    1a84:	c0 93 11 0d 	sts	0x0D11, r28
    1a88:	80 91 12 0d 	lds	r24, 0x0D12
    1a8c:	81 50       	subi	r24, 0x01	; 1
    1a8e:	80 93 12 0d 	sts	0x0D12, r24
    1a92:	80 91 12 0d 	lds	r24, 0x0D12
    1a96:	81 11       	cpse	r24, r1
    1a98:	f3 cf       	rjmp	.-26     	; 0x1a80 <xTaskResumeAll+0xb6>
    1a9a:	80 91 11 0d 	lds	r24, 0x0D11
    1a9e:	81 30       	cpi	r24, 0x01	; 1
    1aa0:	39 f4       	brne	.+14     	; 0x1ab0 <xTaskResumeAll+0xe6>
    1aa2:	48 da       	rcall	.-2928   	; 0xf34 <vPortYield>
    1aa4:	81 e0       	ldi	r24, 0x01	; 1
    1aa6:	05 c0       	rjmp	.+10     	; 0x1ab2 <xTaskResumeAll+0xe8>
    1aa8:	80 e0       	ldi	r24, 0x00	; 0
    1aaa:	03 c0       	rjmp	.+6      	; 0x1ab2 <xTaskResumeAll+0xe8>
    1aac:	80 e0       	ldi	r24, 0x00	; 0
    1aae:	01 c0       	rjmp	.+2      	; 0x1ab2 <xTaskResumeAll+0xe8>
    1ab0:	80 e0       	ldi	r24, 0x00	; 0
    1ab2:	0f 90       	pop	r0
    1ab4:	0f be       	out	0x3f, r0	; 63
    1ab6:	df 91       	pop	r29
    1ab8:	cf 91       	pop	r28
    1aba:	1f 91       	pop	r17
    1abc:	0f 91       	pop	r16
    1abe:	ff 90       	pop	r15
    1ac0:	ef 90       	pop	r14
    1ac2:	df 90       	pop	r13
    1ac4:	08 95       	ret

00001ac6 <vTaskDelay>:
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
    1aca:	ec 01       	movw	r28, r24
    1acc:	00 97       	sbiw	r24, 0x00	; 0
    1ace:	91 f0       	breq	.+36     	; 0x1af4 <vTaskDelay+0x2e>
    1ad0:	bb de       	rcall	.-650    	; 0x1848 <vTaskSuspendAll>
    1ad2:	80 91 15 0d 	lds	r24, 0x0D15
    1ad6:	90 91 16 0d 	lds	r25, 0x0D16
    1ada:	c8 0f       	add	r28, r24
    1adc:	d9 1f       	adc	r29, r25
    1ade:	80 91 65 0d 	lds	r24, 0x0D65
    1ae2:	90 91 66 0d 	lds	r25, 0x0D66
    1ae6:	02 96       	adiw	r24, 0x02	; 2
    1ae8:	47 d9       	rcall	.-3442   	; 0xd78 <uxListRemove>
    1aea:	ce 01       	movw	r24, r28
    1aec:	56 dd       	rcall	.-1364   	; 0x159a <prvAddCurrentTaskToDelayedList>
    1aee:	6d df       	rcall	.-294    	; 0x19ca <xTaskResumeAll>
    1af0:	81 11       	cpse	r24, r1
    1af2:	01 c0       	rjmp	.+2      	; 0x1af6 <vTaskDelay+0x30>
    1af4:	1f da       	rcall	.-3010   	; 0xf34 <vPortYield>
    1af6:	df 91       	pop	r29
    1af8:	cf 91       	pop	r28
    1afa:	08 95       	ret

00001afc <vTaskSwitchContext>:
    1afc:	80 91 0e 0d 	lds	r24, 0x0D0E
    1b00:	88 23       	and	r24, r24
    1b02:	21 f0       	breq	.+8      	; 0x1b0c <vTaskSwitchContext+0x10>
    1b04:	81 e0       	ldi	r24, 0x01	; 1
    1b06:	80 93 11 0d 	sts	0x0D11, r24
    1b0a:	08 95       	ret
    1b0c:	10 92 11 0d 	sts	0x0D11, r1
    1b10:	a0 91 65 0d 	lds	r26, 0x0D65
    1b14:	b0 91 66 0d 	lds	r27, 0x0D66
    1b18:	e0 91 65 0d 	lds	r30, 0x0D65
    1b1c:	f0 91 66 0d 	lds	r31, 0x0D66
    1b20:	2d 91       	ld	r18, X+
    1b22:	3c 91       	ld	r19, X
    1b24:	87 89       	ldd	r24, Z+23	; 0x17
    1b26:	90 8d       	ldd	r25, Z+24	; 0x18
    1b28:	82 17       	cp	r24, r18
    1b2a:	93 07       	cpc	r25, r19
    1b2c:	58 f0       	brcs	.+22     	; 0x1b44 <vTaskSwitchContext+0x48>
    1b2e:	60 91 65 0d 	lds	r22, 0x0D65
    1b32:	70 91 66 0d 	lds	r23, 0x0D66
    1b36:	80 91 65 0d 	lds	r24, 0x0D65
    1b3a:	90 91 66 0d 	lds	r25, 0x0D66
    1b3e:	67 5e       	subi	r22, 0xE7	; 231
    1b40:	7f 4f       	sbci	r23, 0xFF	; 255
    1b42:	56 d2       	rcall	.+1196   	; 0x1ff0 <vApplicationStackOverflowHook>
    1b44:	80 91 14 0d 	lds	r24, 0x0D14
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	ee 0f       	add	r30, r30
    1b4e:	ff 1f       	adc	r31, r31
    1b50:	ee 0f       	add	r30, r30
    1b52:	ff 1f       	adc	r31, r31
    1b54:	ee 0f       	add	r30, r30
    1b56:	ff 1f       	adc	r31, r31
    1b58:	8e 0f       	add	r24, r30
    1b5a:	9f 1f       	adc	r25, r31
    1b5c:	fc 01       	movw	r30, r24
    1b5e:	ef 5b       	subi	r30, 0xBF	; 191
    1b60:	f2 4f       	sbci	r31, 0xF2	; 242
    1b62:	80 81       	ld	r24, Z
    1b64:	81 11       	cpse	r24, r1
    1b66:	17 c0       	rjmp	.+46     	; 0x1b96 <vTaskSwitchContext+0x9a>
    1b68:	80 91 14 0d 	lds	r24, 0x0D14
    1b6c:	81 50       	subi	r24, 0x01	; 1
    1b6e:	80 93 14 0d 	sts	0x0D14, r24
    1b72:	80 91 14 0d 	lds	r24, 0x0D14
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	fc 01       	movw	r30, r24
    1b7a:	ee 0f       	add	r30, r30
    1b7c:	ff 1f       	adc	r31, r31
    1b7e:	ee 0f       	add	r30, r30
    1b80:	ff 1f       	adc	r31, r31
    1b82:	ee 0f       	add	r30, r30
    1b84:	ff 1f       	adc	r31, r31
    1b86:	8e 0f       	add	r24, r30
    1b88:	9f 1f       	adc	r25, r31
    1b8a:	fc 01       	movw	r30, r24
    1b8c:	ef 5b       	subi	r30, 0xBF	; 191
    1b8e:	f2 4f       	sbci	r31, 0xF2	; 242
    1b90:	80 81       	ld	r24, Z
    1b92:	88 23       	and	r24, r24
    1b94:	49 f3       	breq	.-46     	; 0x1b68 <vTaskSwitchContext+0x6c>
    1b96:	e0 91 14 0d 	lds	r30, 0x0D14
    1b9a:	f0 e0       	ldi	r31, 0x00	; 0
    1b9c:	cf 01       	movw	r24, r30
    1b9e:	88 0f       	add	r24, r24
    1ba0:	99 1f       	adc	r25, r25
    1ba2:	88 0f       	add	r24, r24
    1ba4:	99 1f       	adc	r25, r25
    1ba6:	88 0f       	add	r24, r24
    1ba8:	99 1f       	adc	r25, r25
    1baa:	e8 0f       	add	r30, r24
    1bac:	f9 1f       	adc	r31, r25
    1bae:	ef 5b       	subi	r30, 0xBF	; 191
    1bb0:	f2 4f       	sbci	r31, 0xF2	; 242
    1bb2:	a1 81       	ldd	r26, Z+1	; 0x01
    1bb4:	b2 81       	ldd	r27, Z+2	; 0x02
    1bb6:	12 96       	adiw	r26, 0x02	; 2
    1bb8:	0d 90       	ld	r0, X+
    1bba:	bc 91       	ld	r27, X
    1bbc:	a0 2d       	mov	r26, r0
    1bbe:	b2 83       	std	Z+2, r27	; 0x02
    1bc0:	a1 83       	std	Z+1, r26	; 0x01
    1bc2:	cf 01       	movw	r24, r30
    1bc4:	03 96       	adiw	r24, 0x03	; 3
    1bc6:	a8 17       	cp	r26, r24
    1bc8:	b9 07       	cpc	r27, r25
    1bca:	31 f4       	brne	.+12     	; 0x1bd8 <vTaskSwitchContext+0xdc>
    1bcc:	12 96       	adiw	r26, 0x02	; 2
    1bce:	8d 91       	ld	r24, X+
    1bd0:	9c 91       	ld	r25, X
    1bd2:	13 97       	sbiw	r26, 0x03	; 3
    1bd4:	92 83       	std	Z+2, r25	; 0x02
    1bd6:	81 83       	std	Z+1, r24	; 0x01
    1bd8:	01 80       	ldd	r0, Z+1	; 0x01
    1bda:	f2 81       	ldd	r31, Z+2	; 0x02
    1bdc:	e0 2d       	mov	r30, r0
    1bde:	86 81       	ldd	r24, Z+6	; 0x06
    1be0:	97 81       	ldd	r25, Z+7	; 0x07
    1be2:	90 93 66 0d 	sts	0x0D66, r25
    1be6:	80 93 65 0d 	sts	0x0D65, r24
    1bea:	08 95       	ret

00001bec <vTaskPlaceOnEventList>:
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	eb 01       	movw	r28, r22
    1bf2:	60 91 65 0d 	lds	r22, 0x0D65
    1bf6:	70 91 66 0d 	lds	r23, 0x0D66
    1bfa:	64 5f       	subi	r22, 0xF4	; 244
    1bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfe:	8b d8       	rcall	.-3818   	; 0xd16 <vListInsert>
    1c00:	80 91 65 0d 	lds	r24, 0x0D65
    1c04:	90 91 66 0d 	lds	r25, 0x0D66
    1c08:	02 96       	adiw	r24, 0x02	; 2
    1c0a:	b6 d8       	rcall	.-3732   	; 0xd78 <uxListRemove>
    1c0c:	80 91 15 0d 	lds	r24, 0x0D15
    1c10:	90 91 16 0d 	lds	r25, 0x0D16
    1c14:	8c 0f       	add	r24, r28
    1c16:	9d 1f       	adc	r25, r29
    1c18:	c0 dc       	rcall	.-1664   	; 0x159a <prvAddCurrentTaskToDelayedList>
    1c1a:	df 91       	pop	r29
    1c1c:	cf 91       	pop	r28
    1c1e:	08 95       	ret

00001c20 <xTaskRemoveFromEventList>:
    1c20:	0f 93       	push	r16
    1c22:	1f 93       	push	r17
    1c24:	cf 93       	push	r28
    1c26:	df 93       	push	r29
    1c28:	dc 01       	movw	r26, r24
    1c2a:	15 96       	adiw	r26, 0x05	; 5
    1c2c:	ed 91       	ld	r30, X+
    1c2e:	fc 91       	ld	r31, X
    1c30:	16 97       	sbiw	r26, 0x06	; 6
    1c32:	c6 81       	ldd	r28, Z+6	; 0x06
    1c34:	d7 81       	ldd	r29, Z+7	; 0x07
    1c36:	8e 01       	movw	r16, r28
    1c38:	04 5f       	subi	r16, 0xF4	; 244
    1c3a:	1f 4f       	sbci	r17, 0xFF	; 255
    1c3c:	c8 01       	movw	r24, r16
    1c3e:	9c d8       	rcall	.-3784   	; 0xd78 <uxListRemove>
    1c40:	80 91 0e 0d 	lds	r24, 0x0D0E
    1c44:	81 11       	cpse	r24, r1
    1c46:	1a c0       	rjmp	.+52     	; 0x1c7c <xTaskRemoveFromEventList+0x5c>
    1c48:	0a 50       	subi	r16, 0x0A	; 10
    1c4a:	11 09       	sbc	r17, r1
    1c4c:	c8 01       	movw	r24, r16
    1c4e:	94 d8       	rcall	.-3800   	; 0xd78 <uxListRemove>
    1c50:	8e 89       	ldd	r24, Y+22	; 0x16
    1c52:	90 91 14 0d 	lds	r25, 0x0D14
    1c56:	98 17       	cp	r25, r24
    1c58:	10 f4       	brcc	.+4      	; 0x1c5e <xTaskRemoveFromEventList+0x3e>
    1c5a:	80 93 14 0d 	sts	0x0D14, r24
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	9c 01       	movw	r18, r24
    1c62:	22 0f       	add	r18, r18
    1c64:	33 1f       	adc	r19, r19
    1c66:	22 0f       	add	r18, r18
    1c68:	33 1f       	adc	r19, r19
    1c6a:	22 0f       	add	r18, r18
    1c6c:	33 1f       	adc	r19, r19
    1c6e:	82 0f       	add	r24, r18
    1c70:	93 1f       	adc	r25, r19
    1c72:	b8 01       	movw	r22, r16
    1c74:	8f 5b       	subi	r24, 0xBF	; 191
    1c76:	92 4f       	sbci	r25, 0xF2	; 242
    1c78:	2d d8       	rcall	.-4006   	; 0xcd4 <vListInsertEnd>
    1c7a:	04 c0       	rjmp	.+8      	; 0x1c84 <xTaskRemoveFromEventList+0x64>
    1c7c:	b8 01       	movw	r22, r16
    1c7e:	82 e2       	ldi	r24, 0x22	; 34
    1c80:	9d e0       	ldi	r25, 0x0D	; 13
    1c82:	28 d8       	rcall	.-4016   	; 0xcd4 <vListInsertEnd>
    1c84:	e0 91 65 0d 	lds	r30, 0x0D65
    1c88:	f0 91 66 0d 	lds	r31, 0x0D66
    1c8c:	9e 89       	ldd	r25, Y+22	; 0x16
    1c8e:	86 89       	ldd	r24, Z+22	; 0x16
    1c90:	89 17       	cp	r24, r25
    1c92:	20 f4       	brcc	.+8      	; 0x1c9c <xTaskRemoveFromEventList+0x7c>
    1c94:	81 e0       	ldi	r24, 0x01	; 1
    1c96:	80 93 11 0d 	sts	0x0D11, r24
    1c9a:	01 c0       	rjmp	.+2      	; 0x1c9e <xTaskRemoveFromEventList+0x7e>
    1c9c:	80 e0       	ldi	r24, 0x00	; 0
    1c9e:	df 91       	pop	r29
    1ca0:	cf 91       	pop	r28
    1ca2:	1f 91       	pop	r17
    1ca4:	0f 91       	pop	r16
    1ca6:	08 95       	ret

00001ca8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1ca8:	20 91 10 0d 	lds	r18, 0x0D10
    1cac:	fc 01       	movw	r30, r24
    1cae:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1cb0:	20 91 15 0d 	lds	r18, 0x0D15
    1cb4:	30 91 16 0d 	lds	r19, 0x0D16
    1cb8:	32 83       	std	Z+2, r19	; 0x02
    1cba:	21 83       	std	Z+1, r18	; 0x01
    1cbc:	08 95       	ret

00001cbe <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1cc4:	20 91 15 0d 	lds	r18, 0x0D15
    1cc8:	30 91 16 0d 	lds	r19, 0x0D16
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1ccc:	40 91 10 0d 	lds	r20, 0x0D10
    1cd0:	dc 01       	movw	r26, r24
    1cd2:	5c 91       	ld	r21, X
    1cd4:	54 17       	cp	r21, r20
    1cd6:	39 f0       	breq	.+14     	; 0x1ce6 <xTaskCheckForTimeOut+0x28>
    1cd8:	11 96       	adiw	r26, 0x01	; 1
    1cda:	4d 91       	ld	r20, X+
    1cdc:	5c 91       	ld	r21, X
    1cde:	12 97       	sbiw	r26, 0x02	; 2
    1ce0:	24 17       	cp	r18, r20
    1ce2:	35 07       	cpc	r19, r21
    1ce4:	c0 f4       	brcc	.+48     	; 0x1d16 <xTaskCheckForTimeOut+0x58>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    1ce6:	dc 01       	movw	r26, r24
    1ce8:	11 96       	adiw	r26, 0x01	; 1
    1cea:	ed 91       	ld	r30, X+
    1cec:	fc 91       	ld	r31, X
    1cee:	12 97       	sbiw	r26, 0x02	; 2
    1cf0:	db 01       	movw	r26, r22
    1cf2:	4d 91       	ld	r20, X+
    1cf4:	5c 91       	ld	r21, X
    1cf6:	d9 01       	movw	r26, r18
    1cf8:	ae 1b       	sub	r26, r30
    1cfa:	bf 0b       	sbc	r27, r31
    1cfc:	a4 17       	cp	r26, r20
    1cfe:	b5 07       	cpc	r27, r21
    1d00:	60 f4       	brcc	.+24     	; 0x1d1a <xTaskCheckForTimeOut+0x5c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1d02:	e2 1b       	sub	r30, r18
    1d04:	f3 0b       	sbc	r31, r19
    1d06:	4e 0f       	add	r20, r30
    1d08:	5f 1f       	adc	r21, r31
    1d0a:	fb 01       	movw	r30, r22
    1d0c:	51 83       	std	Z+1, r21	; 0x01
    1d0e:	40 83       	st	Z, r20
			vTaskSetTimeOutState( pxTimeOut );
    1d10:	cb df       	rcall	.-106    	; 0x1ca8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1d12:	80 e0       	ldi	r24, 0x00	; 0
    1d14:	03 c0       	rjmp	.+6      	; 0x1d1c <xTaskCheckForTimeOut+0x5e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1d16:	81 e0       	ldi	r24, 0x01	; 1
    1d18:	01 c0       	rjmp	.+2      	; 0x1d1c <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1d1c:	0f 90       	pop	r0
    1d1e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1d20:	08 95       	ret

00001d22 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1d22:	81 e0       	ldi	r24, 0x01	; 1
    1d24:	80 93 11 0d 	sts	0x0D11, r24
    1d28:	08 95       	ret

00001d2a <bt_status_call_back>:


uint8_t bt_initialised = 0;

void bt_status_call_back(uint8_t status) {
	if (status == DIALOG_OK_STOP) {
    1d2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d2c:	19 f4       	brne	.+6      	; 0x1d34 <bt_status_call_back+0xa>
		bt_initialised = 1;
    1d2e:	81 e0       	ldi	r24, 0x01	; 1
    1d30:	80 93 67 0d 	sts	0x0D67, r24
    1d34:	08 95       	ret

00001d36 <vjustATask>:

	/* Cycle for ever, one cycle each time the goal line is passed. */
	for( ;; )
	{
		// Wait for goal line is passed
		xSemaphoreTake(goal_line_semaphore, portMAX_DELAY);
    1d36:	20 e0       	ldi	r18, 0x00	; 0
    1d38:	4f ef       	ldi	r20, 0xFF	; 255
    1d3a:	5f ef       	ldi	r21, 0xFF	; 255
    1d3c:	60 e0       	ldi	r22, 0x00	; 0
    1d3e:	70 e0       	ldi	r23, 0x00	; 0
    1d40:	80 91 6a 0d 	lds	r24, 0x0D6A
    1d44:	90 91 6b 0d 	lds	r25, 0x0D6B
    1d48:	6d db       	rcall	.-2342   	; 0x1424 <xQueueGenericReceive>
    1d4a:	f5 cf       	rjmp	.-22     	; 0x1d36 <vjustATask>

00001d4c <bt_com_call_back>:
		} else if (status == DIALOG_ERROR_STOP) {
		// What to do??
	}
}

void bt_com_call_back(uint8_t byte) {
    1d4c:	ef 92       	push	r14
    1d4e:	ff 92       	push	r15
    1d50:	0f 93       	push	r16
    1d52:	1f 93       	push	r17
    1d54:	cf 93       	push	r28
    1d56:	df 93       	push	r29
    1d58:	cd b7       	in	r28, 0x3d	; 61
    1d5a:	de b7       	in	r29, 0x3e	; 62
    1d5c:	64 97       	sbiw	r28, 0x14	; 20
    1d5e:	0f b6       	in	r0, 0x3f	; 63
    1d60:	f8 94       	cli
    1d62:	de bf       	out	0x3e, r29	; 62
    1d64:	0f be       	out	0x3f, r0	; 63
    1d66:	cd bf       	out	0x3d, r28	; 61
	char buf[20];
	char buf2[20];
	
	if (bt_initialised) {
    1d68:	90 91 67 0d 	lds	r25, 0x0D67
    1d6c:	99 23       	and	r25, r25
    1d6e:	09 f4       	brne	.+2      	; 0x1d72 <bt_com_call_back+0x26>
    1d70:	c2 c0       	rjmp	.+388    	; 0x1ef6 <bt_com_call_back+0x1aa>
		switch (byte) {
    1d72:	90 e0       	ldi	r25, 0x00	; 0
    1d74:	fc 01       	movw	r30, r24
    1d76:	e1 54       	subi	r30, 0x41	; 65
    1d78:	f1 09       	sbc	r31, r1
    1d7a:	e7 32       	cpi	r30, 0x27	; 39
    1d7c:	f1 05       	cpc	r31, r1
    1d7e:	08 f0       	brcs	.+2      	; 0x1d82 <bt_com_call_back+0x36>
    1d80:	ba c0       	rjmp	.+372    	; 0x1ef6 <bt_com_call_back+0x1aa>
    1d82:	ea 59       	subi	r30, 0x9A	; 154
    1d84:	ff 4f       	sbci	r31, 0xFF	; 255
    1d86:	0f c5       	rjmp	.+2590   	; 0x27a6 <__tablejump2__>
			case 'a': {
				set_head_light(0);
    1d88:	80 e0       	ldi	r24, 0x00	; 0
    1d8a:	0e 94 6d 02 	call	0x4da	; 0x4da <set_head_light>
				break;
    1d8e:	b3 c0       	rjmp	.+358    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'A': {
				set_head_light(1);
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	0e 94 6d 02 	call	0x4da	; 0x4da <set_head_light>
				break;
    1d96:	af c0       	rjmp	.+350    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'b': {
				set_brake_light(0);
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	0e 94 73 02 	call	0x4e6	; 0x4e6 <set_brake_light>
				break;
    1d9e:	ab c0       	rjmp	.+342    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'B': {
				set_brake_light(1);
    1da0:	81 e0       	ldi	r24, 0x01	; 1
    1da2:	0e 94 73 02 	call	0x4e6	; 0x4e6 <set_brake_light>
				break;
    1da6:	a7 c0       	rjmp	.+334    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'c': {
				set_horn(0);
    1da8:	80 e0       	ldi	r24, 0x00	; 0
    1daa:	0e 94 67 02 	call	0x4ce	; 0x4ce <set_horn>
				break;
    1dae:	a3 c0       	rjmp	.+326    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'C': {
				set_horn(1);
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	0e 94 67 02 	call	0x4ce	; 0x4ce <set_horn>
				break;
    1db6:	9f c0       	rjmp	.+318    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'd': {
				set_motor_speed(0);
    1db8:	80 e0       	ldi	r24, 0x00	; 0
    1dba:	0e 94 79 02 	call	0x4f2	; 0x4f2 <set_motor_speed>
				break;
    1dbe:	9b c0       	rjmp	.+310    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'D': {
				set_motor_speed(75);
    1dc0:	8b e4       	ldi	r24, 0x4B	; 75
    1dc2:	0e 94 79 02 	call	0x4f2	; 0x4f2 <set_motor_speed>
				break;
    1dc6:	97 c0       	rjmp	.+302    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			
			case 'e': {
				set_brake(0);
    1dc8:	80 e0       	ldi	r24, 0x00	; 0
    1dca:	0e 94 46 03 	call	0x68c	; 0x68c <set_brake>
				break;
    1dce:	93 c0       	rjmp	.+294    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'E': {
				set_brake(100);
    1dd0:	84 e6       	ldi	r24, 0x64	; 100
    1dd2:	0e 94 46 03 	call	0x68c	; 0x68c <set_brake>
				break;
    1dd6:	8f c0       	rjmp	.+286    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'F': {
				uint16_t raw_x = get_raw_x_accel();
    1dd8:	0e 94 69 03 	call	0x6d2	; 0x6d2 <get_raw_x_accel>
    1ddc:	18 2f       	mov	r17, r24
    1dde:	09 2f       	mov	r16, r25
				uint16_t raw_y = get_raw_y_accel();
    1de0:	0e 94 6e 03 	call	0x6dc	; 0x6dc <get_raw_y_accel>
    1de4:	f8 2e       	mov	r15, r24
    1de6:	e9 2e       	mov	r14, r25
				uint16_t raw_z = get_raw_z_accel();
    1de8:	0e 94 73 03 	call	0x6e6	; 0x6e6 <get_raw_z_accel>
				sprintf(buf, "%4d %4d %4d", raw_x, raw_y, raw_z);
    1dec:	9f 93       	push	r25
    1dee:	8f 93       	push	r24
    1df0:	ef 92       	push	r14
    1df2:	ff 92       	push	r15
    1df4:	0f 93       	push	r16
    1df6:	1f 93       	push	r17
    1df8:	8b e8       	ldi	r24, 0x8B	; 139
    1dfa:	92 e0       	ldi	r25, 0x02	; 2
    1dfc:	9f 93       	push	r25
    1dfe:	8f 93       	push	r24
    1e00:	8e 01       	movw	r16, r28
    1e02:	0f 5f       	subi	r16, 0xFF	; 255
    1e04:	1f 4f       	sbci	r17, 0xFF	; 255
    1e06:	1f 93       	push	r17
    1e08:	0f 93       	push	r16
    1e0a:	12 d6       	rcall	.+3108   	; 0x2a30 <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    1e0c:	f8 01       	movw	r30, r16
    1e0e:	01 90       	ld	r0, Z+
    1e10:	00 20       	and	r0, r0
    1e12:	e9 f7       	brne	.-6      	; 0x1e0e <bt_com_call_back+0xc2>
    1e14:	31 97       	sbiw	r30, 0x01	; 1
    1e16:	bf 01       	movw	r22, r30
    1e18:	60 1b       	sub	r22, r16
    1e1a:	71 0b       	sbc	r23, r17
    1e1c:	c8 01       	movw	r24, r16
    1e1e:	0e 94 88 03 	call	0x710	; 0x710 <bt_send_bytes>
				break;
    1e22:	0f b6       	in	r0, 0x3f	; 63
    1e24:	f8 94       	cli
    1e26:	de bf       	out	0x3e, r29	; 62
    1e28:	0f be       	out	0x3f, r0	; 63
    1e2a:	cd bf       	out	0x3d, r28	; 61
    1e2c:	64 c0       	rjmp	.+200    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'f': {
				uint16_t raw_x = get_raw_x_rotation();
    1e2e:	0e 94 78 03 	call	0x6f0	; 0x6f0 <get_raw_x_rotation>
    1e32:	18 2f       	mov	r17, r24
    1e34:	09 2f       	mov	r16, r25
				uint16_t raw_y = get_raw_y_rotation();
    1e36:	0e 94 7d 03 	call	0x6fa	; 0x6fa <get_raw_y_rotation>
				sprintf(buf, "%4d %4d", raw_x, raw_y);
    1e3a:	9f 93       	push	r25
    1e3c:	8f 93       	push	r24
    1e3e:	0f 93       	push	r16
    1e40:	1f 93       	push	r17
    1e42:	8f e8       	ldi	r24, 0x8F	; 143
    1e44:	92 e0       	ldi	r25, 0x02	; 2
    1e46:	9f 93       	push	r25
    1e48:	8f 93       	push	r24
    1e4a:	8e 01       	movw	r16, r28
    1e4c:	0f 5f       	subi	r16, 0xFF	; 255
    1e4e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e50:	1f 93       	push	r17
    1e52:	0f 93       	push	r16
    1e54:	ed d5       	rcall	.+3034   	; 0x2a30 <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    1e56:	f8 01       	movw	r30, r16
    1e58:	01 90       	ld	r0, Z+
    1e5a:	00 20       	and	r0, r0
    1e5c:	e9 f7       	brne	.-6      	; 0x1e58 <bt_com_call_back+0x10c>
    1e5e:	31 97       	sbiw	r30, 0x01	; 1
    1e60:	bf 01       	movw	r22, r30
    1e62:	60 1b       	sub	r22, r16
    1e64:	71 0b       	sbc	r23, r17
    1e66:	c8 01       	movw	r24, r16
    1e68:	0e 94 88 03 	call	0x710	; 0x710 <bt_send_bytes>
				break;
    1e6c:	0f b6       	in	r0, 0x3f	; 63
    1e6e:	f8 94       	cli
    1e70:	de bf       	out	0x3e, r29	; 62
    1e72:	0f be       	out	0x3f, r0	; 63
    1e74:	cd bf       	out	0x3d, r28	; 61
    1e76:	3f c0       	rjmp	.+126    	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'G': {
				uint16_t raw_z = get_raw_z_accel();
    1e78:	0e 94 73 03 	call	0x6e6	; 0x6e6 <get_raw_z_accel>
				sprintf(buf, "raw-z:%4d", raw_z);
    1e7c:	9f 93       	push	r25
    1e7e:	8f 93       	push	r24
    1e80:	87 e9       	ldi	r24, 0x97	; 151
    1e82:	92 e0       	ldi	r25, 0x02	; 2
    1e84:	9f 93       	push	r25
    1e86:	8f 93       	push	r24
    1e88:	8e 01       	movw	r16, r28
    1e8a:	0f 5f       	subi	r16, 0xFF	; 255
    1e8c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e8e:	1f 93       	push	r17
    1e90:	0f 93       	push	r16
    1e92:	ce d5       	rcall	.+2972   	; 0x2a30 <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    1e94:	f8 01       	movw	r30, r16
    1e96:	01 90       	ld	r0, Z+
    1e98:	00 20       	and	r0, r0
    1e9a:	e9 f7       	brne	.-6      	; 0x1e96 <bt_com_call_back+0x14a>
    1e9c:	31 97       	sbiw	r30, 0x01	; 1
    1e9e:	bf 01       	movw	r22, r30
    1ea0:	60 1b       	sub	r22, r16
    1ea2:	71 0b       	sbc	r23, r17
    1ea4:	c8 01       	movw	r24, r16
    1ea6:	0e 94 88 03 	call	0x710	; 0x710 <bt_send_bytes>
				break;
    1eaa:	0f 90       	pop	r0
    1eac:	0f 90       	pop	r0
    1eae:	0f 90       	pop	r0
    1eb0:	0f 90       	pop	r0
    1eb2:	0f 90       	pop	r0
    1eb4:	0f 90       	pop	r0
    1eb6:	1f c0       	rjmp	.+62     	; 0x1ef6 <bt_com_call_back+0x1aa>
			}
			
			case 'g': {
				uint16_t raw_xr = get_raw_x_rotation();
    1eb8:	0e 94 78 03 	call	0x6f0	; 0x6f0 <get_raw_x_rotation>
				sprintf(buf, "raw-x:%4d", raw_xr);
    1ebc:	9f 93       	push	r25
    1ebe:	8f 93       	push	r24
    1ec0:	81 ea       	ldi	r24, 0xA1	; 161
    1ec2:	92 e0       	ldi	r25, 0x02	; 2
    1ec4:	9f 93       	push	r25
    1ec6:	8f 93       	push	r24
    1ec8:	8e 01       	movw	r16, r28
    1eca:	0f 5f       	subi	r16, 0xFF	; 255
    1ecc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ece:	1f 93       	push	r17
    1ed0:	0f 93       	push	r16
    1ed2:	ae d5       	rcall	.+2908   	; 0x2a30 <sprintf>
				bt_send_bytes((uint8_t *)buf, strlen(buf));
    1ed4:	f8 01       	movw	r30, r16
    1ed6:	01 90       	ld	r0, Z+
    1ed8:	00 20       	and	r0, r0
    1eda:	e9 f7       	brne	.-6      	; 0x1ed6 <bt_com_call_back+0x18a>
    1edc:	31 97       	sbiw	r30, 0x01	; 1
    1ede:	bf 01       	movw	r22, r30
    1ee0:	60 1b       	sub	r22, r16
    1ee2:	71 0b       	sbc	r23, r17
    1ee4:	c8 01       	movw	r24, r16
    1ee6:	0e 94 88 03 	call	0x710	; 0x710 <bt_send_bytes>
				break;
    1eea:	0f 90       	pop	r0
    1eec:	0f 90       	pop	r0
    1eee:	0f 90       	pop	r0
    1ef0:	0f 90       	pop	r0
    1ef2:	0f 90       	pop	r0
    1ef4:	0f 90       	pop	r0
			}
			default:;
		}
	}
}
    1ef6:	64 96       	adiw	r28, 0x14	; 20
    1ef8:	0f b6       	in	r0, 0x3f	; 63
    1efa:	f8 94       	cli
    1efc:	de bf       	out	0x3e, r29	; 62
    1efe:	0f be       	out	0x3f, r0	; 63
    1f00:	cd bf       	out	0x3d, r28	; 61
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	1f 91       	pop	r17
    1f08:	0f 91       	pop	r16
    1f0a:	ff 90       	pop	r15
    1f0c:	ef 90       	pop	r14
    1f0e:	08 95       	ret

00001f10 <vstartupTask>:
		// Wait for goal line is passed
		xSemaphoreTake(goal_line_semaphore, portMAX_DELAY);
	}
}

static void vstartupTask( void *pvParameters ) {
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
    1f14:	1f 92       	push	r1
    1f16:	cd b7       	in	r28, 0x3d	; 61
    1f18:	de b7       	in	r29, 0x3e	; 62
	/* The parameters are not used. */
	( void ) pvParameters;
	
	goal_line_semaphore = xSemaphoreCreateBinary();
    1f1a:	43 e0       	ldi	r20, 0x03	; 3
    1f1c:	60 e0       	ldi	r22, 0x00	; 0
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	fa d9       	rcall	.-3084   	; 0x1316 <xQueueGenericCreate>
    1f22:	90 93 6b 0d 	sts	0x0D6B, r25
    1f26:	80 93 6a 0d 	sts	0x0D6A, r24
	_xBT_received_chars_queue = xQueueCreate( _BT_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
    1f2a:	40 e0       	ldi	r20, 0x00	; 0
    1f2c:	61 e0       	ldi	r22, 0x01	; 1
    1f2e:	8e e1       	ldi	r24, 0x1E	; 30
    1f30:	f2 d9       	rcall	.-3100   	; 0x1316 <xQueueGenericCreate>
    1f32:	90 93 69 0d 	sts	0x0D69, r25
    1f36:	80 93 68 0d 	sts	0x0D68, r24
	
	if( goal_line_semaphore == NULL ) {
    1f3a:	80 91 6a 0d 	lds	r24, 0x0D6A
    1f3e:	90 91 6b 0d 	lds	r25, 0x0D6B
    1f42:	00 97       	sbiw	r24, 0x00	; 0
    1f44:	11 f0       	breq	.+4      	; 0x1f4a <vstartupTask+0x3a>
		/* There was insufficient OpenRTOS heap available for the semaphore to
		be created successfully. */
		// What to do here ?????????????????????????????????
		} else {
		set_goal_line_semaphore(goal_line_semaphore);
    1f46:	0e 94 a4 03 	call	0x748	; 0x748 <set_goal_line_semaphore>
	}
	
	// Initialize Bluetooth Module
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    1f4a:	88 ee       	ldi	r24, 0xE8	; 232
    1f4c:	93 e0       	ldi	r25, 0x03	; 3
    1f4e:	bb dd       	rcall	.-1162   	; 0x1ac6 <vTaskDelay>
	set_bt_reset(0);  // Disable reset line of Blue tooth module
    1f50:	80 e0       	ldi	r24, 0x00	; 0
    1f52:	0e 94 82 03 	call	0x704	; 0x704 <set_bt_reset>
	vTaskDelay( 1000/ portTICK_PERIOD_MS);
    1f56:	88 ee       	ldi	r24, 0xE8	; 232
    1f58:	93 e0       	ldi	r25, 0x03	; 3
    1f5a:	b5 dd       	rcall	.-1174   	; 0x1ac6 <vTaskDelay>
	init_bt_module(bt_status_call_back, _xBT_received_chars_queue);
    1f5c:	60 91 68 0d 	lds	r22, 0x0D68
    1f60:	70 91 69 0d 	lds	r23, 0x0D69
    1f64:	85 e9       	ldi	r24, 0x95	; 149
    1f66:	9e e0       	ldi	r25, 0x0E	; 14
    1f68:	0e 94 91 03 	call	0x722	; 0x722 <init_bt_module>
	
	xTaskCreate( vjustATask, "JustATask", configMINIMAL_STACK_SIZE, NULL, just_a_task_TASK_PRIORITY, NULL );
    1f6c:	a1 2c       	mov	r10, r1
    1f6e:	b1 2c       	mov	r11, r1
    1f70:	c1 2c       	mov	r12, r1
    1f72:	d1 2c       	mov	r13, r1
    1f74:	e1 2c       	mov	r14, r1
    1f76:	f1 2c       	mov	r15, r1
    1f78:	01 e0       	ldi	r16, 0x01	; 1
    1f7a:	20 e0       	ldi	r18, 0x00	; 0
    1f7c:	30 e0       	ldi	r19, 0x00	; 0
    1f7e:	49 eb       	ldi	r20, 0xB9	; 185
    1f80:	50 e0       	ldi	r21, 0x00	; 0
    1f82:	6b ea       	ldi	r22, 0xAB	; 171
    1f84:	72 e0       	ldi	r23, 0x02	; 2
    1f86:	8b e9       	ldi	r24, 0x9B	; 155
    1f88:	9e e0       	ldi	r25, 0x0E	; 14
    1f8a:	3c db       	rcall	.-2440   	; 0x1604 <xTaskGenericCreate>
	uint8_t _byte;
	
	for( ;; ) {
		xQueueReceive( _xBT_received_chars_queue, &_byte, portMAX_DELAY );
    1f8c:	20 e0       	ldi	r18, 0x00	; 0
    1f8e:	4f ef       	ldi	r20, 0xFF	; 255
    1f90:	5f ef       	ldi	r21, 0xFF	; 255
    1f92:	be 01       	movw	r22, r28
    1f94:	6f 5f       	subi	r22, 0xFF	; 255
    1f96:	7f 4f       	sbci	r23, 0xFF	; 255
    1f98:	80 91 68 0d 	lds	r24, 0x0D68
    1f9c:	90 91 69 0d 	lds	r25, 0x0D69
    1fa0:	41 da       	rcall	.-2942   	; 0x1424 <xQueueGenericReceive>
		bt_com_call_back(_byte);
    1fa2:	89 81       	ldd	r24, Y+1	; 0x01
    1fa4:	d3 de       	rcall	.-602    	; 0x1d4c <bt_com_call_back>
    1fa6:	f2 cf       	rjmp	.-28     	; 0x1f8c <vstartupTask+0x7c>

00001fa8 <main>:
	}
}

int main(void)
{
    1fa8:	af 92       	push	r10
    1faa:	bf 92       	push	r11
    1fac:	cf 92       	push	r12
    1fae:	df 92       	push	r13
    1fb0:	ef 92       	push	r14
    1fb2:	ff 92       	push	r15
    1fb4:	0f 93       	push	r16
	init_main_board();
    1fb6:	0e 94 9c 02 	call	0x538	; 0x538 <init_main_board>
	xTaskCreate( vstartupTask, "StartupTask", configMINIMAL_STACK_SIZE, NULL, startup_TASK_PRIORITY, NULL );
    1fba:	a1 2c       	mov	r10, r1
    1fbc:	b1 2c       	mov	r11, r1
    1fbe:	c1 2c       	mov	r12, r1
    1fc0:	d1 2c       	mov	r13, r1
    1fc2:	e1 2c       	mov	r14, r1
    1fc4:	f1 2c       	mov	r15, r1
    1fc6:	00 e0       	ldi	r16, 0x00	; 0
    1fc8:	20 e0       	ldi	r18, 0x00	; 0
    1fca:	30 e0       	ldi	r19, 0x00	; 0
    1fcc:	49 eb       	ldi	r20, 0xB9	; 185
    1fce:	50 e0       	ldi	r21, 0x00	; 0
    1fd0:	65 eb       	ldi	r22, 0xB5	; 181
    1fd2:	72 e0       	ldi	r23, 0x02	; 2
    1fd4:	88 e8       	ldi	r24, 0x88	; 136
    1fd6:	9f e0       	ldi	r25, 0x0F	; 15
    1fd8:	15 db       	rcall	.-2518   	; 0x1604 <xTaskGenericCreate>
	vTaskStartScheduler();
    1fda:	0d dc       	rcall	.-2022   	; 0x17f6 <vTaskStartScheduler>
}
    1fdc:	80 e0       	ldi	r24, 0x00	; 0
    1fde:	90 e0       	ldi	r25, 0x00	; 0
    1fe0:	0f 91       	pop	r16
    1fe2:	ff 90       	pop	r15
    1fe4:	ef 90       	pop	r14
    1fe6:	df 90       	pop	r13
    1fe8:	cf 90       	pop	r12
    1fea:	bf 90       	pop	r11
    1fec:	af 90       	pop	r10
    1fee:	08 95       	ret

00001ff0 <vApplicationStackOverflowHook>:


// Called is TASK Stack overflows
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ) {
	set_horn(1);
    1ff0:	81 e0       	ldi	r24, 0x01	; 1
    1ff2:	0c 94 67 02 	jmp	0x4ce	; 0x4ce <set_horn>
    1ff6:	08 95       	ret

00001ff8 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
    1ff8:	4f 92       	push	r4
    1ffa:	5f 92       	push	r5
    1ffc:	6f 92       	push	r6
    1ffe:	7f 92       	push	r7
    2000:	8f 92       	push	r8
    2002:	9f 92       	push	r9
    2004:	af 92       	push	r10
    2006:	bf 92       	push	r11
    2008:	cf 92       	push	r12
    200a:	df 92       	push	r13
    200c:	ff 92       	push	r15
    200e:	0f 93       	push	r16
    2010:	1f 93       	push	r17
    2012:	cf 93       	push	r28
    2014:	df 93       	push	r29
    2016:	cd b7       	in	r28, 0x3d	; 61
    2018:	de b7       	in	r29, 0x3e	; 62
    201a:	f8 2e       	mov	r15, r24
    201c:	2a 01       	movw	r4, r20
    201e:	3b 01       	movw	r6, r22
    2020:	88 e0       	ldi	r24, 0x08	; 8
    2022:	90 e0       	ldi	r25, 0x00	; 0
    2024:	d5 d3       	rcall	.+1962   	; 0x27d0 <malloc>
    2026:	8c 01       	movw	r16, r24
    2028:	8f 2d       	mov	r24, r15
    202a:	90 e0       	ldi	r25, 0x00	; 0
    202c:	88 0f       	add	r24, r24
    202e:	99 1f       	adc	r25, r25
    2030:	fc 01       	movw	r30, r24
    2032:	e4 59       	subi	r30, 0x94	; 148
    2034:	f2 4f       	sbci	r31, 0xF2	; 242
    2036:	11 83       	std	Z+1, r17	; 0x01
    2038:	00 83       	st	Z, r16
    203a:	fc 01       	movw	r30, r24
    203c:	e5 5b       	subi	r30, 0xB5	; 181
    203e:	fd 4f       	sbci	r31, 0xFD	; 253
    2040:	80 81       	ld	r24, Z
    2042:	91 81       	ldd	r25, Z+1	; 0x01
    2044:	d8 01       	movw	r26, r16
    2046:	11 96       	adiw	r26, 0x01	; 1
    2048:	9c 93       	st	X, r25
    204a:	8e 93       	st	-X, r24
    204c:	13 96       	adiw	r26, 0x03	; 3
    204e:	bc 92       	st	X, r11
    2050:	ae 92       	st	-X, r10
    2052:	12 97       	sbiw	r26, 0x02	; 2
    2054:	15 96       	adiw	r26, 0x05	; 5
    2056:	dc 92       	st	X, r13
    2058:	ce 92       	st	-X, r12
    205a:	14 97       	sbiw	r26, 0x04	; 4
    205c:	17 96       	adiw	r26, 0x07	; 7
    205e:	9c 92       	st	X, r9
    2060:	8e 92       	st	-X, r8
    2062:	16 97       	sbiw	r26, 0x06	; 6
    2064:	ff b6       	in	r15, 0x3f	; 63
    2066:	f8 94       	cli
    2068:	d8 01       	movw	r26, r16
    206a:	ed 91       	ld	r30, X+
    206c:	fc 91       	ld	r31, X
    206e:	11 97       	sbiw	r26, 0x01	; 1
    2070:	36 97       	sbiw	r30, 0x06	; 6
    2072:	80 81       	ld	r24, Z
    2074:	82 60       	ori	r24, 0x02	; 2
    2076:	80 83       	st	Z, r24
    2078:	cd 90       	ld	r12, X+
    207a:	dc 90       	ld	r13, X
    207c:	44 0c       	add	r4, r4
    207e:	55 1c       	adc	r5, r5
    2080:	66 1c       	adc	r6, r6
    2082:	77 1c       	adc	r7, r7
    2084:	44 0c       	add	r4, r4
    2086:	55 1c       	adc	r5, r5
    2088:	66 1c       	adc	r6, r6
    208a:	77 1c       	adc	r7, r7
    208c:	a3 01       	movw	r20, r6
    208e:	92 01       	movw	r18, r4
    2090:	22 0f       	add	r18, r18
    2092:	33 1f       	adc	r19, r19
    2094:	44 1f       	adc	r20, r20
    2096:	55 1f       	adc	r21, r21
    2098:	60 e0       	ldi	r22, 0x00	; 0
    209a:	74 e2       	ldi	r23, 0x24	; 36
    209c:	84 ef       	ldi	r24, 0xF4	; 244
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	44 d3       	rcall	.+1672   	; 0x272a <__udivmodsi4>
    20a2:	21 50       	subi	r18, 0x01	; 1
    20a4:	f6 01       	movw	r30, r12
    20a6:	32 97       	sbiw	r30, 0x02	; 2
    20a8:	20 83       	st	Z, r18
    20aa:	d8 01       	movw	r26, r16
    20ac:	ed 91       	ld	r30, X+
    20ae:	fc 91       	ld	r31, X
    20b0:	11 97       	sbiw	r26, 0x01	; 1
    20b2:	35 97       	sbiw	r30, 0x05	; 5
    20b4:	88 e9       	ldi	r24, 0x98	; 152
    20b6:	80 83       	st	Z, r24
    20b8:	ed 91       	ld	r30, X+
    20ba:	fc 91       	ld	r31, X
    20bc:	34 97       	sbiw	r30, 0x04	; 4
    20be:	86 e0       	ldi	r24, 0x06	; 6
    20c0:	80 83       	st	Z, r24
    20c2:	ff be       	out	0x3f, r15	; 63
    20c4:	c8 01       	movw	r24, r16
    20c6:	df 91       	pop	r29
    20c8:	cf 91       	pop	r28
    20ca:	1f 91       	pop	r17
    20cc:	0f 91       	pop	r16
    20ce:	ff 90       	pop	r15
    20d0:	df 90       	pop	r13
    20d2:	cf 90       	pop	r12
    20d4:	bf 90       	pop	r11
    20d6:	af 90       	pop	r10
    20d8:	9f 90       	pop	r9
    20da:	8f 90       	pop	r8
    20dc:	7f 90       	pop	r7
    20de:	6f 90       	pop	r6
    20e0:	5f 90       	pop	r5
    20e2:	4f 90       	pop	r4
    20e4:	08 95       	ret

000020e6 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
    20e6:	ef 92       	push	r14
    20e8:	ff 92       	push	r15
    20ea:	0f 93       	push	r16
    20ec:	1f 93       	push	r17
    20ee:	cf 93       	push	r28
    20f0:	df 93       	push	r29
    20f2:	8c 01       	movw	r16, r24
    20f4:	e4 2e       	mov	r14, r20
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    20f6:	dc 01       	movw	r26, r24
    20f8:	12 96       	adiw	r26, 0x02	; 2
    20fa:	ed 91       	ld	r30, X+
    20fc:	fc 91       	ld	r31, X
    20fe:	13 97       	sbiw	r26, 0x03	; 3
    2100:	30 97       	sbiw	r30, 0x00	; 0
    2102:	69 f0       	breq	.+26     	; 0x211e <serial_send_bytes+0x38>
    2104:	24 2f       	mov	r18, r20
    2106:	30 e0       	ldi	r19, 0x00	; 0
    2108:	42 89       	ldd	r20, Z+18	; 0x12
    210a:	80 e1       	ldi	r24, 0x10	; 16
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	84 1b       	sub	r24, r20
    2110:	91 09       	sbc	r25, r1
    2112:	82 17       	cp	r24, r18
    2114:	93 07       	cpc	r25, r19
    2116:	e4 f0       	brlt	.+56     	; 0x2150 <serial_send_bytes+0x6a>
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2118:	e1 10       	cpse	r14, r1
    211a:	05 c0       	rjmp	.+10     	; 0x2126 <serial_send_bytes+0x40>
    211c:	10 c0       	rjmp	.+32     	; 0x213e <serial_send_bytes+0x58>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    211e:	b1 e0       	ldi	r27, 0x01	; 1
    2120:	b4 17       	cp	r27, r20
    2122:	c0 f0       	brcs	.+48     	; 0x2154 <serial_send_bytes+0x6e>
    2124:	f9 cf       	rjmp	.-14     	; 0x2118 <serial_send_bytes+0x32>
    2126:	c6 2f       	mov	r28, r22
    2128:	d7 2f       	mov	r29, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    212a:	f1 2c       	mov	r15, r1
		buffer_put_item(handle->_tx_buf, buf[i]);
    212c:	69 91       	ld	r22, Y+
    212e:	f8 01       	movw	r30, r16
    2130:	82 81       	ldd	r24, Z+2	; 0x02
    2132:	93 81       	ldd	r25, Z+3	; 0x03
    2134:	0e 94 32 04 	call	0x864	; 0x864 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    2138:	f3 94       	inc	r15
    213a:	fe 10       	cpse	r15, r14
    213c:	f7 cf       	rjmp	.-18     	; 0x212c <serial_send_bytes+0x46>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
    213e:	d8 01       	movw	r26, r16
    2140:	ed 91       	ld	r30, X+
    2142:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
    2144:	35 97       	sbiw	r30, 0x05	; 5
    2146:	80 81       	ld	r24, Z
    2148:	80 62       	ori	r24, 0x20	; 32
    214a:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
    214c:	80 e0       	ldi	r24, 0x00	; 0
    214e:	03 c0       	rjmp	.+6      	; 0x2156 <serial_send_bytes+0x70>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
    2150:	82 e0       	ldi	r24, 0x02	; 2
    2152:	01 c0       	rjmp	.+2      	; 0x2156 <serial_send_bytes+0x70>
    2154:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	1f 91       	pop	r17
    215c:	0f 91       	pop	r16
    215e:	ff 90       	pop	r15
    2160:	ef 90       	pop	r14
    2162:	08 95       	ret

00002164 <__vector_25>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    2164:	1f 92       	push	r1
    2166:	0f 92       	push	r0
    2168:	0f b6       	in	r0, 0x3f	; 63
    216a:	0f 92       	push	r0
    216c:	11 24       	eor	r1, r1
    216e:	0b b6       	in	r0, 0x3b	; 59
    2170:	0f 92       	push	r0
    2172:	2f 93       	push	r18
    2174:	3f 93       	push	r19
    2176:	4f 93       	push	r20
    2178:	5f 93       	push	r21
    217a:	6f 93       	push	r22
    217c:	7f 93       	push	r23
    217e:	8f 93       	push	r24
    2180:	9f 93       	push	r25
    2182:	af 93       	push	r26
    2184:	bf 93       	push	r27
    2186:	cf 93       	push	r28
    2188:	ef 93       	push	r30
    218a:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    218c:	e0 91 6c 0d 	lds	r30, 0x0D6C
    2190:	f0 91 6d 0d 	lds	r31, 0x0D6D
    2194:	30 97       	sbiw	r30, 0x00	; 0
    2196:	a1 f0       	breq	.+40     	; 0x21c0 <__vector_25+0x5c>
		item = UDR0;
    2198:	c0 91 c6 00 	lds	r28, 0x00C6
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
    219c:	6c 2f       	mov	r22, r28
    219e:	84 81       	ldd	r24, Z+4	; 0x04
    21a0:	95 81       	ldd	r25, Z+5	; 0x05
    21a2:	0e 94 32 04 	call	0x864	; 0x864 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
    21a6:	80 91 6c 0d 	lds	r24, 0x0D6C
    21aa:	90 91 6d 0d 	lds	r25, 0x0D6D
    21ae:	dc 01       	movw	r26, r24
    21b0:	16 96       	adiw	r26, 0x06	; 6
    21b2:	ed 91       	ld	r30, X+
    21b4:	fc 91       	ld	r31, X
    21b6:	17 97       	sbiw	r26, 0x07	; 7
    21b8:	30 97       	sbiw	r30, 0x00	; 0
    21ba:	11 f0       	breq	.+4      	; 0x21c0 <__vector_25+0x5c>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
    21bc:	6c 2f       	mov	r22, r28
    21be:	19 95       	eicall
		}
	}
}
    21c0:	ff 91       	pop	r31
    21c2:	ef 91       	pop	r30
    21c4:	cf 91       	pop	r28
    21c6:	bf 91       	pop	r27
    21c8:	af 91       	pop	r26
    21ca:	9f 91       	pop	r25
    21cc:	8f 91       	pop	r24
    21ce:	7f 91       	pop	r23
    21d0:	6f 91       	pop	r22
    21d2:	5f 91       	pop	r21
    21d4:	4f 91       	pop	r20
    21d6:	3f 91       	pop	r19
    21d8:	2f 91       	pop	r18
    21da:	0f 90       	pop	r0
    21dc:	0b be       	out	0x3b, r0	; 59
    21de:	0f 90       	pop	r0
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	0f 90       	pop	r0
    21e4:	1f 90       	pop	r1
    21e6:	18 95       	reti

000021e8 <__vector_26>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
    21e8:	1f 92       	push	r1
    21ea:	0f 92       	push	r0
    21ec:	0f b6       	in	r0, 0x3f	; 63
    21ee:	0f 92       	push	r0
    21f0:	11 24       	eor	r1, r1
    21f2:	0b b6       	in	r0, 0x3b	; 59
    21f4:	0f 92       	push	r0
    21f6:	2f 93       	push	r18
    21f8:	3f 93       	push	r19
    21fa:	4f 93       	push	r20
    21fc:	5f 93       	push	r21
    21fe:	6f 93       	push	r22
    2200:	7f 93       	push	r23
    2202:	8f 93       	push	r24
    2204:	9f 93       	push	r25
    2206:	af 93       	push	r26
    2208:	bf 93       	push	r27
    220a:	ef 93       	push	r30
    220c:	ff 93       	push	r31
    220e:	cf 93       	push	r28
    2210:	df 93       	push	r29
    2212:	1f 92       	push	r1
    2214:	cd b7       	in	r28, 0x3d	; 61
    2216:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    2218:	e0 91 6c 0d 	lds	r30, 0x0D6C
    221c:	f0 91 6d 0d 	lds	r31, 0x0D6D
    2220:	30 97       	sbiw	r30, 0x00	; 0
    2222:	99 f0       	breq	.+38     	; 0x224a <__stack+0x4b>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    2224:	be 01       	movw	r22, r28
    2226:	6f 5f       	subi	r22, 0xFF	; 255
    2228:	7f 4f       	sbci	r23, 0xFF	; 255
    222a:	82 81       	ldd	r24, Z+2	; 0x02
    222c:	93 81       	ldd	r25, Z+3	; 0x03
    222e:	0e 94 1a 04 	call	0x834	; 0x834 <buffer_get_item>
    2232:	81 11       	cpse	r24, r1
    2234:	04 c0       	rjmp	.+8      	; 0x223e <__stack+0x3f>
			UDR0 = item;
    2236:	89 81       	ldd	r24, Y+1	; 0x01
    2238:	80 93 c6 00 	sts	0x00C6, r24
    223c:	0b c0       	rjmp	.+22     	; 0x2254 <__stack+0x55>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    223e:	e1 ec       	ldi	r30, 0xC1	; 193
    2240:	f0 e0       	ldi	r31, 0x00	; 0
    2242:	80 81       	ld	r24, Z
    2244:	8f 7d       	andi	r24, 0xDF	; 223
    2246:	80 83       	st	Z, r24
    2248:	05 c0       	rjmp	.+10     	; 0x2254 <__stack+0x55>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    224a:	e1 ec       	ldi	r30, 0xC1	; 193
    224c:	f0 e0       	ldi	r31, 0x00	; 0
    224e:	80 81       	ld	r24, Z
    2250:	8f 7d       	andi	r24, 0xDF	; 223
    2252:	80 83       	st	Z, r24
	}
}
    2254:	0f 90       	pop	r0
    2256:	df 91       	pop	r29
    2258:	cf 91       	pop	r28
    225a:	ff 91       	pop	r31
    225c:	ef 91       	pop	r30
    225e:	bf 91       	pop	r27
    2260:	af 91       	pop	r26
    2262:	9f 91       	pop	r25
    2264:	8f 91       	pop	r24
    2266:	7f 91       	pop	r23
    2268:	6f 91       	pop	r22
    226a:	5f 91       	pop	r21
    226c:	4f 91       	pop	r20
    226e:	3f 91       	pop	r19
    2270:	2f 91       	pop	r18
    2272:	0f 90       	pop	r0
    2274:	0b be       	out	0x3b, r0	; 59
    2276:	0f 90       	pop	r0
    2278:	0f be       	out	0x3f, r0	; 63
    227a:	0f 90       	pop	r0
    227c:	1f 90       	pop	r1
    227e:	18 95       	reti

00002280 <__vector_36>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    2280:	1f 92       	push	r1
    2282:	0f 92       	push	r0
    2284:	0f b6       	in	r0, 0x3f	; 63
    2286:	0f 92       	push	r0
    2288:	11 24       	eor	r1, r1
    228a:	0b b6       	in	r0, 0x3b	; 59
    228c:	0f 92       	push	r0
    228e:	2f 93       	push	r18
    2290:	3f 93       	push	r19
    2292:	4f 93       	push	r20
    2294:	5f 93       	push	r21
    2296:	6f 93       	push	r22
    2298:	7f 93       	push	r23
    229a:	8f 93       	push	r24
    229c:	9f 93       	push	r25
    229e:	af 93       	push	r26
    22a0:	bf 93       	push	r27
    22a2:	cf 93       	push	r28
    22a4:	ef 93       	push	r30
    22a6:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    22a8:	e0 91 6e 0d 	lds	r30, 0x0D6E
    22ac:	f0 91 6f 0d 	lds	r31, 0x0D6F
    22b0:	30 97       	sbiw	r30, 0x00	; 0
    22b2:	a1 f0       	breq	.+40     	; 0x22dc <__vector_36+0x5c>
		item = UDR1;
    22b4:	c0 91 ce 00 	lds	r28, 0x00CE
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    22b8:	6c 2f       	mov	r22, r28
    22ba:	84 81       	ldd	r24, Z+4	; 0x04
    22bc:	95 81       	ldd	r25, Z+5	; 0x05
    22be:	0e 94 32 04 	call	0x864	; 0x864 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    22c2:	80 91 6e 0d 	lds	r24, 0x0D6E
    22c6:	90 91 6f 0d 	lds	r25, 0x0D6F
    22ca:	dc 01       	movw	r26, r24
    22cc:	16 96       	adiw	r26, 0x06	; 6
    22ce:	ed 91       	ld	r30, X+
    22d0:	fc 91       	ld	r31, X
    22d2:	17 97       	sbiw	r26, 0x07	; 7
    22d4:	30 97       	sbiw	r30, 0x00	; 0
    22d6:	11 f0       	breq	.+4      	; 0x22dc <__vector_36+0x5c>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    22d8:	6c 2f       	mov	r22, r28
    22da:	19 95       	eicall
		}
	}
}
    22dc:	ff 91       	pop	r31
    22de:	ef 91       	pop	r30
    22e0:	cf 91       	pop	r28
    22e2:	bf 91       	pop	r27
    22e4:	af 91       	pop	r26
    22e6:	9f 91       	pop	r25
    22e8:	8f 91       	pop	r24
    22ea:	7f 91       	pop	r23
    22ec:	6f 91       	pop	r22
    22ee:	5f 91       	pop	r21
    22f0:	4f 91       	pop	r20
    22f2:	3f 91       	pop	r19
    22f4:	2f 91       	pop	r18
    22f6:	0f 90       	pop	r0
    22f8:	0b be       	out	0x3b, r0	; 59
    22fa:	0f 90       	pop	r0
    22fc:	0f be       	out	0x3f, r0	; 63
    22fe:	0f 90       	pop	r0
    2300:	1f 90       	pop	r1
    2302:	18 95       	reti

00002304 <__vector_37>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    2304:	1f 92       	push	r1
    2306:	0f 92       	push	r0
    2308:	0f b6       	in	r0, 0x3f	; 63
    230a:	0f 92       	push	r0
    230c:	11 24       	eor	r1, r1
    230e:	0b b6       	in	r0, 0x3b	; 59
    2310:	0f 92       	push	r0
    2312:	2f 93       	push	r18
    2314:	3f 93       	push	r19
    2316:	4f 93       	push	r20
    2318:	5f 93       	push	r21
    231a:	6f 93       	push	r22
    231c:	7f 93       	push	r23
    231e:	8f 93       	push	r24
    2320:	9f 93       	push	r25
    2322:	af 93       	push	r26
    2324:	bf 93       	push	r27
    2326:	ef 93       	push	r30
    2328:	ff 93       	push	r31
    232a:	cf 93       	push	r28
    232c:	df 93       	push	r29
    232e:	1f 92       	push	r1
    2330:	cd b7       	in	r28, 0x3d	; 61
    2332:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    2334:	e0 91 6e 0d 	lds	r30, 0x0D6E
    2338:	f0 91 6f 0d 	lds	r31, 0x0D6F
    233c:	30 97       	sbiw	r30, 0x00	; 0
    233e:	99 f0       	breq	.+38     	; 0x2366 <__vector_37+0x62>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    2340:	be 01       	movw	r22, r28
    2342:	6f 5f       	subi	r22, 0xFF	; 255
    2344:	7f 4f       	sbci	r23, 0xFF	; 255
    2346:	82 81       	ldd	r24, Z+2	; 0x02
    2348:	93 81       	ldd	r25, Z+3	; 0x03
    234a:	0e 94 1a 04 	call	0x834	; 0x834 <buffer_get_item>
    234e:	81 11       	cpse	r24, r1
    2350:	04 c0       	rjmp	.+8      	; 0x235a <__vector_37+0x56>
			UDR1 = item;
    2352:	89 81       	ldd	r24, Y+1	; 0x01
    2354:	80 93 ce 00 	sts	0x00CE, r24
    2358:	0b c0       	rjmp	.+22     	; 0x2370 <__vector_37+0x6c>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    235a:	e9 ec       	ldi	r30, 0xC9	; 201
    235c:	f0 e0       	ldi	r31, 0x00	; 0
    235e:	80 81       	ld	r24, Z
    2360:	8f 7d       	andi	r24, 0xDF	; 223
    2362:	80 83       	st	Z, r24
    2364:	05 c0       	rjmp	.+10     	; 0x2370 <__vector_37+0x6c>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    2366:	e9 ec       	ldi	r30, 0xC9	; 201
    2368:	f0 e0       	ldi	r31, 0x00	; 0
    236a:	80 81       	ld	r24, Z
    236c:	8f 7d       	andi	r24, 0xDF	; 223
    236e:	80 83       	st	Z, r24
	}
}
    2370:	0f 90       	pop	r0
    2372:	df 91       	pop	r29
    2374:	cf 91       	pop	r28
    2376:	ff 91       	pop	r31
    2378:	ef 91       	pop	r30
    237a:	bf 91       	pop	r27
    237c:	af 91       	pop	r26
    237e:	9f 91       	pop	r25
    2380:	8f 91       	pop	r24
    2382:	7f 91       	pop	r23
    2384:	6f 91       	pop	r22
    2386:	5f 91       	pop	r21
    2388:	4f 91       	pop	r20
    238a:	3f 91       	pop	r19
    238c:	2f 91       	pop	r18
    238e:	0f 90       	pop	r0
    2390:	0b be       	out	0x3b, r0	; 59
    2392:	0f 90       	pop	r0
    2394:	0f be       	out	0x3f, r0	; 63
    2396:	0f 90       	pop	r0
    2398:	1f 90       	pop	r1
    239a:	18 95       	reti

0000239c <_select_instance>:
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    239c:	e0 91 71 0d 	lds	r30, 0x0D71
    23a0:	f0 91 72 0d 	lds	r31, 0x0D72
    23a4:	30 97       	sbiw	r30, 0x00	; 0
    23a6:	01 f1       	breq	.+64     	; 0x23e8 <_select_instance+0x4c>
    23a8:	23 81       	ldd	r18, Z+3	; 0x03
    23aa:	21 30       	cpi	r18, 0x01	; 1
    23ac:	79 f4       	brne	.+30     	; 0x23cc <_select_instance+0x30>
    23ae:	a0 81       	ld	r26, Z
    23b0:	b1 81       	ldd	r27, Z+1	; 0x01
    23b2:	4c 91       	ld	r20, X
    23b4:	21 e0       	ldi	r18, 0x01	; 1
    23b6:	30 e0       	ldi	r19, 0x00	; 0
    23b8:	02 80       	ldd	r0, Z+2	; 0x02
    23ba:	02 c0       	rjmp	.+4      	; 0x23c0 <_select_instance+0x24>
    23bc:	22 0f       	add	r18, r18
    23be:	33 1f       	adc	r19, r19
    23c0:	0a 94       	dec	r0
    23c2:	e2 f7       	brpl	.-8      	; 0x23bc <_select_instance+0x20>
    23c4:	20 95       	com	r18
    23c6:	24 23       	and	r18, r20
    23c8:	2c 93       	st	X, r18
    23ca:	0e c0       	rjmp	.+28     	; 0x23e8 <_select_instance+0x4c>
    23cc:	a0 81       	ld	r26, Z
    23ce:	b1 81       	ldd	r27, Z+1	; 0x01
    23d0:	6c 91       	ld	r22, X
    23d2:	41 e0       	ldi	r20, 0x01	; 1
    23d4:	50 e0       	ldi	r21, 0x00	; 0
    23d6:	9a 01       	movw	r18, r20
    23d8:	02 80       	ldd	r0, Z+2	; 0x02
    23da:	02 c0       	rjmp	.+4      	; 0x23e0 <_select_instance+0x44>
    23dc:	22 0f       	add	r18, r18
    23de:	33 1f       	adc	r19, r19
    23e0:	0a 94       	dec	r0
    23e2:	e2 f7       	brpl	.-8      	; 0x23dc <_select_instance+0x40>
    23e4:	26 2b       	or	r18, r22
    23e6:	2c 93       	st	X, r18
    23e8:	90 93 72 0d 	sts	0x0D72, r25
    23ec:	80 93 71 0d 	sts	0x0D71, r24
    23f0:	00 97       	sbiw	r24, 0x00	; 0
    23f2:	69 f0       	breq	.+26     	; 0x240e <_select_instance+0x72>
    23f4:	10 92 73 0d 	sts	0x0D73, r1
    23f8:	2c b5       	in	r18, 0x2c	; 44
    23fa:	2f 73       	andi	r18, 0x3F	; 63
    23fc:	2c bd       	out	0x2c, r18	; 44
    23fe:	fc 01       	movw	r30, r24
    2400:	24 81       	ldd	r18, Z+4	; 0x04
    2402:	2c bd       	out	0x2c, r18	; 44
    2404:	85 81       	ldd	r24, Z+5	; 0x05
    2406:	8d bd       	out	0x2d, r24	; 45
    2408:	8c b5       	in	r24, 0x2c	; 44
    240a:	80 64       	ori	r24, 0x40	; 64
    240c:	8c bd       	out	0x2c, r24	; 44
    240e:	08 95       	ret

00002410 <spi_new_instance>:
    2410:	6f 92       	push	r6
    2412:	7f 92       	push	r7
    2414:	8f 92       	push	r8
    2416:	9f 92       	push	r9
    2418:	af 92       	push	r10
    241a:	bf 92       	push	r11
    241c:	cf 92       	push	r12
    241e:	df 92       	push	r13
    2420:	ef 92       	push	r14
    2422:	ff 92       	push	r15
    2424:	0f 93       	push	r16
    2426:	1f 93       	push	r17
    2428:	cf 93       	push	r28
    242a:	df 93       	push	r29
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	d8 2e       	mov	r13, r24
    2432:	f6 2e       	mov	r15, r22
    2434:	64 2e       	mov	r6, r20
    2436:	72 2e       	mov	r7, r18
    2438:	80 91 70 0d 	lds	r24, 0x0D70
    243c:	81 11       	cpse	r24, r1
    243e:	06 c0       	rjmp	.+12     	; 0x244c <spi_new_instance+0x3c>
    2440:	84 b1       	in	r24, 0x04	; 4
    2442:	87 60       	ori	r24, 0x07	; 7
    2444:	84 b9       	out	0x04, r24	; 4
    2446:	81 e0       	ldi	r24, 0x01	; 1
    2448:	80 93 70 0d 	sts	0x0D70, r24
    244c:	8c e0       	ldi	r24, 0x0C	; 12
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	bf d1       	rcall	.+894    	; 0x27d0 <malloc>
    2452:	fc 01       	movw	r30, r24
    2454:	00 83       	st	Z, r16
    2456:	11 83       	std	Z+1, r17	; 0x01
    2458:	e2 82       	std	Z+2, r14	; 0x02
    245a:	a0 2f       	mov	r26, r16
    245c:	b1 2f       	mov	r27, r17
    245e:	4e 91       	ld	r20, -X
    2460:	21 e0       	ldi	r18, 0x01	; 1
    2462:	30 e0       	ldi	r19, 0x00	; 0
    2464:	c9 01       	movw	r24, r18
    2466:	02 c0       	rjmp	.+4      	; 0x246c <spi_new_instance+0x5c>
    2468:	88 0f       	add	r24, r24
    246a:	99 1f       	adc	r25, r25
    246c:	ea 94       	dec	r14
    246e:	e2 f7       	brpl	.-8      	; 0x2468 <spi_new_instance+0x58>
    2470:	84 2b       	or	r24, r20
    2472:	8c 93       	st	X, r24
    2474:	c3 82       	std	Z+3, r12	; 0x03
    2476:	66 0c       	add	r6, r6
    2478:	66 0c       	add	r6, r6
    247a:	76 28       	or	r7, r6
    247c:	af 2d       	mov	r26, r15
    247e:	bb 27       	eor	r27, r27
    2480:	a7 fd       	sbrc	r26, 7
    2482:	b0 95       	com	r27
    2484:	af 53       	subi	r26, 0x3F	; 63
    2486:	bd 4f       	sbci	r27, 0xFD	; 253
    2488:	6c 90       	ld	r6, X
    248a:	d6 28       	or	r13, r6
    248c:	d7 28       	or	r13, r7
    248e:	d4 82       	std	Z+4, r13	; 0x04
    2490:	83 e0       	ldi	r24, 0x03	; 3
    2492:	8f 15       	cp	r24, r15
    2494:	14 f4       	brge	.+4      	; 0x249a <spi_new_instance+0x8a>
    2496:	81 e0       	ldi	r24, 0x01	; 1
    2498:	85 83       	std	Z+5, r24	; 0x05
    249a:	97 82       	std	Z+7, r9	; 0x07
    249c:	86 82       	std	Z+6, r8	; 0x06
    249e:	b1 86       	std	Z+9, r11	; 0x09
    24a0:	a0 86       	std	Z+8, r10	; 0x08
    24a2:	8a 89       	ldd	r24, Y+18	; 0x12
    24a4:	9b 89       	ldd	r25, Y+19	; 0x13
    24a6:	93 87       	std	Z+11, r25	; 0x0b
    24a8:	82 87       	std	Z+10, r24	; 0x0a
    24aa:	6f b7       	in	r22, 0x3f	; 63
    24ac:	f8 94       	cli
    24ae:	80 91 71 0d 	lds	r24, 0x0D71
    24b2:	90 91 72 0d 	lds	r25, 0x0D72
    24b6:	f0 93 72 0d 	sts	0x0D72, r31
    24ba:	e0 93 71 0d 	sts	0x0D71, r30
    24be:	23 81       	ldd	r18, Z+3	; 0x03
    24c0:	21 30       	cpi	r18, 0x01	; 1
    24c2:	81 f4       	brne	.+32     	; 0x24e4 <spi_new_instance+0xd4>
    24c4:	a0 81       	ld	r26, Z
    24c6:	b1 81       	ldd	r27, Z+1	; 0x01
    24c8:	7c 91       	ld	r23, X
    24ca:	41 e0       	ldi	r20, 0x01	; 1
    24cc:	50 e0       	ldi	r21, 0x00	; 0
    24ce:	9a 01       	movw	r18, r20
    24d0:	02 80       	ldd	r0, Z+2	; 0x02
    24d2:	02 c0       	rjmp	.+4      	; 0x24d8 <spi_new_instance+0xc8>
    24d4:	22 0f       	add	r18, r18
    24d6:	33 1f       	adc	r19, r19
    24d8:	0a 94       	dec	r0
    24da:	e2 f7       	brpl	.-8      	; 0x24d4 <spi_new_instance+0xc4>
    24dc:	20 95       	com	r18
    24de:	27 23       	and	r18, r23
    24e0:	2c 93       	st	X, r18
    24e2:	0e c0       	rjmp	.+28     	; 0x2500 <spi_new_instance+0xf0>
    24e4:	a0 81       	ld	r26, Z
    24e6:	b1 81       	ldd	r27, Z+1	; 0x01
    24e8:	7c 91       	ld	r23, X
    24ea:	41 e0       	ldi	r20, 0x01	; 1
    24ec:	50 e0       	ldi	r21, 0x00	; 0
    24ee:	9a 01       	movw	r18, r20
    24f0:	02 80       	ldd	r0, Z+2	; 0x02
    24f2:	02 c0       	rjmp	.+4      	; 0x24f8 <spi_new_instance+0xe8>
    24f4:	22 0f       	add	r18, r18
    24f6:	33 1f       	adc	r19, r19
    24f8:	0a 94       	dec	r0
    24fa:	e2 f7       	brpl	.-8      	; 0x24f4 <spi_new_instance+0xe4>
    24fc:	27 2b       	or	r18, r23
    24fe:	2c 93       	st	X, r18
    2500:	90 93 72 0d 	sts	0x0D72, r25
    2504:	80 93 71 0d 	sts	0x0D71, r24
    2508:	6f bf       	out	0x3f, r22	; 63
    250a:	cf 01       	movw	r24, r30
    250c:	df 91       	pop	r29
    250e:	cf 91       	pop	r28
    2510:	1f 91       	pop	r17
    2512:	0f 91       	pop	r16
    2514:	ff 90       	pop	r15
    2516:	ef 90       	pop	r14
    2518:	df 90       	pop	r13
    251a:	cf 90       	pop	r12
    251c:	bf 90       	pop	r11
    251e:	af 90       	pop	r10
    2520:	9f 90       	pop	r9
    2522:	8f 90       	pop	r8
    2524:	7f 90       	pop	r7
    2526:	6f 90       	pop	r6
    2528:	08 95       	ret

0000252a <spi_send_string>:
SPI_ILLEGAL_INSTANCE: instance is null.
@param spi to send to.
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
    252a:	df 92       	push	r13
    252c:	ef 92       	push	r14
    252e:	ff 92       	push	r15
    2530:	0f 93       	push	r16
    2532:	1f 93       	push	r17
    2534:	cf 93       	push	r28
    2536:	df 93       	push	r29
    2538:	ec 01       	movw	r28, r24
    253a:	8b 01       	movw	r16, r22
    253c:	f4 2e       	mov	r15, r20
	if (spi == 0) {
    253e:	00 97       	sbiw	r24, 0x00	; 0
    2540:	09 f4       	brne	.+2      	; 0x2544 <spi_send_string+0x1a>
    2542:	6b c0       	rjmp	.+214    	; 0x261a <spi_send_string+0xf0>
		return SPI_ILLEGAL_INSTANCE;
	}

	// Select correct instance
	if (_this != spi ) {
    2544:	80 91 71 0d 	lds	r24, 0x0D71
    2548:	90 91 72 0d 	lds	r25, 0x0D72
    254c:	8c 17       	cp	r24, r28
    254e:	9d 07       	cpc	r25, r29
    2550:	11 f0       	breq	.+4      	; 0x2556 <spi_send_string+0x2c>
		_select_instance(spi);
    2552:	ce 01       	movw	r24, r28
    2554:	23 df       	rcall	.-442    	; 0x239c <_select_instance>
	uint8_t tmp = 0;

	// Critical section
	{
		// disable interrupt
		uint8_t c_sreg = SREG;
    2556:	ef b6       	in	r14, 0x3f	; 63
		cli();
    2558:	f8 94       	cli

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
    255a:	ee 81       	ldd	r30, Y+6	; 0x06
    255c:	ff 81       	ldd	r31, Y+7	; 0x07
    255e:	30 97       	sbiw	r30, 0x00	; 0
    2560:	61 f0       	breq	.+24     	; 0x257a <spi_send_string+0x50>
    2562:	2f 2d       	mov	r18, r15
    2564:	30 e0       	ldi	r19, 0x00	; 0
    2566:	42 89       	ldd	r20, Z+18	; 0x12
    2568:	80 e1       	ldi	r24, 0x10	; 16
    256a:	90 e0       	ldi	r25, 0x00	; 0
    256c:	84 1b       	sub	r24, r20
    256e:	91 09       	sbc	r25, r1
    2570:	82 17       	cp	r24, r18
    2572:	93 07       	cpc	r25, r19
    2574:	0c f4       	brge	.+2      	; 0x2578 <spi_send_string+0x4e>
    2576:	48 c0       	rjmp	.+144    	; 0x2608 <spi_send_string+0xde>
    2578:	04 c0       	rjmp	.+8      	; 0x2582 <spi_send_string+0x58>
    257a:	81 e0       	ldi	r24, 0x01	; 1
    257c:	8f 15       	cp	r24, r15
    257e:	08 f4       	brcc	.+2      	; 0x2582 <spi_send_string+0x58>
    2580:	45 c0       	rjmp	.+138    	; 0x260c <spi_send_string+0xe2>
			result = SPI_NO_ROOM_IN_TX_BUFFER;
			} else {
			// If SPI in idle send the first byte
			if (!_spi_active) {
    2582:	80 91 73 0d 	lds	r24, 0x0D73
    2586:	81 11       	cpse	r24, r1
    2588:	30 c0       	rjmp	.+96     	; 0x25ea <spi_send_string+0xc0>
				_spi_active = 1;
    258a:	81 e0       	ldi	r24, 0x01	; 1
    258c:	80 93 73 0d 	sts	0x0D73, r24
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    2590:	e0 91 71 0d 	lds	r30, 0x0D71
    2594:	f0 91 72 0d 	lds	r31, 0x0D72
    2598:	83 81       	ldd	r24, Z+3	; 0x03
    259a:	81 30       	cpi	r24, 0x01	; 1
    259c:	79 f4       	brne	.+30     	; 0x25bc <spi_send_string+0x92>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    259e:	a0 81       	ld	r26, Z
    25a0:	b1 81       	ldd	r27, Z+1	; 0x01
    25a2:	4c 91       	ld	r20, X
    25a4:	21 e0       	ldi	r18, 0x01	; 1
    25a6:	30 e0       	ldi	r19, 0x00	; 0
    25a8:	c9 01       	movw	r24, r18
    25aa:	02 80       	ldd	r0, Z+2	; 0x02
    25ac:	02 c0       	rjmp	.+4      	; 0x25b2 <spi_send_string+0x88>
    25ae:	88 0f       	add	r24, r24
    25b0:	99 1f       	adc	r25, r25
    25b2:	0a 94       	dec	r0
    25b4:	e2 f7       	brpl	.-8      	; 0x25ae <spi_send_string+0x84>
    25b6:	84 2b       	or	r24, r20
    25b8:	8c 93       	st	X, r24
    25ba:	0e c0       	rjmp	.+28     	; 0x25d8 <spi_send_string+0xae>
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
		}
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    25bc:	a0 81       	ld	r26, Z
    25be:	b1 81       	ldd	r27, Z+1	; 0x01
    25c0:	2c 91       	ld	r18, X
    25c2:	81 e0       	ldi	r24, 0x01	; 1
    25c4:	90 e0       	ldi	r25, 0x00	; 0
    25c6:	02 80       	ldd	r0, Z+2	; 0x02
    25c8:	02 c0       	rjmp	.+4      	; 0x25ce <spi_send_string+0xa4>
    25ca:	88 0f       	add	r24, r24
    25cc:	99 1f       	adc	r25, r25
    25ce:	0a 94       	dec	r0
    25d0:	e2 f7       	brpl	.-8      	; 0x25ca <spi_send_string+0xa0>
    25d2:	80 95       	com	r24
    25d4:	82 23       	and	r24, r18
    25d6:	8c 93       	st	X, r24
			// If SPI in idle send the first byte
			if (!_spi_active) {
				_spi_active = 1;
				_set_cs(CS_ACTIVE);
				// Enable SPI interrupt
				SPCR |= _BV(SPIE);
    25d8:	8c b5       	in	r24, 0x2c	; 44
    25da:	80 68       	ori	r24, 0x80	; 128
    25dc:	8c bd       	out	0x2c, r24	; 44
				// Send first byte
				SPDR =buf[0];
    25de:	f8 01       	movw	r30, r16
    25e0:	80 81       	ld	r24, Z
    25e2:	8e bd       	out	0x2e, r24	; 46

				tmp = 1;
    25e4:	dd 24       	eor	r13, r13
    25e6:	d3 94       	inc	r13
    25e8:	01 c0       	rjmp	.+2      	; 0x25ec <spi_send_string+0xc2>
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
	uint8_t tmp = 0;
    25ea:	d1 2c       	mov	r13, r1
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    25ec:	df 14       	cp	r13, r15
    25ee:	80 f4       	brcc	.+32     	; 0x2610 <spi_send_string+0xe6>
				buffer_put_item(spi->_tx_buf, buf[i]);
    25f0:	f8 01       	movw	r30, r16
    25f2:	ed 0d       	add	r30, r13
    25f4:	f1 1d       	adc	r31, r1
    25f6:	60 81       	ld	r22, Z
    25f8:	8e 81       	ldd	r24, Y+6	; 0x06
    25fa:	9f 81       	ldd	r25, Y+7	; 0x07
    25fc:	0e 94 32 04 	call	0x864	; 0x864 <buffer_put_item>
				SPDR =buf[0];

				tmp = 1;
			}
			// Put in the tx buffer
			for (uint8_t i = tmp; i < len; i++) {
    2600:	d3 94       	inc	r13
    2602:	df 14       	cp	r13, r15
    2604:	a8 f3       	brcs	.-22     	; 0x25f0 <spi_send_string+0xc6>
    2606:	06 c0       	rjmp	.+12     	; 0x2614 <spi_send_string+0xea>
		uint8_t c_sreg = SREG;
		cli();

		// Check if buffer is free
		if ( ((spi->_tx_buf != 0) && (len > (BUFFER_SIZE - spi->_tx_buf->no_in_buffer))) || ((spi->_tx_buf == 0) && (len > 1)) ) {
			result = SPI_NO_ROOM_IN_TX_BUFFER;
    2608:	81 e0       	ldi	r24, 0x01	; 1
    260a:	05 c0       	rjmp	.+10     	; 0x2616 <spi_send_string+0xec>
    260c:	81 e0       	ldi	r24, 0x01	; 1
    260e:	03 c0       	rjmp	.+6      	; 0x2616 <spi_send_string+0xec>
	// Select correct instance
	if (_this != spi ) {
		_select_instance(spi);
	}

	uint8_t result = SPI_OK;
    2610:	80 e0       	ldi	r24, 0x00	; 0
    2612:	01 c0       	rjmp	.+2      	; 0x2616 <spi_send_string+0xec>
    2614:	80 e0       	ldi	r24, 0x00	; 0
				buffer_put_item(spi->_tx_buf, buf[i]);
			}
		}

		// restore interrupt state
		SREG = c_sreg;
    2616:	ef be       	out	0x3f, r14	; 63
	}

	return result;
    2618:	01 c0       	rjmp	.+2      	; 0x261c <spi_send_string+0xf2>
@param *buf pointer to buffer to be send.
@param len no of bytes to send.
*/
uint8_t spi_send_string(spi_p spi, uint8_t *buf, uint8_t len) {
	if (spi == 0) {
		return SPI_ILLEGAL_INSTANCE;
    261a:	83 e0       	ldi	r24, 0x03	; 3
		// restore interrupt state
		SREG = c_sreg;
	}

	return result;
}
    261c:	df 91       	pop	r29
    261e:	cf 91       	pop	r28
    2620:	1f 91       	pop	r17
    2622:	0f 91       	pop	r16
    2624:	ff 90       	pop	r15
    2626:	ef 90       	pop	r14
    2628:	df 90       	pop	r13
    262a:	08 95       	ret

0000262c <__vector_24>:

/* ======================================================================================================================= */
/**
@todo Documentation
*/
ISR(SPI_STC_vect) {
    262c:	1f 92       	push	r1
    262e:	0f 92       	push	r0
    2630:	0f b6       	in	r0, 0x3f	; 63
    2632:	0f 92       	push	r0
    2634:	11 24       	eor	r1, r1
    2636:	0b b6       	in	r0, 0x3b	; 59
    2638:	0f 92       	push	r0
    263a:	2f 93       	push	r18
    263c:	3f 93       	push	r19
    263e:	4f 93       	push	r20
    2640:	5f 93       	push	r21
    2642:	6f 93       	push	r22
    2644:	7f 93       	push	r23
    2646:	8f 93       	push	r24
    2648:	9f 93       	push	r25
    264a:	af 93       	push	r26
    264c:	bf 93       	push	r27
    264e:	ef 93       	push	r30
    2650:	ff 93       	push	r31
    2652:	cf 93       	push	r28
    2654:	df 93       	push	r29
    2656:	1f 92       	push	r1
    2658:	cd b7       	in	r28, 0x3d	; 61
    265a:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	#if SPI_USE_BUFFER == 1
	// store received byte if receive buffer available

	if (_this->_rx_buf != 0){
    265c:	e0 91 71 0d 	lds	r30, 0x0D71
    2660:	f0 91 72 0d 	lds	r31, 0x0D72
    2664:	80 85       	ldd	r24, Z+8	; 0x08
    2666:	91 85       	ldd	r25, Z+9	; 0x09
    2668:	00 97       	sbiw	r24, 0x00	; 0
    266a:	19 f0       	breq	.+6      	; 0x2672 <__vector_24+0x46>
		buffer_put_item(_this->_rx_buf, SPDR);
    266c:	6e b5       	in	r22, 0x2e	; 46
    266e:	0e 94 32 04 	call	0x864	; 0x864 <buffer_put_item>
	}
	// more bytes to send?
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
    2672:	e0 91 71 0d 	lds	r30, 0x0D71
    2676:	f0 91 72 0d 	lds	r31, 0x0D72
    267a:	be 01       	movw	r22, r28
    267c:	6f 5f       	subi	r22, 0xFF	; 255
    267e:	7f 4f       	sbci	r23, 0xFF	; 255
    2680:	86 81       	ldd	r24, Z+6	; 0x06
    2682:	97 81       	ldd	r25, Z+7	; 0x07
    2684:	0e 94 1a 04 	call	0x834	; 0x834 <buffer_get_item>
    2688:	81 11       	cpse	r24, r1
    268a:	03 c0       	rjmp	.+6      	; 0x2692 <__vector_24+0x66>
		_spi_send_byte(item);
    268c:	89 81       	ldd	r24, Y+1	; 0x01
// Indexed by SPI_CLOCK_DIVIDER_xx defines
static const uint8_t _prescaler_mask [] = {0b00,0b01,0b10,0b11,0b00,0b01,0b10};

// Send a byte to the SPI-bus
static inline void _spi_send_byte(uint8_t byte) {
	SPDR = byte;
    268e:	8e bd       	out	0x2e, r24	; 46
    2690:	29 c0       	rjmp	.+82     	; 0x26e4 <__vector_24+0xb8>
	if ( buffer_get_item(_this->_tx_buf, &item) == BUFFER_OK) {
		_spi_send_byte(item);
		} else {
		// No
		// Disable SPI interrupt
		SPCR &= ~_BV(SPIE);
    2692:	8c b5       	in	r24, 0x2c	; 44
    2694:	8f 77       	andi	r24, 0x7F	; 127
    2696:	8c bd       	out	0x2c, r24	; 44
		_spi_active = 0;
    2698:	10 92 73 0d 	sts	0x0D73, r1
	SPDR = byte;
}

// Set the CS according to the instance
static inline void _set_cs(uint8_t state) {
	if (_this->_cs_active_level == 1) {
    269c:	e0 91 71 0d 	lds	r30, 0x0D71
    26a0:	f0 91 72 0d 	lds	r31, 0x0D72
    26a4:	83 81       	ldd	r24, Z+3	; 0x03
    26a6:	81 30       	cpi	r24, 0x01	; 1
    26a8:	79 f4       	brne	.+30     	; 0x26c8 <__vector_24+0x9c>
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
			} else {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);
    26aa:	a0 81       	ld	r26, Z
    26ac:	b1 81       	ldd	r27, Z+1	; 0x01
    26ae:	2c 91       	ld	r18, X
    26b0:	81 e0       	ldi	r24, 0x01	; 1
    26b2:	90 e0       	ldi	r25, 0x00	; 0
    26b4:	02 80       	ldd	r0, Z+2	; 0x02
    26b6:	02 c0       	rjmp	.+4      	; 0x26bc <__vector_24+0x90>
    26b8:	88 0f       	add	r24, r24
    26ba:	99 1f       	adc	r25, r25
    26bc:	0a 94       	dec	r0
    26be:	e2 f7       	brpl	.-8      	; 0x26b8 <__vector_24+0x8c>
    26c0:	80 95       	com	r24
    26c2:	82 23       	and	r24, r18
    26c4:	8c 93       	st	X, r24
    26c6:	0e c0       	rjmp	.+28     	; 0x26e4 <__vector_24+0xb8>
		} else {
		if (state == CS_ACTIVE) {
			*(_this->_cs_port) &= ~_BV(_this->_cs_pin);

			} else {
			*(_this->_cs_port) |= _BV(_this->_cs_pin);
    26c8:	a0 81       	ld	r26, Z
    26ca:	b1 81       	ldd	r27, Z+1	; 0x01
    26cc:	4c 91       	ld	r20, X
    26ce:	21 e0       	ldi	r18, 0x01	; 1
    26d0:	30 e0       	ldi	r19, 0x00	; 0
    26d2:	c9 01       	movw	r24, r18
    26d4:	02 80       	ldd	r0, Z+2	; 0x02
    26d6:	02 c0       	rjmp	.+4      	; 0x26dc <__vector_24+0xb0>
    26d8:	88 0f       	add	r24, r24
    26da:	99 1f       	adc	r25, r25
    26dc:	0a 94       	dec	r0
    26de:	e2 f7       	brpl	.-8      	; 0x26d8 <__vector_24+0xac>
    26e0:	84 2b       	or	r24, r20
    26e2:	8c 93       	st	X, r24
	_spi_active = 0;
	_set_cs(CS_INACTIVE);
	#endif

	// If handler defined - call it with instance and received byte.
	if (_this->_call_back)
    26e4:	80 91 71 0d 	lds	r24, 0x0D71
    26e8:	90 91 72 0d 	lds	r25, 0x0D72
    26ec:	dc 01       	movw	r26, r24
    26ee:	1a 96       	adiw	r26, 0x0a	; 10
    26f0:	ed 91       	ld	r30, X+
    26f2:	fc 91       	ld	r31, X
    26f4:	1b 97       	sbiw	r26, 0x0b	; 11
    26f6:	30 97       	sbiw	r30, 0x00	; 0
    26f8:	11 f0       	breq	.+4      	; 0x26fe <__vector_24+0xd2>
	{
		_this->_call_back(_this, item);
    26fa:	69 81       	ldd	r22, Y+1	; 0x01
    26fc:	19 95       	eicall
	}
    26fe:	0f 90       	pop	r0
    2700:	df 91       	pop	r29
    2702:	cf 91       	pop	r28
    2704:	ff 91       	pop	r31
    2706:	ef 91       	pop	r30
    2708:	bf 91       	pop	r27
    270a:	af 91       	pop	r26
    270c:	9f 91       	pop	r25
    270e:	8f 91       	pop	r24
    2710:	7f 91       	pop	r23
    2712:	6f 91       	pop	r22
    2714:	5f 91       	pop	r21
    2716:	4f 91       	pop	r20
    2718:	3f 91       	pop	r19
    271a:	2f 91       	pop	r18
    271c:	0f 90       	pop	r0
    271e:	0b be       	out	0x3b, r0	; 59
    2720:	0f 90       	pop	r0
    2722:	0f be       	out	0x3f, r0	; 63
    2724:	0f 90       	pop	r0
    2726:	1f 90       	pop	r1
    2728:	18 95       	reti

0000272a <__udivmodsi4>:
    272a:	a1 e2       	ldi	r26, 0x21	; 33
    272c:	1a 2e       	mov	r1, r26
    272e:	aa 1b       	sub	r26, r26
    2730:	bb 1b       	sub	r27, r27
    2732:	fd 01       	movw	r30, r26
    2734:	0d c0       	rjmp	.+26     	; 0x2750 <__udivmodsi4_ep>

00002736 <__udivmodsi4_loop>:
    2736:	aa 1f       	adc	r26, r26
    2738:	bb 1f       	adc	r27, r27
    273a:	ee 1f       	adc	r30, r30
    273c:	ff 1f       	adc	r31, r31
    273e:	a2 17       	cp	r26, r18
    2740:	b3 07       	cpc	r27, r19
    2742:	e4 07       	cpc	r30, r20
    2744:	f5 07       	cpc	r31, r21
    2746:	20 f0       	brcs	.+8      	; 0x2750 <__udivmodsi4_ep>
    2748:	a2 1b       	sub	r26, r18
    274a:	b3 0b       	sbc	r27, r19
    274c:	e4 0b       	sbc	r30, r20
    274e:	f5 0b       	sbc	r31, r21

00002750 <__udivmodsi4_ep>:
    2750:	66 1f       	adc	r22, r22
    2752:	77 1f       	adc	r23, r23
    2754:	88 1f       	adc	r24, r24
    2756:	99 1f       	adc	r25, r25
    2758:	1a 94       	dec	r1
    275a:	69 f7       	brne	.-38     	; 0x2736 <__udivmodsi4_loop>
    275c:	60 95       	com	r22
    275e:	70 95       	com	r23
    2760:	80 95       	com	r24
    2762:	90 95       	com	r25
    2764:	9b 01       	movw	r18, r22
    2766:	ac 01       	movw	r20, r24
    2768:	bd 01       	movw	r22, r26
    276a:	cf 01       	movw	r24, r30
    276c:	08 95       	ret

0000276e <__divmodsi4>:
    276e:	05 2e       	mov	r0, r21
    2770:	97 fb       	bst	r25, 7
    2772:	16 f4       	brtc	.+4      	; 0x2778 <__divmodsi4+0xa>
    2774:	00 94       	com	r0
    2776:	0f d0       	rcall	.+30     	; 0x2796 <__negsi2>
    2778:	57 fd       	sbrc	r21, 7
    277a:	05 d0       	rcall	.+10     	; 0x2786 <__divmodsi4_neg2>
    277c:	d6 df       	rcall	.-84     	; 0x272a <__udivmodsi4>
    277e:	07 fc       	sbrc	r0, 7
    2780:	02 d0       	rcall	.+4      	; 0x2786 <__divmodsi4_neg2>
    2782:	46 f4       	brtc	.+16     	; 0x2794 <__divmodsi4_exit>
    2784:	08 c0       	rjmp	.+16     	; 0x2796 <__negsi2>

00002786 <__divmodsi4_neg2>:
    2786:	50 95       	com	r21
    2788:	40 95       	com	r20
    278a:	30 95       	com	r19
    278c:	21 95       	neg	r18
    278e:	3f 4f       	sbci	r19, 0xFF	; 255
    2790:	4f 4f       	sbci	r20, 0xFF	; 255
    2792:	5f 4f       	sbci	r21, 0xFF	; 255

00002794 <__divmodsi4_exit>:
    2794:	08 95       	ret

00002796 <__negsi2>:
    2796:	90 95       	com	r25
    2798:	80 95       	com	r24
    279a:	70 95       	com	r23
    279c:	61 95       	neg	r22
    279e:	7f 4f       	sbci	r23, 0xFF	; 255
    27a0:	8f 4f       	sbci	r24, 0xFF	; 255
    27a2:	9f 4f       	sbci	r25, 0xFF	; 255
    27a4:	08 95       	ret

000027a6 <__tablejump2__>:
    27a6:	ee 0f       	add	r30, r30
    27a8:	ff 1f       	adc	r31, r31

000027aa <__tablejump__>:
    27aa:	05 90       	lpm	r0, Z+
    27ac:	f4 91       	lpm	r31, Z
    27ae:	e0 2d       	mov	r30, r0
    27b0:	19 94       	eijmp

000027b2 <__umulhisi3>:
    27b2:	a2 9f       	mul	r26, r18
    27b4:	b0 01       	movw	r22, r0
    27b6:	b3 9f       	mul	r27, r19
    27b8:	c0 01       	movw	r24, r0
    27ba:	a3 9f       	mul	r26, r19
    27bc:	70 0d       	add	r23, r0
    27be:	81 1d       	adc	r24, r1
    27c0:	11 24       	eor	r1, r1
    27c2:	91 1d       	adc	r25, r1
    27c4:	b2 9f       	mul	r27, r18
    27c6:	70 0d       	add	r23, r0
    27c8:	81 1d       	adc	r24, r1
    27ca:	11 24       	eor	r1, r1
    27cc:	91 1d       	adc	r25, r1
    27ce:	08 95       	ret

000027d0 <malloc>:
    27d0:	cf 93       	push	r28
    27d2:	df 93       	push	r29
    27d4:	82 30       	cpi	r24, 0x02	; 2
    27d6:	91 05       	cpc	r25, r1
    27d8:	10 f4       	brcc	.+4      	; 0x27de <malloc+0xe>
    27da:	82 e0       	ldi	r24, 0x02	; 2
    27dc:	90 e0       	ldi	r25, 0x00	; 0
    27de:	e0 91 76 0d 	lds	r30, 0x0D76
    27e2:	f0 91 77 0d 	lds	r31, 0x0D77
    27e6:	20 e0       	ldi	r18, 0x00	; 0
    27e8:	30 e0       	ldi	r19, 0x00	; 0
    27ea:	a0 e0       	ldi	r26, 0x00	; 0
    27ec:	b0 e0       	ldi	r27, 0x00	; 0
    27ee:	30 97       	sbiw	r30, 0x00	; 0
    27f0:	39 f1       	breq	.+78     	; 0x2840 <malloc+0x70>
    27f2:	40 81       	ld	r20, Z
    27f4:	51 81       	ldd	r21, Z+1	; 0x01
    27f6:	48 17       	cp	r20, r24
    27f8:	59 07       	cpc	r21, r25
    27fa:	b8 f0       	brcs	.+46     	; 0x282a <malloc+0x5a>
    27fc:	48 17       	cp	r20, r24
    27fe:	59 07       	cpc	r21, r25
    2800:	71 f4       	brne	.+28     	; 0x281e <malloc+0x4e>
    2802:	82 81       	ldd	r24, Z+2	; 0x02
    2804:	93 81       	ldd	r25, Z+3	; 0x03
    2806:	10 97       	sbiw	r26, 0x00	; 0
    2808:	29 f0       	breq	.+10     	; 0x2814 <malloc+0x44>
    280a:	13 96       	adiw	r26, 0x03	; 3
    280c:	9c 93       	st	X, r25
    280e:	8e 93       	st	-X, r24
    2810:	12 97       	sbiw	r26, 0x02	; 2
    2812:	2c c0       	rjmp	.+88     	; 0x286c <malloc+0x9c>
    2814:	90 93 77 0d 	sts	0x0D77, r25
    2818:	80 93 76 0d 	sts	0x0D76, r24
    281c:	27 c0       	rjmp	.+78     	; 0x286c <malloc+0x9c>
    281e:	21 15       	cp	r18, r1
    2820:	31 05       	cpc	r19, r1
    2822:	31 f0       	breq	.+12     	; 0x2830 <malloc+0x60>
    2824:	42 17       	cp	r20, r18
    2826:	53 07       	cpc	r21, r19
    2828:	18 f0       	brcs	.+6      	; 0x2830 <malloc+0x60>
    282a:	a9 01       	movw	r20, r18
    282c:	db 01       	movw	r26, r22
    282e:	01 c0       	rjmp	.+2      	; 0x2832 <malloc+0x62>
    2830:	ef 01       	movw	r28, r30
    2832:	9a 01       	movw	r18, r20
    2834:	bd 01       	movw	r22, r26
    2836:	df 01       	movw	r26, r30
    2838:	02 80       	ldd	r0, Z+2	; 0x02
    283a:	f3 81       	ldd	r31, Z+3	; 0x03
    283c:	e0 2d       	mov	r30, r0
    283e:	d7 cf       	rjmp	.-82     	; 0x27ee <malloc+0x1e>
    2840:	21 15       	cp	r18, r1
    2842:	31 05       	cpc	r19, r1
    2844:	f9 f0       	breq	.+62     	; 0x2884 <malloc+0xb4>
    2846:	28 1b       	sub	r18, r24
    2848:	39 0b       	sbc	r19, r25
    284a:	24 30       	cpi	r18, 0x04	; 4
    284c:	31 05       	cpc	r19, r1
    284e:	80 f4       	brcc	.+32     	; 0x2870 <malloc+0xa0>
    2850:	8a 81       	ldd	r24, Y+2	; 0x02
    2852:	9b 81       	ldd	r25, Y+3	; 0x03
    2854:	61 15       	cp	r22, r1
    2856:	71 05       	cpc	r23, r1
    2858:	21 f0       	breq	.+8      	; 0x2862 <malloc+0x92>
    285a:	fb 01       	movw	r30, r22
    285c:	93 83       	std	Z+3, r25	; 0x03
    285e:	82 83       	std	Z+2, r24	; 0x02
    2860:	04 c0       	rjmp	.+8      	; 0x286a <malloc+0x9a>
    2862:	90 93 77 0d 	sts	0x0D77, r25
    2866:	80 93 76 0d 	sts	0x0D76, r24
    286a:	fe 01       	movw	r30, r28
    286c:	32 96       	adiw	r30, 0x02	; 2
    286e:	44 c0       	rjmp	.+136    	; 0x28f8 <malloc+0x128>
    2870:	fe 01       	movw	r30, r28
    2872:	e2 0f       	add	r30, r18
    2874:	f3 1f       	adc	r31, r19
    2876:	81 93       	st	Z+, r24
    2878:	91 93       	st	Z+, r25
    287a:	22 50       	subi	r18, 0x02	; 2
    287c:	31 09       	sbc	r19, r1
    287e:	39 83       	std	Y+1, r19	; 0x01
    2880:	28 83       	st	Y, r18
    2882:	3a c0       	rjmp	.+116    	; 0x28f8 <malloc+0x128>
    2884:	20 91 74 0d 	lds	r18, 0x0D74
    2888:	30 91 75 0d 	lds	r19, 0x0D75
    288c:	23 2b       	or	r18, r19
    288e:	41 f4       	brne	.+16     	; 0x28a0 <malloc+0xd0>
    2890:	20 91 02 02 	lds	r18, 0x0202
    2894:	30 91 03 02 	lds	r19, 0x0203
    2898:	30 93 75 0d 	sts	0x0D75, r19
    289c:	20 93 74 0d 	sts	0x0D74, r18
    28a0:	20 91 00 02 	lds	r18, 0x0200
    28a4:	30 91 01 02 	lds	r19, 0x0201
    28a8:	21 15       	cp	r18, r1
    28aa:	31 05       	cpc	r19, r1
    28ac:	41 f4       	brne	.+16     	; 0x28be <malloc+0xee>
    28ae:	2d b7       	in	r18, 0x3d	; 61
    28b0:	3e b7       	in	r19, 0x3e	; 62
    28b2:	40 91 04 02 	lds	r20, 0x0204
    28b6:	50 91 05 02 	lds	r21, 0x0205
    28ba:	24 1b       	sub	r18, r20
    28bc:	35 0b       	sbc	r19, r21
    28be:	e0 91 74 0d 	lds	r30, 0x0D74
    28c2:	f0 91 75 0d 	lds	r31, 0x0D75
    28c6:	e2 17       	cp	r30, r18
    28c8:	f3 07       	cpc	r31, r19
    28ca:	a0 f4       	brcc	.+40     	; 0x28f4 <malloc+0x124>
    28cc:	2e 1b       	sub	r18, r30
    28ce:	3f 0b       	sbc	r19, r31
    28d0:	28 17       	cp	r18, r24
    28d2:	39 07       	cpc	r19, r25
    28d4:	78 f0       	brcs	.+30     	; 0x28f4 <malloc+0x124>
    28d6:	ac 01       	movw	r20, r24
    28d8:	4e 5f       	subi	r20, 0xFE	; 254
    28da:	5f 4f       	sbci	r21, 0xFF	; 255
    28dc:	24 17       	cp	r18, r20
    28de:	35 07       	cpc	r19, r21
    28e0:	48 f0       	brcs	.+18     	; 0x28f4 <malloc+0x124>
    28e2:	4e 0f       	add	r20, r30
    28e4:	5f 1f       	adc	r21, r31
    28e6:	50 93 75 0d 	sts	0x0D75, r21
    28ea:	40 93 74 0d 	sts	0x0D74, r20
    28ee:	81 93       	st	Z+, r24
    28f0:	91 93       	st	Z+, r25
    28f2:	02 c0       	rjmp	.+4      	; 0x28f8 <malloc+0x128>
    28f4:	e0 e0       	ldi	r30, 0x00	; 0
    28f6:	f0 e0       	ldi	r31, 0x00	; 0
    28f8:	cf 01       	movw	r24, r30
    28fa:	df 91       	pop	r29
    28fc:	cf 91       	pop	r28
    28fe:	08 95       	ret

00002900 <free>:
    2900:	cf 93       	push	r28
    2902:	df 93       	push	r29
    2904:	00 97       	sbiw	r24, 0x00	; 0
    2906:	09 f4       	brne	.+2      	; 0x290a <free+0xa>
    2908:	87 c0       	rjmp	.+270    	; 0x2a18 <free+0x118>
    290a:	fc 01       	movw	r30, r24
    290c:	32 97       	sbiw	r30, 0x02	; 2
    290e:	13 82       	std	Z+3, r1	; 0x03
    2910:	12 82       	std	Z+2, r1	; 0x02
    2912:	c0 91 76 0d 	lds	r28, 0x0D76
    2916:	d0 91 77 0d 	lds	r29, 0x0D77
    291a:	20 97       	sbiw	r28, 0x00	; 0
    291c:	81 f4       	brne	.+32     	; 0x293e <free+0x3e>
    291e:	20 81       	ld	r18, Z
    2920:	31 81       	ldd	r19, Z+1	; 0x01
    2922:	28 0f       	add	r18, r24
    2924:	39 1f       	adc	r19, r25
    2926:	80 91 74 0d 	lds	r24, 0x0D74
    292a:	90 91 75 0d 	lds	r25, 0x0D75
    292e:	82 17       	cp	r24, r18
    2930:	93 07       	cpc	r25, r19
    2932:	79 f5       	brne	.+94     	; 0x2992 <free+0x92>
    2934:	f0 93 75 0d 	sts	0x0D75, r31
    2938:	e0 93 74 0d 	sts	0x0D74, r30
    293c:	6d c0       	rjmp	.+218    	; 0x2a18 <free+0x118>
    293e:	de 01       	movw	r26, r28
    2940:	20 e0       	ldi	r18, 0x00	; 0
    2942:	30 e0       	ldi	r19, 0x00	; 0
    2944:	ae 17       	cp	r26, r30
    2946:	bf 07       	cpc	r27, r31
    2948:	50 f4       	brcc	.+20     	; 0x295e <free+0x5e>
    294a:	12 96       	adiw	r26, 0x02	; 2
    294c:	4d 91       	ld	r20, X+
    294e:	5c 91       	ld	r21, X
    2950:	13 97       	sbiw	r26, 0x03	; 3
    2952:	9d 01       	movw	r18, r26
    2954:	41 15       	cp	r20, r1
    2956:	51 05       	cpc	r21, r1
    2958:	09 f1       	breq	.+66     	; 0x299c <free+0x9c>
    295a:	da 01       	movw	r26, r20
    295c:	f3 cf       	rjmp	.-26     	; 0x2944 <free+0x44>
    295e:	b3 83       	std	Z+3, r27	; 0x03
    2960:	a2 83       	std	Z+2, r26	; 0x02
    2962:	40 81       	ld	r20, Z
    2964:	51 81       	ldd	r21, Z+1	; 0x01
    2966:	84 0f       	add	r24, r20
    2968:	95 1f       	adc	r25, r21
    296a:	8a 17       	cp	r24, r26
    296c:	9b 07       	cpc	r25, r27
    296e:	71 f4       	brne	.+28     	; 0x298c <free+0x8c>
    2970:	8d 91       	ld	r24, X+
    2972:	9c 91       	ld	r25, X
    2974:	11 97       	sbiw	r26, 0x01	; 1
    2976:	84 0f       	add	r24, r20
    2978:	95 1f       	adc	r25, r21
    297a:	02 96       	adiw	r24, 0x02	; 2
    297c:	91 83       	std	Z+1, r25	; 0x01
    297e:	80 83       	st	Z, r24
    2980:	12 96       	adiw	r26, 0x02	; 2
    2982:	8d 91       	ld	r24, X+
    2984:	9c 91       	ld	r25, X
    2986:	13 97       	sbiw	r26, 0x03	; 3
    2988:	93 83       	std	Z+3, r25	; 0x03
    298a:	82 83       	std	Z+2, r24	; 0x02
    298c:	21 15       	cp	r18, r1
    298e:	31 05       	cpc	r19, r1
    2990:	29 f4       	brne	.+10     	; 0x299c <free+0x9c>
    2992:	f0 93 77 0d 	sts	0x0D77, r31
    2996:	e0 93 76 0d 	sts	0x0D76, r30
    299a:	3e c0       	rjmp	.+124    	; 0x2a18 <free+0x118>
    299c:	d9 01       	movw	r26, r18
    299e:	13 96       	adiw	r26, 0x03	; 3
    29a0:	fc 93       	st	X, r31
    29a2:	ee 93       	st	-X, r30
    29a4:	12 97       	sbiw	r26, 0x02	; 2
    29a6:	4d 91       	ld	r20, X+
    29a8:	5d 91       	ld	r21, X+
    29aa:	a4 0f       	add	r26, r20
    29ac:	b5 1f       	adc	r27, r21
    29ae:	ea 17       	cp	r30, r26
    29b0:	fb 07       	cpc	r31, r27
    29b2:	79 f4       	brne	.+30     	; 0x29d2 <free+0xd2>
    29b4:	80 81       	ld	r24, Z
    29b6:	91 81       	ldd	r25, Z+1	; 0x01
    29b8:	84 0f       	add	r24, r20
    29ba:	95 1f       	adc	r25, r21
    29bc:	02 96       	adiw	r24, 0x02	; 2
    29be:	d9 01       	movw	r26, r18
    29c0:	11 96       	adiw	r26, 0x01	; 1
    29c2:	9c 93       	st	X, r25
    29c4:	8e 93       	st	-X, r24
    29c6:	82 81       	ldd	r24, Z+2	; 0x02
    29c8:	93 81       	ldd	r25, Z+3	; 0x03
    29ca:	13 96       	adiw	r26, 0x03	; 3
    29cc:	9c 93       	st	X, r25
    29ce:	8e 93       	st	-X, r24
    29d0:	12 97       	sbiw	r26, 0x02	; 2
    29d2:	e0 e0       	ldi	r30, 0x00	; 0
    29d4:	f0 e0       	ldi	r31, 0x00	; 0
    29d6:	8a 81       	ldd	r24, Y+2	; 0x02
    29d8:	9b 81       	ldd	r25, Y+3	; 0x03
    29da:	00 97       	sbiw	r24, 0x00	; 0
    29dc:	19 f0       	breq	.+6      	; 0x29e4 <free+0xe4>
    29de:	fe 01       	movw	r30, r28
    29e0:	ec 01       	movw	r28, r24
    29e2:	f9 cf       	rjmp	.-14     	; 0x29d6 <free+0xd6>
    29e4:	ce 01       	movw	r24, r28
    29e6:	02 96       	adiw	r24, 0x02	; 2
    29e8:	28 81       	ld	r18, Y
    29ea:	39 81       	ldd	r19, Y+1	; 0x01
    29ec:	82 0f       	add	r24, r18
    29ee:	93 1f       	adc	r25, r19
    29f0:	20 91 74 0d 	lds	r18, 0x0D74
    29f4:	30 91 75 0d 	lds	r19, 0x0D75
    29f8:	28 17       	cp	r18, r24
    29fa:	39 07       	cpc	r19, r25
    29fc:	69 f4       	brne	.+26     	; 0x2a18 <free+0x118>
    29fe:	30 97       	sbiw	r30, 0x00	; 0
    2a00:	29 f4       	brne	.+10     	; 0x2a0c <free+0x10c>
    2a02:	10 92 77 0d 	sts	0x0D77, r1
    2a06:	10 92 76 0d 	sts	0x0D76, r1
    2a0a:	02 c0       	rjmp	.+4      	; 0x2a10 <free+0x110>
    2a0c:	13 82       	std	Z+3, r1	; 0x03
    2a0e:	12 82       	std	Z+2, r1	; 0x02
    2a10:	d0 93 75 0d 	sts	0x0D75, r29
    2a14:	c0 93 74 0d 	sts	0x0D74, r28
    2a18:	df 91       	pop	r29
    2a1a:	cf 91       	pop	r28
    2a1c:	08 95       	ret

00002a1e <memcpy>:
    2a1e:	fb 01       	movw	r30, r22
    2a20:	dc 01       	movw	r26, r24
    2a22:	02 c0       	rjmp	.+4      	; 0x2a28 <memcpy+0xa>
    2a24:	01 90       	ld	r0, Z+
    2a26:	0d 92       	st	X+, r0
    2a28:	41 50       	subi	r20, 0x01	; 1
    2a2a:	50 40       	sbci	r21, 0x00	; 0
    2a2c:	d8 f7       	brcc	.-10     	; 0x2a24 <memcpy+0x6>
    2a2e:	08 95       	ret

00002a30 <sprintf>:
    2a30:	0f 93       	push	r16
    2a32:	1f 93       	push	r17
    2a34:	cf 93       	push	r28
    2a36:	df 93       	push	r29
    2a38:	cd b7       	in	r28, 0x3d	; 61
    2a3a:	de b7       	in	r29, 0x3e	; 62
    2a3c:	2e 97       	sbiw	r28, 0x0e	; 14
    2a3e:	0f b6       	in	r0, 0x3f	; 63
    2a40:	f8 94       	cli
    2a42:	de bf       	out	0x3e, r29	; 62
    2a44:	0f be       	out	0x3f, r0	; 63
    2a46:	cd bf       	out	0x3d, r28	; 61
    2a48:	0e 89       	ldd	r16, Y+22	; 0x16
    2a4a:	1f 89       	ldd	r17, Y+23	; 0x17
    2a4c:	86 e0       	ldi	r24, 0x06	; 6
    2a4e:	8c 83       	std	Y+4, r24	; 0x04
    2a50:	1a 83       	std	Y+2, r17	; 0x02
    2a52:	09 83       	std	Y+1, r16	; 0x01
    2a54:	8f ef       	ldi	r24, 0xFF	; 255
    2a56:	9f e7       	ldi	r25, 0x7F	; 127
    2a58:	9e 83       	std	Y+6, r25	; 0x06
    2a5a:	8d 83       	std	Y+5, r24	; 0x05
    2a5c:	ae 01       	movw	r20, r28
    2a5e:	46 5e       	subi	r20, 0xE6	; 230
    2a60:	5f 4f       	sbci	r21, 0xFF	; 255
    2a62:	68 8d       	ldd	r22, Y+24	; 0x18
    2a64:	79 8d       	ldd	r23, Y+25	; 0x19
    2a66:	ce 01       	movw	r24, r28
    2a68:	01 96       	adiw	r24, 0x01	; 1
    2a6a:	10 d0       	rcall	.+32     	; 0x2a8c <vfprintf>
    2a6c:	ef 81       	ldd	r30, Y+7	; 0x07
    2a6e:	f8 85       	ldd	r31, Y+8	; 0x08
    2a70:	e0 0f       	add	r30, r16
    2a72:	f1 1f       	adc	r31, r17
    2a74:	10 82       	st	Z, r1
    2a76:	2e 96       	adiw	r28, 0x0e	; 14
    2a78:	0f b6       	in	r0, 0x3f	; 63
    2a7a:	f8 94       	cli
    2a7c:	de bf       	out	0x3e, r29	; 62
    2a7e:	0f be       	out	0x3f, r0	; 63
    2a80:	cd bf       	out	0x3d, r28	; 61
    2a82:	df 91       	pop	r29
    2a84:	cf 91       	pop	r28
    2a86:	1f 91       	pop	r17
    2a88:	0f 91       	pop	r16
    2a8a:	08 95       	ret

00002a8c <vfprintf>:
    2a8c:	2f 92       	push	r2
    2a8e:	3f 92       	push	r3
    2a90:	4f 92       	push	r4
    2a92:	5f 92       	push	r5
    2a94:	6f 92       	push	r6
    2a96:	7f 92       	push	r7
    2a98:	8f 92       	push	r8
    2a9a:	9f 92       	push	r9
    2a9c:	af 92       	push	r10
    2a9e:	bf 92       	push	r11
    2aa0:	cf 92       	push	r12
    2aa2:	df 92       	push	r13
    2aa4:	ef 92       	push	r14
    2aa6:	ff 92       	push	r15
    2aa8:	0f 93       	push	r16
    2aaa:	1f 93       	push	r17
    2aac:	cf 93       	push	r28
    2aae:	df 93       	push	r29
    2ab0:	cd b7       	in	r28, 0x3d	; 61
    2ab2:	de b7       	in	r29, 0x3e	; 62
    2ab4:	2c 97       	sbiw	r28, 0x0c	; 12
    2ab6:	0f b6       	in	r0, 0x3f	; 63
    2ab8:	f8 94       	cli
    2aba:	de bf       	out	0x3e, r29	; 62
    2abc:	0f be       	out	0x3f, r0	; 63
    2abe:	cd bf       	out	0x3d, r28	; 61
    2ac0:	7c 01       	movw	r14, r24
    2ac2:	6b 01       	movw	r12, r22
    2ac4:	8a 01       	movw	r16, r20
    2ac6:	fc 01       	movw	r30, r24
    2ac8:	17 82       	std	Z+7, r1	; 0x07
    2aca:	16 82       	std	Z+6, r1	; 0x06
    2acc:	83 81       	ldd	r24, Z+3	; 0x03
    2ace:	81 ff       	sbrs	r24, 1
    2ad0:	b0 c1       	rjmp	.+864    	; 0x2e32 <vfprintf+0x3a6>
    2ad2:	ce 01       	movw	r24, r28
    2ad4:	01 96       	adiw	r24, 0x01	; 1
    2ad6:	4c 01       	movw	r8, r24
    2ad8:	f7 01       	movw	r30, r14
    2ada:	93 81       	ldd	r25, Z+3	; 0x03
    2adc:	f6 01       	movw	r30, r12
    2ade:	93 fd       	sbrc	r25, 3
    2ae0:	85 91       	lpm	r24, Z+
    2ae2:	93 ff       	sbrs	r25, 3
    2ae4:	81 91       	ld	r24, Z+
    2ae6:	6f 01       	movw	r12, r30
    2ae8:	88 23       	and	r24, r24
    2aea:	09 f4       	brne	.+2      	; 0x2aee <vfprintf+0x62>
    2aec:	9e c1       	rjmp	.+828    	; 0x2e2a <vfprintf+0x39e>
    2aee:	85 32       	cpi	r24, 0x25	; 37
    2af0:	39 f4       	brne	.+14     	; 0x2b00 <vfprintf+0x74>
    2af2:	93 fd       	sbrc	r25, 3
    2af4:	85 91       	lpm	r24, Z+
    2af6:	93 ff       	sbrs	r25, 3
    2af8:	81 91       	ld	r24, Z+
    2afa:	6f 01       	movw	r12, r30
    2afc:	85 32       	cpi	r24, 0x25	; 37
    2afe:	21 f4       	brne	.+8      	; 0x2b08 <vfprintf+0x7c>
    2b00:	b7 01       	movw	r22, r14
    2b02:	90 e0       	ldi	r25, 0x00	; 0
    2b04:	c7 d1       	rcall	.+910    	; 0x2e94 <fputc>
    2b06:	e8 cf       	rjmp	.-48     	; 0x2ad8 <vfprintf+0x4c>
    2b08:	51 2c       	mov	r5, r1
    2b0a:	31 2c       	mov	r3, r1
    2b0c:	20 e0       	ldi	r18, 0x00	; 0
    2b0e:	20 32       	cpi	r18, 0x20	; 32
    2b10:	a0 f4       	brcc	.+40     	; 0x2b3a <vfprintf+0xae>
    2b12:	8b 32       	cpi	r24, 0x2B	; 43
    2b14:	69 f0       	breq	.+26     	; 0x2b30 <vfprintf+0xa4>
    2b16:	30 f4       	brcc	.+12     	; 0x2b24 <vfprintf+0x98>
    2b18:	80 32       	cpi	r24, 0x20	; 32
    2b1a:	59 f0       	breq	.+22     	; 0x2b32 <vfprintf+0xa6>
    2b1c:	83 32       	cpi	r24, 0x23	; 35
    2b1e:	69 f4       	brne	.+26     	; 0x2b3a <vfprintf+0xae>
    2b20:	20 61       	ori	r18, 0x10	; 16
    2b22:	2c c0       	rjmp	.+88     	; 0x2b7c <vfprintf+0xf0>
    2b24:	8d 32       	cpi	r24, 0x2D	; 45
    2b26:	39 f0       	breq	.+14     	; 0x2b36 <vfprintf+0xaa>
    2b28:	80 33       	cpi	r24, 0x30	; 48
    2b2a:	39 f4       	brne	.+14     	; 0x2b3a <vfprintf+0xae>
    2b2c:	21 60       	ori	r18, 0x01	; 1
    2b2e:	26 c0       	rjmp	.+76     	; 0x2b7c <vfprintf+0xf0>
    2b30:	22 60       	ori	r18, 0x02	; 2
    2b32:	24 60       	ori	r18, 0x04	; 4
    2b34:	23 c0       	rjmp	.+70     	; 0x2b7c <vfprintf+0xf0>
    2b36:	28 60       	ori	r18, 0x08	; 8
    2b38:	21 c0       	rjmp	.+66     	; 0x2b7c <vfprintf+0xf0>
    2b3a:	27 fd       	sbrc	r18, 7
    2b3c:	27 c0       	rjmp	.+78     	; 0x2b8c <vfprintf+0x100>
    2b3e:	30 ed       	ldi	r19, 0xD0	; 208
    2b40:	38 0f       	add	r19, r24
    2b42:	3a 30       	cpi	r19, 0x0A	; 10
    2b44:	78 f4       	brcc	.+30     	; 0x2b64 <vfprintf+0xd8>
    2b46:	26 ff       	sbrs	r18, 6
    2b48:	06 c0       	rjmp	.+12     	; 0x2b56 <vfprintf+0xca>
    2b4a:	fa e0       	ldi	r31, 0x0A	; 10
    2b4c:	5f 9e       	mul	r5, r31
    2b4e:	30 0d       	add	r19, r0
    2b50:	11 24       	eor	r1, r1
    2b52:	53 2e       	mov	r5, r19
    2b54:	13 c0       	rjmp	.+38     	; 0x2b7c <vfprintf+0xf0>
    2b56:	8a e0       	ldi	r24, 0x0A	; 10
    2b58:	38 9e       	mul	r3, r24
    2b5a:	30 0d       	add	r19, r0
    2b5c:	11 24       	eor	r1, r1
    2b5e:	33 2e       	mov	r3, r19
    2b60:	20 62       	ori	r18, 0x20	; 32
    2b62:	0c c0       	rjmp	.+24     	; 0x2b7c <vfprintf+0xf0>
    2b64:	8e 32       	cpi	r24, 0x2E	; 46
    2b66:	21 f4       	brne	.+8      	; 0x2b70 <vfprintf+0xe4>
    2b68:	26 fd       	sbrc	r18, 6
    2b6a:	5f c1       	rjmp	.+702    	; 0x2e2a <vfprintf+0x39e>
    2b6c:	20 64       	ori	r18, 0x40	; 64
    2b6e:	06 c0       	rjmp	.+12     	; 0x2b7c <vfprintf+0xf0>
    2b70:	8c 36       	cpi	r24, 0x6C	; 108
    2b72:	11 f4       	brne	.+4      	; 0x2b78 <vfprintf+0xec>
    2b74:	20 68       	ori	r18, 0x80	; 128
    2b76:	02 c0       	rjmp	.+4      	; 0x2b7c <vfprintf+0xf0>
    2b78:	88 36       	cpi	r24, 0x68	; 104
    2b7a:	41 f4       	brne	.+16     	; 0x2b8c <vfprintf+0x100>
    2b7c:	f6 01       	movw	r30, r12
    2b7e:	93 fd       	sbrc	r25, 3
    2b80:	85 91       	lpm	r24, Z+
    2b82:	93 ff       	sbrs	r25, 3
    2b84:	81 91       	ld	r24, Z+
    2b86:	6f 01       	movw	r12, r30
    2b88:	81 11       	cpse	r24, r1
    2b8a:	c1 cf       	rjmp	.-126    	; 0x2b0e <vfprintf+0x82>
    2b8c:	98 2f       	mov	r25, r24
    2b8e:	9f 7d       	andi	r25, 0xDF	; 223
    2b90:	95 54       	subi	r25, 0x45	; 69
    2b92:	93 30       	cpi	r25, 0x03	; 3
    2b94:	28 f4       	brcc	.+10     	; 0x2ba0 <vfprintf+0x114>
    2b96:	0c 5f       	subi	r16, 0xFC	; 252
    2b98:	1f 4f       	sbci	r17, 0xFF	; 255
    2b9a:	ff e3       	ldi	r31, 0x3F	; 63
    2b9c:	f9 83       	std	Y+1, r31	; 0x01
    2b9e:	0d c0       	rjmp	.+26     	; 0x2bba <vfprintf+0x12e>
    2ba0:	83 36       	cpi	r24, 0x63	; 99
    2ba2:	31 f0       	breq	.+12     	; 0x2bb0 <vfprintf+0x124>
    2ba4:	83 37       	cpi	r24, 0x73	; 115
    2ba6:	71 f0       	breq	.+28     	; 0x2bc4 <vfprintf+0x138>
    2ba8:	83 35       	cpi	r24, 0x53	; 83
    2baa:	09 f0       	breq	.+2      	; 0x2bae <vfprintf+0x122>
    2bac:	57 c0       	rjmp	.+174    	; 0x2c5c <vfprintf+0x1d0>
    2bae:	21 c0       	rjmp	.+66     	; 0x2bf2 <vfprintf+0x166>
    2bb0:	f8 01       	movw	r30, r16
    2bb2:	80 81       	ld	r24, Z
    2bb4:	89 83       	std	Y+1, r24	; 0x01
    2bb6:	0e 5f       	subi	r16, 0xFE	; 254
    2bb8:	1f 4f       	sbci	r17, 0xFF	; 255
    2bba:	44 24       	eor	r4, r4
    2bbc:	43 94       	inc	r4
    2bbe:	51 2c       	mov	r5, r1
    2bc0:	54 01       	movw	r10, r8
    2bc2:	14 c0       	rjmp	.+40     	; 0x2bec <vfprintf+0x160>
    2bc4:	38 01       	movw	r6, r16
    2bc6:	f2 e0       	ldi	r31, 0x02	; 2
    2bc8:	6f 0e       	add	r6, r31
    2bca:	71 1c       	adc	r7, r1
    2bcc:	f8 01       	movw	r30, r16
    2bce:	a0 80       	ld	r10, Z
    2bd0:	b1 80       	ldd	r11, Z+1	; 0x01
    2bd2:	26 ff       	sbrs	r18, 6
    2bd4:	03 c0       	rjmp	.+6      	; 0x2bdc <vfprintf+0x150>
    2bd6:	65 2d       	mov	r22, r5
    2bd8:	70 e0       	ldi	r23, 0x00	; 0
    2bda:	02 c0       	rjmp	.+4      	; 0x2be0 <vfprintf+0x154>
    2bdc:	6f ef       	ldi	r22, 0xFF	; 255
    2bde:	7f ef       	ldi	r23, 0xFF	; 255
    2be0:	c5 01       	movw	r24, r10
    2be2:	2c 87       	std	Y+12, r18	; 0x0c
    2be4:	4c d1       	rcall	.+664    	; 0x2e7e <strnlen>
    2be6:	2c 01       	movw	r4, r24
    2be8:	83 01       	movw	r16, r6
    2bea:	2c 85       	ldd	r18, Y+12	; 0x0c
    2bec:	2f 77       	andi	r18, 0x7F	; 127
    2bee:	22 2e       	mov	r2, r18
    2bf0:	16 c0       	rjmp	.+44     	; 0x2c1e <vfprintf+0x192>
    2bf2:	38 01       	movw	r6, r16
    2bf4:	f2 e0       	ldi	r31, 0x02	; 2
    2bf6:	6f 0e       	add	r6, r31
    2bf8:	71 1c       	adc	r7, r1
    2bfa:	f8 01       	movw	r30, r16
    2bfc:	a0 80       	ld	r10, Z
    2bfe:	b1 80       	ldd	r11, Z+1	; 0x01
    2c00:	26 ff       	sbrs	r18, 6
    2c02:	03 c0       	rjmp	.+6      	; 0x2c0a <vfprintf+0x17e>
    2c04:	65 2d       	mov	r22, r5
    2c06:	70 e0       	ldi	r23, 0x00	; 0
    2c08:	02 c0       	rjmp	.+4      	; 0x2c0e <vfprintf+0x182>
    2c0a:	6f ef       	ldi	r22, 0xFF	; 255
    2c0c:	7f ef       	ldi	r23, 0xFF	; 255
    2c0e:	c5 01       	movw	r24, r10
    2c10:	2c 87       	std	Y+12, r18	; 0x0c
    2c12:	2a d1       	rcall	.+596    	; 0x2e68 <strnlen_P>
    2c14:	2c 01       	movw	r4, r24
    2c16:	2c 85       	ldd	r18, Y+12	; 0x0c
    2c18:	20 68       	ori	r18, 0x80	; 128
    2c1a:	22 2e       	mov	r2, r18
    2c1c:	83 01       	movw	r16, r6
    2c1e:	23 fc       	sbrc	r2, 3
    2c20:	19 c0       	rjmp	.+50     	; 0x2c54 <vfprintf+0x1c8>
    2c22:	83 2d       	mov	r24, r3
    2c24:	90 e0       	ldi	r25, 0x00	; 0
    2c26:	48 16       	cp	r4, r24
    2c28:	59 06       	cpc	r5, r25
    2c2a:	a0 f4       	brcc	.+40     	; 0x2c54 <vfprintf+0x1c8>
    2c2c:	b7 01       	movw	r22, r14
    2c2e:	80 e2       	ldi	r24, 0x20	; 32
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	30 d1       	rcall	.+608    	; 0x2e94 <fputc>
    2c34:	3a 94       	dec	r3
    2c36:	f5 cf       	rjmp	.-22     	; 0x2c22 <vfprintf+0x196>
    2c38:	f5 01       	movw	r30, r10
    2c3a:	27 fc       	sbrc	r2, 7
    2c3c:	85 91       	lpm	r24, Z+
    2c3e:	27 fe       	sbrs	r2, 7
    2c40:	81 91       	ld	r24, Z+
    2c42:	5f 01       	movw	r10, r30
    2c44:	b7 01       	movw	r22, r14
    2c46:	90 e0       	ldi	r25, 0x00	; 0
    2c48:	25 d1       	rcall	.+586    	; 0x2e94 <fputc>
    2c4a:	31 10       	cpse	r3, r1
    2c4c:	3a 94       	dec	r3
    2c4e:	f1 e0       	ldi	r31, 0x01	; 1
    2c50:	4f 1a       	sub	r4, r31
    2c52:	51 08       	sbc	r5, r1
    2c54:	41 14       	cp	r4, r1
    2c56:	51 04       	cpc	r5, r1
    2c58:	79 f7       	brne	.-34     	; 0x2c38 <vfprintf+0x1ac>
    2c5a:	de c0       	rjmp	.+444    	; 0x2e18 <vfprintf+0x38c>
    2c5c:	84 36       	cpi	r24, 0x64	; 100
    2c5e:	11 f0       	breq	.+4      	; 0x2c64 <vfprintf+0x1d8>
    2c60:	89 36       	cpi	r24, 0x69	; 105
    2c62:	31 f5       	brne	.+76     	; 0x2cb0 <vfprintf+0x224>
    2c64:	f8 01       	movw	r30, r16
    2c66:	27 ff       	sbrs	r18, 7
    2c68:	07 c0       	rjmp	.+14     	; 0x2c78 <vfprintf+0x1ec>
    2c6a:	60 81       	ld	r22, Z
    2c6c:	71 81       	ldd	r23, Z+1	; 0x01
    2c6e:	82 81       	ldd	r24, Z+2	; 0x02
    2c70:	93 81       	ldd	r25, Z+3	; 0x03
    2c72:	0c 5f       	subi	r16, 0xFC	; 252
    2c74:	1f 4f       	sbci	r17, 0xFF	; 255
    2c76:	08 c0       	rjmp	.+16     	; 0x2c88 <vfprintf+0x1fc>
    2c78:	60 81       	ld	r22, Z
    2c7a:	71 81       	ldd	r23, Z+1	; 0x01
    2c7c:	88 27       	eor	r24, r24
    2c7e:	77 fd       	sbrc	r23, 7
    2c80:	80 95       	com	r24
    2c82:	98 2f       	mov	r25, r24
    2c84:	0e 5f       	subi	r16, 0xFE	; 254
    2c86:	1f 4f       	sbci	r17, 0xFF	; 255
    2c88:	2f 76       	andi	r18, 0x6F	; 111
    2c8a:	b2 2e       	mov	r11, r18
    2c8c:	97 ff       	sbrs	r25, 7
    2c8e:	09 c0       	rjmp	.+18     	; 0x2ca2 <vfprintf+0x216>
    2c90:	90 95       	com	r25
    2c92:	80 95       	com	r24
    2c94:	70 95       	com	r23
    2c96:	61 95       	neg	r22
    2c98:	7f 4f       	sbci	r23, 0xFF	; 255
    2c9a:	8f 4f       	sbci	r24, 0xFF	; 255
    2c9c:	9f 4f       	sbci	r25, 0xFF	; 255
    2c9e:	20 68       	ori	r18, 0x80	; 128
    2ca0:	b2 2e       	mov	r11, r18
    2ca2:	2a e0       	ldi	r18, 0x0A	; 10
    2ca4:	30 e0       	ldi	r19, 0x00	; 0
    2ca6:	a4 01       	movw	r20, r8
    2ca8:	27 d1       	rcall	.+590    	; 0x2ef8 <__ultoa_invert>
    2caa:	a8 2e       	mov	r10, r24
    2cac:	a8 18       	sub	r10, r8
    2cae:	43 c0       	rjmp	.+134    	; 0x2d36 <vfprintf+0x2aa>
    2cb0:	85 37       	cpi	r24, 0x75	; 117
    2cb2:	29 f4       	brne	.+10     	; 0x2cbe <vfprintf+0x232>
    2cb4:	2f 7e       	andi	r18, 0xEF	; 239
    2cb6:	b2 2e       	mov	r11, r18
    2cb8:	2a e0       	ldi	r18, 0x0A	; 10
    2cba:	30 e0       	ldi	r19, 0x00	; 0
    2cbc:	25 c0       	rjmp	.+74     	; 0x2d08 <vfprintf+0x27c>
    2cbe:	f2 2f       	mov	r31, r18
    2cc0:	f9 7f       	andi	r31, 0xF9	; 249
    2cc2:	bf 2e       	mov	r11, r31
    2cc4:	8f 36       	cpi	r24, 0x6F	; 111
    2cc6:	c1 f0       	breq	.+48     	; 0x2cf8 <vfprintf+0x26c>
    2cc8:	18 f4       	brcc	.+6      	; 0x2cd0 <vfprintf+0x244>
    2cca:	88 35       	cpi	r24, 0x58	; 88
    2ccc:	79 f0       	breq	.+30     	; 0x2cec <vfprintf+0x260>
    2cce:	ad c0       	rjmp	.+346    	; 0x2e2a <vfprintf+0x39e>
    2cd0:	80 37       	cpi	r24, 0x70	; 112
    2cd2:	19 f0       	breq	.+6      	; 0x2cda <vfprintf+0x24e>
    2cd4:	88 37       	cpi	r24, 0x78	; 120
    2cd6:	21 f0       	breq	.+8      	; 0x2ce0 <vfprintf+0x254>
    2cd8:	a8 c0       	rjmp	.+336    	; 0x2e2a <vfprintf+0x39e>
    2cda:	2f 2f       	mov	r18, r31
    2cdc:	20 61       	ori	r18, 0x10	; 16
    2cde:	b2 2e       	mov	r11, r18
    2ce0:	b4 fe       	sbrs	r11, 4
    2ce2:	0d c0       	rjmp	.+26     	; 0x2cfe <vfprintf+0x272>
    2ce4:	8b 2d       	mov	r24, r11
    2ce6:	84 60       	ori	r24, 0x04	; 4
    2ce8:	b8 2e       	mov	r11, r24
    2cea:	09 c0       	rjmp	.+18     	; 0x2cfe <vfprintf+0x272>
    2cec:	24 ff       	sbrs	r18, 4
    2cee:	0a c0       	rjmp	.+20     	; 0x2d04 <vfprintf+0x278>
    2cf0:	9f 2f       	mov	r25, r31
    2cf2:	96 60       	ori	r25, 0x06	; 6
    2cf4:	b9 2e       	mov	r11, r25
    2cf6:	06 c0       	rjmp	.+12     	; 0x2d04 <vfprintf+0x278>
    2cf8:	28 e0       	ldi	r18, 0x08	; 8
    2cfa:	30 e0       	ldi	r19, 0x00	; 0
    2cfc:	05 c0       	rjmp	.+10     	; 0x2d08 <vfprintf+0x27c>
    2cfe:	20 e1       	ldi	r18, 0x10	; 16
    2d00:	30 e0       	ldi	r19, 0x00	; 0
    2d02:	02 c0       	rjmp	.+4      	; 0x2d08 <vfprintf+0x27c>
    2d04:	20 e1       	ldi	r18, 0x10	; 16
    2d06:	32 e0       	ldi	r19, 0x02	; 2
    2d08:	f8 01       	movw	r30, r16
    2d0a:	b7 fe       	sbrs	r11, 7
    2d0c:	07 c0       	rjmp	.+14     	; 0x2d1c <vfprintf+0x290>
    2d0e:	60 81       	ld	r22, Z
    2d10:	71 81       	ldd	r23, Z+1	; 0x01
    2d12:	82 81       	ldd	r24, Z+2	; 0x02
    2d14:	93 81       	ldd	r25, Z+3	; 0x03
    2d16:	0c 5f       	subi	r16, 0xFC	; 252
    2d18:	1f 4f       	sbci	r17, 0xFF	; 255
    2d1a:	06 c0       	rjmp	.+12     	; 0x2d28 <vfprintf+0x29c>
    2d1c:	60 81       	ld	r22, Z
    2d1e:	71 81       	ldd	r23, Z+1	; 0x01
    2d20:	80 e0       	ldi	r24, 0x00	; 0
    2d22:	90 e0       	ldi	r25, 0x00	; 0
    2d24:	0e 5f       	subi	r16, 0xFE	; 254
    2d26:	1f 4f       	sbci	r17, 0xFF	; 255
    2d28:	a4 01       	movw	r20, r8
    2d2a:	e6 d0       	rcall	.+460    	; 0x2ef8 <__ultoa_invert>
    2d2c:	a8 2e       	mov	r10, r24
    2d2e:	a8 18       	sub	r10, r8
    2d30:	fb 2d       	mov	r31, r11
    2d32:	ff 77       	andi	r31, 0x7F	; 127
    2d34:	bf 2e       	mov	r11, r31
    2d36:	b6 fe       	sbrs	r11, 6
    2d38:	0b c0       	rjmp	.+22     	; 0x2d50 <vfprintf+0x2c4>
    2d3a:	2b 2d       	mov	r18, r11
    2d3c:	2e 7f       	andi	r18, 0xFE	; 254
    2d3e:	a5 14       	cp	r10, r5
    2d40:	50 f4       	brcc	.+20     	; 0x2d56 <vfprintf+0x2ca>
    2d42:	b4 fe       	sbrs	r11, 4
    2d44:	0a c0       	rjmp	.+20     	; 0x2d5a <vfprintf+0x2ce>
    2d46:	b2 fc       	sbrc	r11, 2
    2d48:	08 c0       	rjmp	.+16     	; 0x2d5a <vfprintf+0x2ce>
    2d4a:	2b 2d       	mov	r18, r11
    2d4c:	2e 7e       	andi	r18, 0xEE	; 238
    2d4e:	05 c0       	rjmp	.+10     	; 0x2d5a <vfprintf+0x2ce>
    2d50:	7a 2c       	mov	r7, r10
    2d52:	2b 2d       	mov	r18, r11
    2d54:	03 c0       	rjmp	.+6      	; 0x2d5c <vfprintf+0x2d0>
    2d56:	7a 2c       	mov	r7, r10
    2d58:	01 c0       	rjmp	.+2      	; 0x2d5c <vfprintf+0x2d0>
    2d5a:	75 2c       	mov	r7, r5
    2d5c:	24 ff       	sbrs	r18, 4
    2d5e:	0d c0       	rjmp	.+26     	; 0x2d7a <vfprintf+0x2ee>
    2d60:	fe 01       	movw	r30, r28
    2d62:	ea 0d       	add	r30, r10
    2d64:	f1 1d       	adc	r31, r1
    2d66:	80 81       	ld	r24, Z
    2d68:	80 33       	cpi	r24, 0x30	; 48
    2d6a:	11 f4       	brne	.+4      	; 0x2d70 <vfprintf+0x2e4>
    2d6c:	29 7e       	andi	r18, 0xE9	; 233
    2d6e:	09 c0       	rjmp	.+18     	; 0x2d82 <vfprintf+0x2f6>
    2d70:	22 ff       	sbrs	r18, 2
    2d72:	06 c0       	rjmp	.+12     	; 0x2d80 <vfprintf+0x2f4>
    2d74:	73 94       	inc	r7
    2d76:	73 94       	inc	r7
    2d78:	04 c0       	rjmp	.+8      	; 0x2d82 <vfprintf+0x2f6>
    2d7a:	82 2f       	mov	r24, r18
    2d7c:	86 78       	andi	r24, 0x86	; 134
    2d7e:	09 f0       	breq	.+2      	; 0x2d82 <vfprintf+0x2f6>
    2d80:	73 94       	inc	r7
    2d82:	23 fd       	sbrc	r18, 3
    2d84:	12 c0       	rjmp	.+36     	; 0x2daa <vfprintf+0x31e>
    2d86:	20 ff       	sbrs	r18, 0
    2d88:	06 c0       	rjmp	.+12     	; 0x2d96 <vfprintf+0x30a>
    2d8a:	5a 2c       	mov	r5, r10
    2d8c:	73 14       	cp	r7, r3
    2d8e:	18 f4       	brcc	.+6      	; 0x2d96 <vfprintf+0x30a>
    2d90:	53 0c       	add	r5, r3
    2d92:	57 18       	sub	r5, r7
    2d94:	73 2c       	mov	r7, r3
    2d96:	73 14       	cp	r7, r3
    2d98:	60 f4       	brcc	.+24     	; 0x2db2 <vfprintf+0x326>
    2d9a:	b7 01       	movw	r22, r14
    2d9c:	80 e2       	ldi	r24, 0x20	; 32
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	2c 87       	std	Y+12, r18	; 0x0c
    2da2:	78 d0       	rcall	.+240    	; 0x2e94 <fputc>
    2da4:	73 94       	inc	r7
    2da6:	2c 85       	ldd	r18, Y+12	; 0x0c
    2da8:	f6 cf       	rjmp	.-20     	; 0x2d96 <vfprintf+0x30a>
    2daa:	73 14       	cp	r7, r3
    2dac:	10 f4       	brcc	.+4      	; 0x2db2 <vfprintf+0x326>
    2dae:	37 18       	sub	r3, r7
    2db0:	01 c0       	rjmp	.+2      	; 0x2db4 <vfprintf+0x328>
    2db2:	31 2c       	mov	r3, r1
    2db4:	24 ff       	sbrs	r18, 4
    2db6:	11 c0       	rjmp	.+34     	; 0x2dda <vfprintf+0x34e>
    2db8:	b7 01       	movw	r22, r14
    2dba:	80 e3       	ldi	r24, 0x30	; 48
    2dbc:	90 e0       	ldi	r25, 0x00	; 0
    2dbe:	2c 87       	std	Y+12, r18	; 0x0c
    2dc0:	69 d0       	rcall	.+210    	; 0x2e94 <fputc>
    2dc2:	2c 85       	ldd	r18, Y+12	; 0x0c
    2dc4:	22 ff       	sbrs	r18, 2
    2dc6:	16 c0       	rjmp	.+44     	; 0x2df4 <vfprintf+0x368>
    2dc8:	21 ff       	sbrs	r18, 1
    2dca:	03 c0       	rjmp	.+6      	; 0x2dd2 <vfprintf+0x346>
    2dcc:	88 e5       	ldi	r24, 0x58	; 88
    2dce:	90 e0       	ldi	r25, 0x00	; 0
    2dd0:	02 c0       	rjmp	.+4      	; 0x2dd6 <vfprintf+0x34a>
    2dd2:	88 e7       	ldi	r24, 0x78	; 120
    2dd4:	90 e0       	ldi	r25, 0x00	; 0
    2dd6:	b7 01       	movw	r22, r14
    2dd8:	0c c0       	rjmp	.+24     	; 0x2df2 <vfprintf+0x366>
    2dda:	82 2f       	mov	r24, r18
    2ddc:	86 78       	andi	r24, 0x86	; 134
    2dde:	51 f0       	breq	.+20     	; 0x2df4 <vfprintf+0x368>
    2de0:	21 fd       	sbrc	r18, 1
    2de2:	02 c0       	rjmp	.+4      	; 0x2de8 <vfprintf+0x35c>
    2de4:	80 e2       	ldi	r24, 0x20	; 32
    2de6:	01 c0       	rjmp	.+2      	; 0x2dea <vfprintf+0x35e>
    2de8:	8b e2       	ldi	r24, 0x2B	; 43
    2dea:	27 fd       	sbrc	r18, 7
    2dec:	8d e2       	ldi	r24, 0x2D	; 45
    2dee:	b7 01       	movw	r22, r14
    2df0:	90 e0       	ldi	r25, 0x00	; 0
    2df2:	50 d0       	rcall	.+160    	; 0x2e94 <fputc>
    2df4:	a5 14       	cp	r10, r5
    2df6:	30 f4       	brcc	.+12     	; 0x2e04 <vfprintf+0x378>
    2df8:	b7 01       	movw	r22, r14
    2dfa:	80 e3       	ldi	r24, 0x30	; 48
    2dfc:	90 e0       	ldi	r25, 0x00	; 0
    2dfe:	4a d0       	rcall	.+148    	; 0x2e94 <fputc>
    2e00:	5a 94       	dec	r5
    2e02:	f8 cf       	rjmp	.-16     	; 0x2df4 <vfprintf+0x368>
    2e04:	aa 94       	dec	r10
    2e06:	f4 01       	movw	r30, r8
    2e08:	ea 0d       	add	r30, r10
    2e0a:	f1 1d       	adc	r31, r1
    2e0c:	80 81       	ld	r24, Z
    2e0e:	b7 01       	movw	r22, r14
    2e10:	90 e0       	ldi	r25, 0x00	; 0
    2e12:	40 d0       	rcall	.+128    	; 0x2e94 <fputc>
    2e14:	a1 10       	cpse	r10, r1
    2e16:	f6 cf       	rjmp	.-20     	; 0x2e04 <vfprintf+0x378>
    2e18:	33 20       	and	r3, r3
    2e1a:	09 f4       	brne	.+2      	; 0x2e1e <vfprintf+0x392>
    2e1c:	5d ce       	rjmp	.-838    	; 0x2ad8 <vfprintf+0x4c>
    2e1e:	b7 01       	movw	r22, r14
    2e20:	80 e2       	ldi	r24, 0x20	; 32
    2e22:	90 e0       	ldi	r25, 0x00	; 0
    2e24:	37 d0       	rcall	.+110    	; 0x2e94 <fputc>
    2e26:	3a 94       	dec	r3
    2e28:	f7 cf       	rjmp	.-18     	; 0x2e18 <vfprintf+0x38c>
    2e2a:	f7 01       	movw	r30, r14
    2e2c:	86 81       	ldd	r24, Z+6	; 0x06
    2e2e:	97 81       	ldd	r25, Z+7	; 0x07
    2e30:	02 c0       	rjmp	.+4      	; 0x2e36 <vfprintf+0x3aa>
    2e32:	8f ef       	ldi	r24, 0xFF	; 255
    2e34:	9f ef       	ldi	r25, 0xFF	; 255
    2e36:	2c 96       	adiw	r28, 0x0c	; 12
    2e38:	0f b6       	in	r0, 0x3f	; 63
    2e3a:	f8 94       	cli
    2e3c:	de bf       	out	0x3e, r29	; 62
    2e3e:	0f be       	out	0x3f, r0	; 63
    2e40:	cd bf       	out	0x3d, r28	; 61
    2e42:	df 91       	pop	r29
    2e44:	cf 91       	pop	r28
    2e46:	1f 91       	pop	r17
    2e48:	0f 91       	pop	r16
    2e4a:	ff 90       	pop	r15
    2e4c:	ef 90       	pop	r14
    2e4e:	df 90       	pop	r13
    2e50:	cf 90       	pop	r12
    2e52:	bf 90       	pop	r11
    2e54:	af 90       	pop	r10
    2e56:	9f 90       	pop	r9
    2e58:	8f 90       	pop	r8
    2e5a:	7f 90       	pop	r7
    2e5c:	6f 90       	pop	r6
    2e5e:	5f 90       	pop	r5
    2e60:	4f 90       	pop	r4
    2e62:	3f 90       	pop	r3
    2e64:	2f 90       	pop	r2
    2e66:	08 95       	ret

00002e68 <strnlen_P>:
    2e68:	fc 01       	movw	r30, r24
    2e6a:	05 90       	lpm	r0, Z+
    2e6c:	61 50       	subi	r22, 0x01	; 1
    2e6e:	70 40       	sbci	r23, 0x00	; 0
    2e70:	01 10       	cpse	r0, r1
    2e72:	d8 f7       	brcc	.-10     	; 0x2e6a <strnlen_P+0x2>
    2e74:	80 95       	com	r24
    2e76:	90 95       	com	r25
    2e78:	8e 0f       	add	r24, r30
    2e7a:	9f 1f       	adc	r25, r31
    2e7c:	08 95       	ret

00002e7e <strnlen>:
    2e7e:	fc 01       	movw	r30, r24
    2e80:	61 50       	subi	r22, 0x01	; 1
    2e82:	70 40       	sbci	r23, 0x00	; 0
    2e84:	01 90       	ld	r0, Z+
    2e86:	01 10       	cpse	r0, r1
    2e88:	d8 f7       	brcc	.-10     	; 0x2e80 <strnlen+0x2>
    2e8a:	80 95       	com	r24
    2e8c:	90 95       	com	r25
    2e8e:	8e 0f       	add	r24, r30
    2e90:	9f 1f       	adc	r25, r31
    2e92:	08 95       	ret

00002e94 <fputc>:
    2e94:	0f 93       	push	r16
    2e96:	1f 93       	push	r17
    2e98:	cf 93       	push	r28
    2e9a:	df 93       	push	r29
    2e9c:	18 2f       	mov	r17, r24
    2e9e:	09 2f       	mov	r16, r25
    2ea0:	eb 01       	movw	r28, r22
    2ea2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea4:	81 fd       	sbrc	r24, 1
    2ea6:	03 c0       	rjmp	.+6      	; 0x2eae <fputc+0x1a>
    2ea8:	8f ef       	ldi	r24, 0xFF	; 255
    2eaa:	9f ef       	ldi	r25, 0xFF	; 255
    2eac:	20 c0       	rjmp	.+64     	; 0x2eee <fputc+0x5a>
    2eae:	82 ff       	sbrs	r24, 2
    2eb0:	10 c0       	rjmp	.+32     	; 0x2ed2 <fputc+0x3e>
    2eb2:	4e 81       	ldd	r20, Y+6	; 0x06
    2eb4:	5f 81       	ldd	r21, Y+7	; 0x07
    2eb6:	2c 81       	ldd	r18, Y+4	; 0x04
    2eb8:	3d 81       	ldd	r19, Y+5	; 0x05
    2eba:	42 17       	cp	r20, r18
    2ebc:	53 07       	cpc	r21, r19
    2ebe:	7c f4       	brge	.+30     	; 0x2ede <fputc+0x4a>
    2ec0:	e8 81       	ld	r30, Y
    2ec2:	f9 81       	ldd	r31, Y+1	; 0x01
    2ec4:	9f 01       	movw	r18, r30
    2ec6:	2f 5f       	subi	r18, 0xFF	; 255
    2ec8:	3f 4f       	sbci	r19, 0xFF	; 255
    2eca:	39 83       	std	Y+1, r19	; 0x01
    2ecc:	28 83       	st	Y, r18
    2ece:	10 83       	st	Z, r17
    2ed0:	06 c0       	rjmp	.+12     	; 0x2ede <fputc+0x4a>
    2ed2:	e8 85       	ldd	r30, Y+8	; 0x08
    2ed4:	f9 85       	ldd	r31, Y+9	; 0x09
    2ed6:	81 2f       	mov	r24, r17
    2ed8:	19 95       	eicall
    2eda:	89 2b       	or	r24, r25
    2edc:	29 f7       	brne	.-54     	; 0x2ea8 <fputc+0x14>
    2ede:	2e 81       	ldd	r18, Y+6	; 0x06
    2ee0:	3f 81       	ldd	r19, Y+7	; 0x07
    2ee2:	2f 5f       	subi	r18, 0xFF	; 255
    2ee4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ee6:	3f 83       	std	Y+7, r19	; 0x07
    2ee8:	2e 83       	std	Y+6, r18	; 0x06
    2eea:	81 2f       	mov	r24, r17
    2eec:	90 2f       	mov	r25, r16
    2eee:	df 91       	pop	r29
    2ef0:	cf 91       	pop	r28
    2ef2:	1f 91       	pop	r17
    2ef4:	0f 91       	pop	r16
    2ef6:	08 95       	ret

00002ef8 <__ultoa_invert>:
    2ef8:	fa 01       	movw	r30, r20
    2efa:	aa 27       	eor	r26, r26
    2efc:	28 30       	cpi	r18, 0x08	; 8
    2efe:	51 f1       	breq	.+84     	; 0x2f54 <__ultoa_invert+0x5c>
    2f00:	20 31       	cpi	r18, 0x10	; 16
    2f02:	81 f1       	breq	.+96     	; 0x2f64 <__ultoa_invert+0x6c>
    2f04:	e8 94       	clt
    2f06:	6f 93       	push	r22
    2f08:	6e 7f       	andi	r22, 0xFE	; 254
    2f0a:	6e 5f       	subi	r22, 0xFE	; 254
    2f0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f0e:	8f 4f       	sbci	r24, 0xFF	; 255
    2f10:	9f 4f       	sbci	r25, 0xFF	; 255
    2f12:	af 4f       	sbci	r26, 0xFF	; 255
    2f14:	b1 e0       	ldi	r27, 0x01	; 1
    2f16:	3e d0       	rcall	.+124    	; 0x2f94 <__ultoa_invert+0x9c>
    2f18:	b4 e0       	ldi	r27, 0x04	; 4
    2f1a:	3c d0       	rcall	.+120    	; 0x2f94 <__ultoa_invert+0x9c>
    2f1c:	67 0f       	add	r22, r23
    2f1e:	78 1f       	adc	r23, r24
    2f20:	89 1f       	adc	r24, r25
    2f22:	9a 1f       	adc	r25, r26
    2f24:	a1 1d       	adc	r26, r1
    2f26:	68 0f       	add	r22, r24
    2f28:	79 1f       	adc	r23, r25
    2f2a:	8a 1f       	adc	r24, r26
    2f2c:	91 1d       	adc	r25, r1
    2f2e:	a1 1d       	adc	r26, r1
    2f30:	6a 0f       	add	r22, r26
    2f32:	71 1d       	adc	r23, r1
    2f34:	81 1d       	adc	r24, r1
    2f36:	91 1d       	adc	r25, r1
    2f38:	a1 1d       	adc	r26, r1
    2f3a:	20 d0       	rcall	.+64     	; 0x2f7c <__ultoa_invert+0x84>
    2f3c:	09 f4       	brne	.+2      	; 0x2f40 <__ultoa_invert+0x48>
    2f3e:	68 94       	set
    2f40:	3f 91       	pop	r19
    2f42:	2a e0       	ldi	r18, 0x0A	; 10
    2f44:	26 9f       	mul	r18, r22
    2f46:	11 24       	eor	r1, r1
    2f48:	30 19       	sub	r19, r0
    2f4a:	30 5d       	subi	r19, 0xD0	; 208
    2f4c:	31 93       	st	Z+, r19
    2f4e:	de f6       	brtc	.-74     	; 0x2f06 <__ultoa_invert+0xe>
    2f50:	cf 01       	movw	r24, r30
    2f52:	08 95       	ret
    2f54:	46 2f       	mov	r20, r22
    2f56:	47 70       	andi	r20, 0x07	; 7
    2f58:	40 5d       	subi	r20, 0xD0	; 208
    2f5a:	41 93       	st	Z+, r20
    2f5c:	b3 e0       	ldi	r27, 0x03	; 3
    2f5e:	0f d0       	rcall	.+30     	; 0x2f7e <__ultoa_invert+0x86>
    2f60:	c9 f7       	brne	.-14     	; 0x2f54 <__ultoa_invert+0x5c>
    2f62:	f6 cf       	rjmp	.-20     	; 0x2f50 <__ultoa_invert+0x58>
    2f64:	46 2f       	mov	r20, r22
    2f66:	4f 70       	andi	r20, 0x0F	; 15
    2f68:	40 5d       	subi	r20, 0xD0	; 208
    2f6a:	4a 33       	cpi	r20, 0x3A	; 58
    2f6c:	18 f0       	brcs	.+6      	; 0x2f74 <__ultoa_invert+0x7c>
    2f6e:	49 5d       	subi	r20, 0xD9	; 217
    2f70:	31 fd       	sbrc	r19, 1
    2f72:	40 52       	subi	r20, 0x20	; 32
    2f74:	41 93       	st	Z+, r20
    2f76:	02 d0       	rcall	.+4      	; 0x2f7c <__ultoa_invert+0x84>
    2f78:	a9 f7       	brne	.-22     	; 0x2f64 <__ultoa_invert+0x6c>
    2f7a:	ea cf       	rjmp	.-44     	; 0x2f50 <__ultoa_invert+0x58>
    2f7c:	b4 e0       	ldi	r27, 0x04	; 4
    2f7e:	a6 95       	lsr	r26
    2f80:	97 95       	ror	r25
    2f82:	87 95       	ror	r24
    2f84:	77 95       	ror	r23
    2f86:	67 95       	ror	r22
    2f88:	ba 95       	dec	r27
    2f8a:	c9 f7       	brne	.-14     	; 0x2f7e <__ultoa_invert+0x86>
    2f8c:	00 97       	sbiw	r24, 0x00	; 0
    2f8e:	61 05       	cpc	r22, r1
    2f90:	71 05       	cpc	r23, r1
    2f92:	08 95       	ret
    2f94:	9b 01       	movw	r18, r22
    2f96:	ac 01       	movw	r20, r24
    2f98:	0a 2e       	mov	r0, r26
    2f9a:	06 94       	lsr	r0
    2f9c:	57 95       	ror	r21
    2f9e:	47 95       	ror	r20
    2fa0:	37 95       	ror	r19
    2fa2:	27 95       	ror	r18
    2fa4:	ba 95       	dec	r27
    2fa6:	c9 f7       	brne	.-14     	; 0x2f9a <__ultoa_invert+0xa2>
    2fa8:	62 0f       	add	r22, r18
    2faa:	73 1f       	adc	r23, r19
    2fac:	84 1f       	adc	r24, r20
    2fae:	95 1f       	adc	r25, r21
    2fb0:	a0 1d       	adc	r26, r0
    2fb2:	08 95       	ret

00002fb4 <_exit>:
    2fb4:	f8 94       	cli

00002fb6 <__stop_program>:
    2fb6:	ff cf       	rjmp	.-2      	; 0x2fb6 <__stop_program>
